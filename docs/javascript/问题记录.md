# 问题记录

## Primitive & Object

在JS里头，也有几种基本数据类型，它们分别是 `string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`

primitive的特点就是immutable，也就是说它们不能被更改，不能被更改指的是，不能像数组，对象和函数那样地把自己的property和value给更改。如果一个primitive变量的值被更改了，那他就是被重新赋了个新值了。

> All primitives are immutable, i.e., they cannot be altered. It is important not to confuse a primitive itself with a variable assigned a primitive value. The variable may be reassigned a new value, but the existing value can not be changed in the ways that objects, arrays, and functions can be altered.

而对象类型的赋值就是赋引用reference了，这跟Java是差不多的

``` javascript
let a = { x: 114514 };
let b = a; // copy the reference and assign to b
b.x = 1919810;
console.log(a.x); // 1919810

let c = 114514;
let d = c; // assigning a new primitive, but not copying the reference
d = 1919810;
console.log(c); // 114514
```

## typeof keyword

要确定一个js变量的类型，可以使用`typeof`关键字

``` javascript
let i = 114
console.log(typeof i) // number

let f = () => console.log('dssq');
console.log(typeof f); // function
```

## let keyword

> The let statement declares a block-scoped local variable, optionally initializing it to a value.

跟全局变量var不一样，let声明的是个具有block-scope的本地变量，即它的作用域是在一个block内，并且在同一个块里面，我们**不能重复声明**同一个变量。比如我们这样做就会发生错误

``` javascript
let x = 1;
switch(x) {
  case 0:
    let foo;
    break;

  case 1:
    let foo; // SyntaxError for redeclaration.
    break;
}
```

而要做的，只需要把每个case后面的statement使用brace括起来就行了，比如

``` javascript
case 0: {
  let foo;
  break;
}
```

很多时候，`var`和`let`的行为都是差不多的，但是有几种情况。

``` javascript
function varTest() {
  var x = 1;
  {
    var x = 2;  // same variable!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

function letTest() {
  let x = 1;
  {
    let x = 2;  // different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
```

由于 let statement declares a block-scoped local variable，所以我们可以利用这个特性外加闭包来创建`private member`。比如这个

``` javascript
var Thing;

{
  let privateScope = new WeakMap();
  let counter = 0;

  Thing = function() {
    this.someProperty = 'foo';

    privateScope.set(this, {
      hidden: ++counter,
    });
  };

  Thing.prototype.showPublic = function() {
    return this.someProperty;
  };

  Thing.prototype.showPrivate = function() {
    return privateScope.get(this).hidden;
  };
}

console.log(typeof privateScope);
// "undefined"

var thing = new Thing();

console.log(thing);
// Thing {someProperty: "foo"}

thing.showPublic();
// "foo"

thing.showPrivate();
// 1
```

然后，let不会在global object上面创建一个property

> At the top level of programs and functions, let, unlike var, does not create a property on the global object.

``` javascript
var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
```

还有一个特性TDZ(temporal dead zone)，可以理解为在初始化之前被使用就会报错，而全局变量只会`undefined`，

``` javascript
{ // TDZ starts at beginning of scope
  console.log(bar); // undefined
  console.log(foo); // ReferenceError
  var bar = 1;
  let foo = 2; // End of TDZ (for foo)
}
```

## const keyword

这个和let是差不多的，只不过const的必须要初始化，并且不能被重新赋值。

## 运算符 || &&

> ||(Logic OR): If expr1 can be converted to true, returns expr1; else, returns expr2.
>
> &&(Logic AND): If expr1 can be converted to true, returns expr2; else, returns expr1.

这个在逻辑运算中是一样的了，只不过在js里头还能这样做

``` javascript
let a = undefined || 114514; // a = 114514
let b = undefined && 1919810; // b = undefined
let c = "you" || "me"; // c = you
let d = "you" && "me"; // d = me
```

欸，怎么理解和记忆呢？直接根据**短路运算**的规则来就行了，比如Logic OR，第一个true就扔回第一个，否则就会比较第二个，因此第一个false就会扔回第二个。Logic AND也是如此。

当然要注意哪些东西在js里头是false的

## Falsy values

下面这些表达式都是false的

- null
- NaN
- 0
- empty string ("" or '' or ``)
- undefined

## 原型链

一图以蔽之，只需要理解到

1. Function对象是一个比较特殊的对象，拥有prototype
2. prototype是函数的**原型对象**，即是调用这个Function所创建的对象的原型`__proto__`
3. `__proto__`的值是创建对象的对象

![wow prototype](./images/photo_2021-01-31_18-25-34.jpg)

一个对象在寻找property的时候，会从自己开始，要是自己没有，则顺着原型链即`__proto__`属性来找，直到找到了或碰到null为止。而`hasOwnProperty(property)`只会判断这个property是否是自己的，而不会通过原型链来找(毕竟叫做own property)

## setTimeout & setInterval

那就是`setTimeout`和`setInterval`了，之前一直不会英语，导致不知道是什么意思。现在literally读了一下，估计应该是：前者是在一段时间后执行，后者是以某一时间长短为间隔，反复执行。看起来没什么问题毕竟叫做是Timeout和Interval嘛。。。一查发现，的确如此

``` javascript
setTimeout()
Execute a specified block of code once after a specified time has elapsed.
setInterval()
Execute a specified block of code repeatedly with a fixed time delay between each call.
```

## apply & call

> The difference is that apply lets you invoke the function with arguments as an array; call requires the parameters be listed explicitly. A useful mnemonic is **"A for array and C for comma."**

就只是传arg的方式不是很一样而已，一个是数组，一个是正常的参数。

`func.apply(thisArg, [ argsArray])`

`func.call([thisArg[, arg1, arg2, ...argN]])`

The result of calling the function with the specified this value and arguments.

## bind

`let boundFunc = func.bind(thisArg[, arg1[, arg2[, ...argN]]])`

这个方法返回一个函数，这个函数有什么特别之处呢。特别之处就是这个函数的this是被bind了，bind就是对象`thisArg`。

具体怎么操作呢？见下代码

``` javascript
const mod = {
  value: 114514,
  getValue: function () {
    return this.value;
  }
};

const unboundGetValue = mod.getValue;
console.log(unboundGetValue());

const boundGetValue = mod.getValue.bind(mod);
console.log(boundGetValue());

// in nodejs
// the excepted output: undefined 114514
```

## script tag in HTML

这个要注意，因为HTML的加载，是从头加载到尾的，所以如果一个js有与DOM相关的操作，就要等物件都加载完了先。因此最好的方法是把`<script src=""></script>`放在body后面，而不是放在`<head>`里头。
