# 问题记录

[回到上一级](index.md)

这个页面，是用来记录自己路上所出现的问题的

- split()方法是如何进行字符串切割的?

记录时间：2020/12/29 16:57

emm这次竟然卡在String的split()方法里面了…不过这也证明了，我读文档的耐心程度还不够

![问题图](./images/20201229112401.jpg)

为什么会出现一个length为0的element呢…?想了想感觉是不是：因为是空格，所以直接把空格删掉，填个""上去充数了呢。结果读了文档才发现如下这么一段

`
The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string.
`

上面的这段话就是说，返回来的数组是包含着被原字符串中的子串所截断所产生的新String[]或因为没有符合的pattern而直接返回的包含一个原字符串的数组…

所以，要认真一点读文档，避免错失关键信息。

- print一个对象不加toString()，在此之后不能用加号拼接一个非String？

这个有点意思，我暂时还么有想到原因。

- 有了泛型擦除，但泛型类变量不能指向其他type parameter的对象？

注意这个坑，擦除是compile后擦掉的，而如`List<String>`和`List<Object>`这两个在compile的时候，是属于不同类型的。在Runtime上，它们才是属于同一类型`List`（被擦了）

因此kotlin的Array<>也不能做到jvav中`String[] a = new String[1];Object[] i = a;`的操作（

- Method reference与Lambda expression的关系？

简的来说，方法引用就是把一个方法当成Lambda表达式。目前我有在用，用在abstract method或者interface method的实现上。其实这个method reference在内部似乎是交给了java.util.function package里的class来处理了（这个没有深究，以后补上！）

怎么判断一个method reference能不能被使用，首先看一下这个方法，static method的话，直接看header中的return type和signature中的parameter是否一致，比如int(int, int)的抽象类或接口方法就可以接受int(int, int)的method reference。那么对于对象方法，由于this会作为第一个参数传入。一个实例方法如int(String)可以被这样的方法：int(String, String)使用，因为这个实例方法的static样子就是int(this, String)即int(String, String)

constructor也可以当成reference来传的，这个我没有研究过。

- static block

这个问题是我在看到`Integer.java`源码之后，才想去了解下的。

- inner interface

这个东东是我在`Map.java`里看到有的，之前没见过，准备有空就去了解下。

- 详细了解Lambda表达式

这个嘛，书上本来说Lambda是个匿名类，但是发现作用域有点不同，所以决定深入看看。（待更）

- 为什么内部类只能访问final or effectively final的变量？

~~这似乎跟内部实现有关，暂时先记住这个rule吧，以后有空再去慢慢摸清。~~已经出文章，详情请看我博客：[点击前往](https://blog.situ2001.com/contents/3b19f30c2f96/)

## Java的Enumerated Type（枚举类型）

这个我的教材没有详细讲，而是将这玩意放在了Appendix里头，那么按理来说就是比较好理解了。

例子如下，其实枚举类型的结构跟class也是差不多的（这玩意也是一个class哦），自带`name()`和`ordinate()`方法，又因为`extends Object implements Comparable`，所以有`compareTo()`和Object自带的方法。下面这个例子就啥都涉及到了，里面有data field, method和constructor。而枚举的元素这样写，相当于new一个实例罢了。

``` java
package appendixH;

public enum TrafficLight {
    RED("Please stop"), GREEN("Please go"),
    YELLOW("Please caution");

    private final String description;

    private TrafficLight(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}

class TestTrafficLight {
    public static void main(String[] args) {
        TrafficLight light = TrafficLight.GREEN;
        System.out.println(light.getDescription());
        System.out.println(light.name());
        System.out.println(light.ordinal());
    }
}
```
