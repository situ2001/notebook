(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&p.push(o[i][0]),o[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==o[l]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"2ade0f41",3:"118f5b48",4:"6dd2940b",5:"69667846",6:"99450cb4",7:"12149e90",8:"1453a7cc",9:"acb621ae",10:"7c8d5432",11:"098c6bc4",12:"b1976303",13:"6ae3f419",14:"3c7e1479",15:"9ebef3d3",16:"113eb911",17:"341fa188",18:"718ecd75",19:"49947d0e",20:"31b12fb0",21:"a71b4ca2",22:"e49630c4",23:"7b84f692",24:"cbb63b26",25:"90a5a65b",26:"54e59082",27:"91599caf",28:"1716bdd1",29:"73194b66",30:"541f8167",31:"037c3dc9",32:"ec3e1c28",33:"a0ba6418",34:"b88a7b39",35:"aa1a3bb0",36:"2340ac19",37:"bddd9be8",38:"919492ee",39:"e5f70a0f",40:"82590afe",41:"4ae8d44b",42:"6599db0b",43:"18abe1fa",44:"c0e7a559",45:"94303610",46:"a854fc0b",47:"b5b9a971",48:"c5a95ccb",49:"30087306",50:"1d655b65",51:"43e5364c",52:"822ecd0a",53:"d5fa6476",54:"032b596d",55:"68e297e7",56:"7aa98ed8",57:"63904ed8",58:"6b8c399a"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;a.push([48,0]),t()}([function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(24),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){var r=t(67),o=t(70);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(5),o=t(52),a=t(53),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){var r=t(1).Symbol;n.exports=r},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):o&&(l=s?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(57),o=t(58),a=t(59),i=t(60),s=t(61);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(26);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(2)(Object,"create");n.exports=r},function(n,e,t){var r=t(79);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(20);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&p(o),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n,e,t){var r=t(51),o=t(3),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(2)(t(1),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(71),o=t(78),a=t(80),i=t(81),s=t(82);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(0),o=t(20),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(4),o=t(3);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(7),o=t(62),a=t(63),i=t(64),s=t(65),l=t(66);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(4),o=t(15);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(83),o=t(3);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(31),o=t(86),a=t(32);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),f=l.get(e);if(p&&f)return p==e&&f==n;var h=-1,m=!0,v=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var b=n[h],g=e[h];if(i)var y=c?i(g,b,h,e,n,l):i(b,g,h,n,e,l);if(void 0!==y){if(y)continue;m=!1;break}if(v){if(!o(e,(function(n,e){if(!a(v,e)&&(b===n||s(b,n,t,i,l)))return v.push(e)}))){m=!1;break}}else if(b!==g&&!s(b,g,t,i,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(16),o=t(84),a=t(85);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(96),o=t(102),a=t(37);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(1),o=t(98),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||o;n.exports=l}).call(this,t(22)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(99),o=t(100),a=t(101),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(27),o=t(18);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(2)(t(1),"Set");n.exports=r},function(n,e,t){var r=t(15);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(42),o=t(11);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(0),o=t(19),a=t(113),i=t(116);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(49),o=t(54),a=t(125),i=t(133),s=t(142),l=t(47),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=c},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,f=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,l,c=0,u=!1,v=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function g(e){var t=r,a=o;return r=o=void 0,c=e,i=n.apply(a,t)}function y(n){return c=n,s=setTimeout(x,e),u?g(n):i}function w(n){var t=n-l;return void 0===l||t>=e||t<0||v&&n-c>=a}function x(){var n=f();if(w(n))return _(n);s=setTimeout(x,function(n){var t=e-(n-l);return v?p(t,a-(n-c)):t}(n))}function _(n){return s=void 0,b&&r?g(n):(r=o=void 0,i)}function k(){var n=f(),t=w(n);if(r=arguments,o=this,l=n,t){if(void 0===s)return y(l);if(v)return s=setTimeout(x,e),g(l)}return void 0===s&&(s=setTimeout(x,e)),i}return e=m(e)||0,h(t)&&(u=!!t.leading,a=(v="maxWait"in t)?d(m(t.maxWait)||0,e):a,b="trailing"in t?!!t.trailing:b),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=o=s=void 0},k.flush=function(){return void 0===s?i:_(f())},k}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(147)},function(n,e,t){var r=t(23),o=t(50);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=o),s||(s=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(5),o=t(13),a=t(0),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(4),o=t(3);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(5),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(55),o=t(111),a=t(21),i=t(0),s=t(122);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(56),o=t(110),a=t(40);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(25),o=t(29);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var f=new r;if(a)var h=a(d,p,u,n,e,f);if(!(void 0===h?o(p,d,3,a,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(8),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(8);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(8);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(8);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(7);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(7),o=t(14),a=t(16);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(27),o=t(68),a=t(15),i=t(28),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?p:s).test(i(n))}},function(n,e,t){var r,o=t(69),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(1)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(72),o=t(7),a=t(14);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(73),o=t(74),a=t(75),i=t(76),s=t(77);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(9);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(9),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(9),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(9);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(10);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(10);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(10);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(10);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(25),o=t(30),a=t(87),i=t(90),s=t(106),l=t(0),c=t(34),u=t(36),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,m){var v=l(n),b=l(e),g=v?"[object Array]":s(n),y=b?"[object Array]":s(e),w=(g="[object Arguments]"==g?d:g)==d,x=(y="[object Arguments]"==y?d:y)==d,_=g==y;if(_&&c(n)){if(!c(e))return!1;v=!0,w=!1}if(_&&!w)return m||(m=new r),v||u(n)?o(n,e,t,f,h,m):a(n,e,g,t,f,h,m);if(!(1&t)){var k=w&&p.call(n,"__wrapped__"),j=x&&p.call(e,"__wrapped__");if(k||j){var T=k?n.value():n,S=j?e.value():e;return m||(m=new r),h(T,S,t,f,m)}}return!!_&&(m||(m=new r),i(n,e,t,f,h,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(5),o=t(88),a=t(26),i=t(30),s=t(89),l=t(17),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var m=p.get(n);if(m)return m==e;r|=2,p.set(n,e);var v=i(f(n),f(e),r,c,d,p);return p.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(1).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(91),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:o.call(e,p)))return!1}var f=s.get(n),h=s.get(e);if(f&&h)return f==e&&h==n;var m=!0;s.set(n,e),s.set(e,n);for(var v=l;++d<u;){var b=n[p=c[d]],g=e[p];if(a)var y=l?a(g,b,p,e,n,s):a(b,g,p,n,e,s);if(!(void 0===y?b===g||i(b,g,t,a,s):y)){m=!1;break}v||(v="constructor"==p)}if(m&&!v){var w=n.constructor,x=e.constructor;w==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof w&&w instanceof w&&"function"==typeof x&&x instanceof x||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(92),o=t(93),a=t(33);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(23),o=t(0);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(94),o=t(95),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(97),o=t(13),a=t(0),i=t(34),s=t(35),l=t(36),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&o(n),d=!t&&!u&&i(n),p=!t&&!u&&!d&&l(n),f=t||u||d||p,h=f?r(n.length,String):[],m=h.length;for(var v in n)!e&&!c.call(n,v)||f&&("length"==v||d&&("offset"==v||"parent"==v)||p&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||h.push(v);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(4),o=t(18),a=t(3),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(24),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(22)(n))},function(n,e,t){var r=t(103),o=t(104),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(105)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(107),o=t(14),a=t(108),i=t(38),s=t(109),l=t(4),c=t(28),u=c(r),d=c(o),p=c(a),f=c(i),h=c(s),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=m(new o)||a&&"[object Promise]"!=m(a.resolve())||i&&"[object Set]"!=m(new i)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(2)(t(1),"DataView");n.exports=r},function(n,e,t){var r=t(2)(t(1),"Promise");n.exports=r},function(n,e,t){var r=t(2)(t(1),"WeakMap");n.exports=r},function(n,e,t){var r=t(39),o=t(33);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(29),o=t(112),a=t(119),i=t(19),s=t(39),l=t(40),c=t(11);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(41);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(114),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(115);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(16);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(117);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(5),o=t(118),a=t(0),i=t(20),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(120),o=t(121);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(42),o=t(13),a=t(0),i=t(35),s=t(18),l=t(11);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&i(p,u)&&(a(n)||o(n))}},function(n,e,t){var r=t(123),o=t(124),a=t(19),i=t(11);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(41);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(21),o=t(126),a=t(128);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(127),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(129),o=t(132)(r);n.exports=o},function(n,e,t){var r=t(130),o=t(131),a=t(21),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(2),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(31),o=t(134),a=t(139),i=t(32),s=t(140),l=t(17);n.exports=function(n,e,t){var c=-1,u=o,d=n.length,p=!0,f=[],h=f;if(t)p=!1,u=a;else if(d>=200){var m=e?null:s(n);if(m)return l(m);p=!1,u=i,h=new r}else h=e?[]:f;n:for(;++c<d;){var v=n[c],b=e?e(v):v;if(v=t||0!==v?v:0,p&&b==b){for(var g=h.length;g--;)if(h[g]===b)continue n;e&&h.push(b),f.push(v)}else u(h,b,t)||(h!==f&&h.push(b),f.push(v))}return f}},function(n,e,t){var r=t(135);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(136),o=t(137),a=t(138);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(38),o=t(141),a=t(17),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(37),o=t(3);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(43)},function(n,e,t){"use strict";t(44)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({});function o(n){return null==n}function a(n){return null!=n}function i(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function u(n){return"[object Object]"===c.call(n)}function d(n){return"[object RegExp]"===c.call(n)}function p(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function m(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function g(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var y=Object.prototype.hasOwnProperty;function w(n,e){return y.call(n,e)}function x(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,k=x((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),j=x((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,S=x((function(n){return n.replace(T,"-$1").toLowerCase()}));var P=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function O(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function C(n,e){for(var t in e)n[t]=e[t];return n}function I(n){for(var e={},t=0;t<n.length;t++)n[t]&&C(e,n[t]);return e}function A(n,e,t){}var E=function(n,e,t){return!1},z=function(n){return n};function $(n,e){if(n===e)return!0;var t=l(n),r=l(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return $(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return $(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if($(n[t],e))return t;return-1}function R(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var F=["component","directive","filter"],D=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:E,isReservedAttr:E,isUnknownElement:E,getTagNamespace:A,parsePlatformTagName:z,mustUseProp:E,async:!0,_lifecycleHooks:D},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var M=new RegExp("[^"+B.source+".$_\\d]");var V,U="__proto__"in{},H="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=W&&WXEnvironment.platform.toLowerCase(),Q=H&&window.navigator.userAgent.toLowerCase(),G=Q&&/msie|trident/.test(Q),X=Q&&Q.indexOf("msie 9.0")>0,K=Q&&Q.indexOf("edge/")>0,Z=(Q&&Q.indexOf("android"),Q&&/iphone|ipad|ipod|ios/.test(Q)||"ios"===J),Y=(Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q),Q&&Q.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(H)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var rn=function(){return void 0===V&&(V=!H&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),V},on=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function an(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,ln="undefined"!=typeof Symbol&&an(Symbol)&&"undefined"!=typeof Reflect&&an(Reflect.ownKeys);sn="undefined"!=typeof Set&&an(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=A,un=0,dn=function(){this.id=un++,this.subs=[]};dn.prototype.addSub=function(n){this.subs.push(n)},dn.prototype.removeSub=function(n){g(this.subs,n)},dn.prototype.depend=function(){dn.target&&dn.target.addDep(this)},dn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},dn.target=null;var pn=[];function fn(n){pn.push(n),dn.target=n}function hn(){pn.pop(),dn.target=pn[pn.length-1]}var mn=function(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(mn.prototype,vn);var bn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function yn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,xn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];N(xn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var _n=Object.getOwnPropertyNames(xn),kn=!0;function jn(n){kn=n}var Tn=function(n){this.value=n,this.dep=new dn,this.vmCount=0,N(n,"__ob__",this),Array.isArray(n)?(U?function(n,e){n.__proto__=e}(n,xn):function(n,e,t){for(var r=0,o=t.length;r<o;r++){var a=t[r];N(n,a,e[a])}}(n,xn,_n),this.observeArray(n)):this.walk(n)};function Sn(n,e){var t;if(l(n)&&!(n instanceof mn))return w(n,"__ob__")&&n.__ob__ instanceof Tn?t=n.__ob__:kn&&!rn()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Tn(n)),e&&t&&t.vmCount++,t}function Pn(n,e,t,r,o){var a=new dn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,l=i&&i.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!o&&Sn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return dn.target&&(a.depend(),c&&(c.dep.depend(),Array.isArray(e)&&In(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!o&&Sn(e),a.notify())}})}}function On(n,e,t){if(Array.isArray(n)&&p(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Pn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function Cn(n,e){if(Array.isArray(n)&&p(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function In(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&In(e)}Tn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Pn(n,e[t])},Tn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Sn(n[e])};var An=q.optionMergeStrategies;function En(n,e){if(!e)return n;for(var t,r,o,a=ln?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(r=n[t],o=e[t],w(n,t)?r!==o&&u(r)&&u(o)&&En(r,o):On(n,t,o));return n}function zn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,o="function"==typeof n?n.call(t,t):n;return r?En(r,o):o}:e?n?function(){return En("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function $n(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ln(n,e,t,r){var o=Object.create(n||null);return e?C(o,e):o}An.data=function(n,e,t){return t?zn(n,e,t):e&&"function"!=typeof e?n:zn(n,e)},D.forEach((function(n){An[n]=$n})),F.forEach((function(n){An[n+"s"]=Ln})),An.watch=function(n,e,t,r){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var a in C(o,n),e){var i=o[a],s=e[a];i&&!Array.isArray(i)&&(i=[i]),o[a]=i?i.concat(s):Array.isArray(s)?s:[s]}return o},An.props=An.methods=An.inject=An.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return C(o,n),e&&C(o,e),o},An.provide=zn;var Rn=function(n,e){return void 0===e?n:e};function Fn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,a={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(a[k(o)]={type:null});else if(u(t))for(var i in t)o=t[i],a[k(i)]=u(o)?o:{type:o};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(u(t))for(var a in t){var i=t[a];r[a]=u(i)?C({from:a},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Fn(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Fn(n,e.mixins[r],t);var a,i={};for(a in n)s(a);for(a in e)w(n,a)||s(a);function s(r){var o=An[r]||Rn;i[r]=o(n[r],e[r],t,r)}return i}function Dn(n,e,t,r){if("string"==typeof t){var o=n[e];if(w(o,t))return o[t];var a=k(t);if(w(o,a))return o[a];var i=j(a);return w(o,i)?o[i]:o[t]||o[a]||o[i]}}function qn(n,e,t,r){var o=e[n],a=!w(t,n),i=t[n],s=Mn(Boolean,o.type);if(s>-1)if(a&&!w(o,"default"))i=!1;else if(""===i||i===S(n)){var l=Mn(String,o.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Bn(e.type)?r.call(n):r}(r,o,n);var c=kn;jn(!0),Sn(i),jn(c)}return i}function Bn(n){var e=n&&n.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function Nn(n,e){return Bn(n)===Bn(e)}function Mn(n,e){if(!Array.isArray(e))return Nn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Nn(e[t],n))return t;return-1}function Vn(n,e,t){fn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){Hn(n,r,"errorCaptured hook")}}Hn(n,e,t)}finally{hn()}}function Un(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return Vn(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){Vn(n,r,o)}return a}function Hn(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!H&&!W||"undefined"==typeof console)throw n;console.error(n)}var Jn,Qn=!1,Gn=[],Xn=!1;function Kn(){Xn=!1;var n=Gn.slice(0);Gn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&an(Promise)){var Zn=Promise.resolve();Jn=function(){Zn.then(Kn),Z&&setTimeout(A)},Qn=!0}else if(G||"undefined"==typeof MutationObserver||!an(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Jn="undefined"!=typeof setImmediate&&an(setImmediate)?function(){setImmediate(Kn)}:function(){setTimeout(Kn,0)};else{var Yn=1,ne=new MutationObserver(Kn),ee=document.createTextNode(String(Yn));ne.observe(ee,{characterData:!0}),Jn=function(){Yn=(Yn+1)%2,ee.data=String(Yn)},Qn=!0}function te(n,e){var t;if(Gn.push((function(){if(n)try{n.call(e)}catch(n){Vn(n,e,"nextTick")}else t&&t(e)})),Xn||(Xn=!0,Jn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var re=new sn;function oe(n){!function n(e,t){var r,o,a=Array.isArray(e);if(!a&&!l(e)||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(a)for(r=e.length;r--;)n(e[r],t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,re),re.clear()}var ae=x((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function ie(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Un(r,null,arguments,e,"v-on handler");for(var o=r.slice(),a=0;a<o.length;a++)Un(o[a],null,n,e,"v-on handler")}return t.fns=n,t}function se(n,e,t,r,a,s){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=ae(l),o(c)||(o(u)?(o(c.fns)&&(c=n[l]=ie(c,s)),i(d.once)&&(c=n[l]=a(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)o(n[l])&&r((d=ae(l)).name,e[l],d.capture)}function le(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var s=n[e];function l(){t.apply(this,arguments),g(r.fns,l)}o(s)?r=ie([l]):a(s.fns)&&i(s.merged)?(r=s).fns.push(l):r=ie([s,l]),r.merged=!0,n[e]=r}function ce(n,e,t,r,o){if(a(e)){if(w(e,t))return n[t]=e[t],o||delete e[t],!0;if(w(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function ue(n){return s(n)?[gn(n)]:Array.isArray(n)?function n(e,t){var r,l,c,u,d=[];for(r=0;r<e.length;r++)o(l=e[r])||"boolean"==typeof l||(c=d.length-1,u=d[c],Array.isArray(l)?l.length>0&&(de((l=n(l,(t||"")+"_"+r))[0])&&de(u)&&(d[c]=gn(u.text+l[0].text),l.shift()),d.push.apply(d,l)):s(l)?de(u)?d[c]=gn(u.text+l):""!==l&&d.push(gn(l)):de(l)&&de(u)?d[c]=gn(u.text+l.text):(i(e._isVList)&&a(l.tag)&&o(l.key)&&a(t)&&(l.key="__vlist"+t+"_"+r+"__"),d.push(l)));return d}(n):void 0}function de(n){return a(n)&&a(n.text)&&!1===n.isComment}function pe(n,e){if(n){for(var t=Object.create(null),r=ln?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){for(var i=n[a].from,s=e;s;){if(s._provided&&w(s._provided,i)){t[a]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[a]){var l=n[a].default;t[a]="function"==typeof l?l.call(e):l}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n,e,t){var o,a=Object.keys(e).length>0,i=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==r&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var l in o={},n)n[l]&&"$"!==l[0]&&(o[l]=ve(e,l,n[l]))}else o={};for(var c in e)c in o||(o[c]=be(e,c));return n&&Object.isExtensible(n)&&(n._normalized=o),N(o,"$stable",i),N(o,"$key",s),N(o,"$hasNormal",a),o}function ve(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({});return(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ue(n))&&(0===n.length||1===n.length&&n[0].isComment)?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function be(n,e){return function(){return n[e]}}function ge(n,e){var t,r,o,i,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,o=n.length;r<o;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)t.push(e(u.value,t.length)),u=c.next()}else for(i=Object.keys(n),t=new Array(i.length),r=0,o=i.length;r<o;r++)s=i[r],t[r]=e(n[s],s,r);return a(t)||(t=[]),t._isVList=!0,t}function ye(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=C(C({},r),t)),o=a(t)||e):o=this.$slots[n]||e;var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function we(n){return Dn(this.$options,"filters",n)||z}function xe(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function _e(n,e,t,r,o){var a=q.keyCodes[e]||t;return o&&r&&!q.keyCodes[e]?xe(o,r):a?xe(a,n):r?S(r)!==e:void 0}function ke(n,e,t,r,o){if(t)if(l(t)){var a;Array.isArray(t)&&(t=I(t));var i=function(i){if("class"===i||"style"===i||b(i))a=n;else{var s=n.attrs&&n.attrs.type;a=r||q.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=k(i),c=S(i);l in a||c in a||(a[i]=t[i],o&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function je(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Se(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Te(n,e,t){return Se(n,"__once__"+e+(t?"_"+t:""),!0),n}function Se(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Pe(n[r],e+"_"+r,t);else Pe(n,e,t)}function Pe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Oe(n,e){if(e)if(u(e)){var t=n.on=n.on?C({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function Ce(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var a=n[o];Array.isArray(a)?Ce(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function Ie(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Ae(n,e){return"string"==typeof n?e+n:n}function Ee(n){n._o=Te,n._n=m,n._s=h,n._l=ge,n._t=ye,n._q=$,n._i=L,n._m=je,n._f=we,n._k=_e,n._b=ke,n._v=gn,n._e=bn,n._u=Ce,n._g=Oe,n._d=Ie,n._p=Ae}function ze(n,e,t,o,a){var s,l=this,c=a.options;w(o,"_uid")?(s=Object.create(o))._original=o:(s=o,o=o._original);var u=i(c._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=pe(c.inject,o),this.slots=function(){return l.$slots||me(n.scopedSlots,l.$slots=fe(t,o)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return me(n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=me(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var a=Be(s,n,e,t,r,d);return a&&!Array.isArray(a)&&(a.fnScopeId=c._scopeId,a.fnContext=o),a}:this._c=function(n,e,t,r){return Be(s,n,e,t,r,d)}}function $e(n,e,t,r,o){var a=yn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Le(n,e){for(var t in e)n[k(t)]=e[t]}Ee(ze.prototype);var Re={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Re.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;a(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){0;var i=o.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key),c=!!(a||n.$options._renderChildren||l);n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o);if(n.$options._renderChildren=a,n.$attrs=o.data.attrs||r,n.$listeners=t||r,e&&n.$options.props){jn(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var f=d[p],h=n.$options.props;u[f]=qn(f,h,e,n)}jn(!0),n.$options.propsData=e}t=t||r;var m=n.$options._parentListeners;n.$options._parentListeners=t,Ge(n,t,m),c&&(n.$slots=fe(a,o.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Ye(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ze(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},Fe=Object.keys(Re);function De(n,e,t,s,c){if(!o(n)){var u=t.$options._base;if(l(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,e){if(i(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=Me;t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(i(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var r=n.owners=[t],s=!0,c=null,u=null;t.$on("hook:destroyed",(function(){return g(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==u&&(clearTimeout(u),u=null))},p=R((function(t){n.resolved=Ve(t,e),s?r.length=0:d(!0)})),h=R((function(e){a(n.errorComp)&&(n.error=!0,d(!0))})),m=n(p,h);return l(m)&&(f(m)?o(n.resolved)&&m.then(p,h):f(m.component)&&(m.component.then(p,h),a(m.error)&&(n.errorComp=Ve(m.error,e)),a(m.loading)&&(n.loadingComp=Ve(m.loading,e),0===m.delay?n.loading=!0:c=setTimeout((function(){c=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,d(!1))}),m.delay||200)),a(m.timeout)&&(u=setTimeout((function(){u=null,o(n.resolved)&&h(null)}),m.timeout)))),s=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,o){var a=bn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(d,e,t,s,c);e=e||{},_t(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),i=o[r],s=e.model.callback;a(i)?(Array.isArray(i)?-1===i.indexOf(s):i!==s)&&(o[r]=[s].concat(i)):o[r]=s}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!o(r)){var i={},s=n.attrs,l=n.props;if(a(s)||a(l))for(var c in r){var u=S(c);ce(i,l,c,u,!0)||ce(i,s,c,u,!1)}return i}}(e,n);if(i(n.options.functional))return function(n,e,t,o,i){var s=n.options,l={},c=s.props;if(a(c))for(var u in c)l[u]=qn(u,c,e||r);else a(t.attrs)&&Le(l,t.attrs),a(t.props)&&Le(l,t.props);var d=new ze(t,l,i,o,n),p=s.render.call(null,d._c,d);if(p instanceof mn)return $e(p,t,d.parent,s,d);if(Array.isArray(p)){for(var f=ue(p)||[],h=new Array(f.length),m=0;m<f.length;m++)h[m]=$e(f[m],t,d.parent,s,d);return h}}(n,p,e,t,s);var h=e.on;if(e.on=e.nativeOn,i(n.options.abstract)){var m=e.slot;e={},m&&(e.slot=m)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Fe.length;t++){var r=Fe[t],o=e[r],a=Re[r];o===a||o&&o._merged||(e[r]=o?qe(a,o):a)}}(e);var v=n.options.name||c;return new mn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:h,tag:c,children:s},d)}}}function qe(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Be(n,e,t,r,c,u){return(Array.isArray(t)||s(t))&&(c=r,r=t,t=void 0),i(u)&&(c=2),function(n,e,t,r,s){if(a(t)&&a(t.__ob__))return bn();a(t)&&a(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===s?r=ue(r):1===s&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var c,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),c=q.isReservedTag(e)?new mn(q.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!a(d=Dn(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):De(d,t,n,r,e)}else c=De(e,t,n,r);return Array.isArray(c)?c:a(c)?(a(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(a(e.children))for(var s=0,l=e.children.length;s<l;s++){var c=e.children[s];a(c.tag)&&(o(c.ns)||i(r)&&"svg"!==c.tag)&&n(c,t,r)}}(c,u),a(t)&&function(n){l(n.style)&&oe(n.style);l(n.class)&&oe(n.class)}(t),c):bn()}(n,e,t,r,c)}var Ne,Me=null;function Ve(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function Ue(n){return n.isComment&&n.asyncFactory}function He(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||Ue(t)))return t}}function We(n,e){Ne.$on(n,e)}function Je(n,e){Ne.$off(n,e)}function Qe(n,e){var t=Ne;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function Ge(n,e,t){Ne=n,se(e,t||{},We,Je,Qe,n),Ne=void 0}var Xe=null;function Ke(n){var e=Xe;return Xe=n,function(){Xe=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e){fn();var t=n.$options[e],r=e+" hook";if(t)for(var o=0,a=t.length;o<a;o++)Un(t[o],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var et=[],tt=[],rt={},ot=!1,at=!1,it=0;var st=0,lt=Date.now;if(H&&!G){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}function ut(){var n,e;for(st=lt(),at=!0,et.sort((function(n,e){return n.id-e.id})),it=0;it<et.length;it++)(n=et[it]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();it=et.length=tt.length=0,rt={},ot=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),on&&q.devtools&&on.emit("flush")}var dt=0,pt=function(n,e,t,r,o){this.vm=n,o&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++dt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!M.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=A)),this.value=this.lazy?void 0:this.get()};pt.prototype.get=function(){var n;fn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Vn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),hn(),this.cleanupDeps()}return n},pt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},pt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},pt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==rt[e]){if(rt[e]=!0,at){for(var t=et.length-1;t>it&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);ot||(ot=!0,te(ut))}}(this)},pt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user)try{this.cb.call(this.vm,n,e)}catch(n){Vn(n,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,n,e)}}},pt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},pt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},pt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||g(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:A,set:A};function ht(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function mt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},o=n.$options._propKeys=[];n.$parent&&jn(!1);var a=function(a){o.push(a);var i=qn(a,e,t,n);Pn(r,a,i),a in n||ht(n,"_props",a)};for(var i in e)a(i);jn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?A:P(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){fn();try{return n.call(e,e)}catch(n){return Vn(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&w(r,a)||(i=void 0,36!==(i=(a+"").charCodeAt(0))&&95!==i&&ht(n,"_data",a))}var i;Sn(e,!0)}(n):Sn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=rn();for(var o in e){var a=e[o],i="function"==typeof a?a:a.get;0,r||(t[o]=new pt(n,i||A,A,vt)),o in n||bt(n,o,a)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var o=0;o<r.length;o++)wt(n,t,r[o]);else wt(n,t,r)}}(n,e.watch)}var vt={lazy:!0};function bt(n,e,t){var r=!rn();"function"==typeof t?(ft.get=r?gt(e):yt(t),ft.set=A):(ft.get=t.get?r&&!1!==t.cache?gt(e):yt(t.get):A,ft.set=t.set||A),Object.defineProperty(n,e,ft)}function gt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),dn.target&&e.depend(),e.value}}function yt(n){return function(){return n.call(this,this)}}function wt(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var xt=0;function _t(n){var e=n.options;if(n.super){var t=_t(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&C(n.extendOptions,r),(e=n.options=Fn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function kt(n){this._init(n)}function jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Fn(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)ht(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)bt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,F.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=C({},i.options),o[r]=i,i}}function Tt(n){return n&&(n.Ctor.options.name||n.tag)}function St(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!d(n)&&n.test(e)}function Pt(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var a in t){var i=t[a];if(i){var s=Tt(i.componentOptions);s&&!e(s)&&Ot(t,a,r,o)}}}function Ot(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,g(t,e)}kt.prototype._init=function(n){var e=this;e._uid=xt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Fn(_t(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ge(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=fe(e._renderChildren,o),n.$scopedSlots=r,n._c=function(e,t,r,o){return Be(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return Be(n,e,t,r,o,!0)};var a=t&&t.data;Pn(n,"$attrs",a&&a.attrs||r,null,!0),Pn(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate"),function(n){var e=pe(n.$options.inject,n);e&&(jn(!1),Object.keys(e).forEach((function(t){Pn(n,t,e[t])})),jn(!0))}(e),mt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=On,n.prototype.$delete=Cn,n.prototype.$watch=function(n,e,t){if(u(e))return wt(this,n,e,t);(t=t||{}).user=!0;var r=new pt(this,n,e,t);if(t.immediate)try{e.call(this,r.value)}catch(n){Vn(n,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(kt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var o=0,a=n.length;o<a;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var a,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((a=i[s])===e||a.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?O(t):t;for(var r=O(arguments,1),o='event handler for "'+n+'"',a=0,i=t.length;a<i;a++)Un(t[a],e,r,e,o)}return e}}(kt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=Ke(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||g(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(kt),function(n){Ee(n.prototype),n.prototype.$nextTick=function(n){return te(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&(e.$scopedSlots=me(o.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=o;try{Me=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Vn(t,e,"render"),n=e._vnode}finally{Me=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=bn()),n.parent=o,n}}(kt);var Ct=[String,RegExp,Array],It={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ct,exclude:Ct,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ot(this.cache,n,this.keys)},mounted:function(){var n=this;this.$watch("include",(function(e){Pt(n,(function(n){return St(e,n)}))})),this.$watch("exclude",(function(e){Pt(n,(function(n){return!St(e,n)}))}))},render:function(){var n=this.$slots.default,e=He(n),t=e&&e.componentOptions;if(t){var r=Tt(t),o=this.include,a=this.exclude;if(o&&(!r||!St(o,r))||a&&r&&St(a,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,g(s,l),s.push(l)):(i[l]=e,s.push(l),this.max&&s.length>parseInt(this.max)&&Ot(i,s[0],s,this._vnode)),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:C,mergeOptions:Fn,defineReactive:Pn},n.set=On,n.delete=Cn,n.nextTick=te,n.observable=function(n){return Sn(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,C(n.options.components,It),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=O(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Fn(this.options,n),this}}(n),jt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(kt),Object.defineProperty(kt.prototype,"$isServer",{get:rn}),Object.defineProperty(kt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(kt,"FunctionalRenderContext",{value:ze}),kt.version="2.6.12";var At=v("style,class"),Et=v("input,textarea,option,select,progress"),zt=v("contenteditable,draggable,spellcheck"),$t=v("events,caret,typing,plaintext-only"),Lt=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Ft=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Dt=function(n){return Ft(n)?n.slice(6,n.length):""},qt=function(n){return null==n||!1===n};function Bt(n){for(var e=n.data,t=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Nt(r.data,e));for(;a(t=t.parent);)t&&t.data&&(e=Nt(e,t.data));return function(n,e){if(a(n)||a(e))return Mt(n,Vt(e));return""}(e.staticClass,e.class)}function Nt(n,e){return{staticClass:Mt(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function Mt(n,e){return n?e?n+" "+e:n:e||""}function Vt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)a(e=Vt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ut={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Ht=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Jt=function(n){return Ht(n)||Wt(n)};var Qt=Object.create(null);var Gt=v("text,number,password,search,email,tel,url");var Xt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Ut[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Kt={create:function(n,e){Zt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Zt(n,!0),Zt(e))},destroy:function(n){Zt(n,!0)}};function Zt(n,e){var t=n.data.ref;if(a(t)){var r=n.context,o=n.componentInstance||n.elm,i=r.$refs;e?Array.isArray(i[t])?g(i[t],o):i[t]===o&&(i[t]=void 0):n.data.refInFor?Array.isArray(i[t])?i[t].indexOf(o)<0&&i[t].push(o):i[t]=[o]:i[t]=o}}var Yt=new mn("",{},[]),nr=["create","activate","update","remove","destroy"];function er(n,e){return n.key===e.key&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=a(t=n.data)&&a(t=t.attrs)&&t.type,o=a(t=e.data)&&a(t=t.attrs)&&t.type;return r===o||Gt(r)&&Gt(o)}(n,e)||i(n.isAsyncPlaceholder)&&n.asyncFactory===e.asyncFactory&&o(e.asyncFactory.error))}function tr(n,e,t){var r,o,i={};for(r=e;r<=t;++r)a(o=n[r].key)&&(i[o]=r);return i}var rr={create:or,update:or,destroy:function(n){or(n,Yt)}};function or(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===Yt,i=e===Yt,s=ir(n.data.directives,n.context),l=ir(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,lr(o,"update",e,n),o.def&&o.def.componentUpdated&&u.push(o)):(lr(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var d=function(){for(var t=0;t<c.length;t++)lr(c[t],"inserted",e,n)};a?le(e,"insert",d):d()}u.length&&le(e,"postpatch",(function(){for(var t=0;t<u.length;t++)lr(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||lr(s[t],"unbind",n,n,i)}(n,e)}var ar=Object.create(null);function ir(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=ar),o[sr(r)]=r,r.def=Dn(e.$options,"directives",r.name);return o}function sr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function lr(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){Vn(r,t.context,"directive "+n.name+" "+e+" hook")}}var cr=[Kt,rr];function ur(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,i,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in a(c.__ob__)&&(c=e.data.attrs=C({},c)),c)i=c[r],l[r]!==i&&dr(s,r,i);for(r in(G||K)&&c.value!==l.value&&dr(s,"value",c.value),l)o(c[r])&&(Ft(r)?s.removeAttributeNS(Rt,Dt(r)):zt(r)||s.removeAttribute(r))}}function dr(n,e,t){n.tagName.indexOf("-")>-1?pr(n,e,t):Lt(e)?qt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):zt(e)?n.setAttribute(e,function(n,e){return qt(e)||"false"===e?"false":"contenteditable"===n&&$t(e)?e:"true"}(e,t)):Ft(e)?qt(t)?n.removeAttributeNS(Rt,Dt(e)):n.setAttributeNS(Rt,e,t):pr(n,e,t)}function pr(n,e,t){if(qt(t))n.removeAttribute(e);else{if(G&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var fr={create:ur,update:ur};function hr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var s=Bt(e),l=t._transitionClasses;a(l)&&(s=Mt(s,Vt(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var mr,vr={create:hr,update:hr};function br(n,e,t){var r=mr;return function o(){var a=e.apply(null,arguments);null!==a&&wr(n,o,t,r)}}var gr=Qn&&!(Y&&Number(Y[1])<=53);function yr(n,e,t,r){if(gr){var o=st,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}mr.addEventListener(n,e,en?{capture:t,passive:r}:t)}function wr(n,e,t,r){(r||mr).removeEventListener(n,e._wrapper||e,t)}function xr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};mr=e.elm,function(n){if(a(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),se(t,r,yr,wr,br,e.context),mr=void 0}}var _r,kr={create:xr,update:xr};function jr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,i=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in a(l.__ob__)&&(l=e.data.domProps=C({},l)),s)t in l||(i[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=o(r)?"":String(r);Tr(i,c)&&(i.value=c)}else if("innerHTML"===t&&Wt(i.tagName)&&o(i.innerHTML)){(_r=_r||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=_r.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(r!==s[t])try{i[t]=r}catch(n){}}}}function Tr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(a(r)){if(r.number)return m(t)!==m(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Sr={create:jr,update:jr},Pr=x((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Or(n){var e=Cr(n.style);return n.staticStyle?C(n.staticStyle,e):e}function Cr(n){return Array.isArray(n)?I(n):"string"==typeof n?Pr(n):n}var Ir,Ar=/^--/,Er=/\s*!important$/,zr=function(n,e,t){if(Ar.test(e))n.style.setProperty(e,t);else if(Er.test(t))n.style.setProperty(S(e),t.replace(Er,""),"important");else{var r=Lr(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},$r=["Webkit","Moz","ms"],Lr=x((function(n){if(Ir=Ir||document.createElement("div").style,"filter"!==(n=k(n))&&n in Ir)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<$r.length;t++){var r=$r[t]+e;if(r in Ir)return r}}));function Rr(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var i,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=Cr(e.data.style)||{};e.data.normalizedStyle=a(p.__ob__)?C({},p):p;var f=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Or(o.data))&&C(r,t);(t=Or(n.data))&&C(r,t);for(var a=n;a=a.parent;)a.data&&(t=Or(a.data))&&C(r,t);return r}(e,!0);for(s in d)o(f[s])&&zr(l,s,"");for(s in f)(i=f[s])!==d[s]&&zr(l,s,null==i?"":i)}}var Fr={create:Rr,update:Rr},Dr=/\s+/;function qr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Dr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Br(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Dr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Nr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&C(e,Mr(n.name||"v")),C(e,n),e}return"string"==typeof n?Mr(n):void 0}}var Mr=x((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Vr=H&&!X,Ur="transition",Hr="transitionend",Wr="animation",Jr="animationend";Vr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ur="WebkitTransition",Hr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wr="WebkitAnimation",Jr="webkitAnimationEnd"));var Qr=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Gr(n){Qr((function(){Qr(n)}))}function Xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),qr(n,e))}function Kr(n,e){n._transitionClasses&&g(n._transitionClasses,e),Br(n,e)}function Zr(n,e,t){var r=no(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?Hr:Jr,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,u)}var Yr=/\b(transform|all)(,|$)/;function no(n,e){var t,r=window.getComputedStyle(n),o=(r[Ur+"Delay"]||"").split(", "),a=(r[Ur+"Duration"]||"").split(", "),i=eo(o,a),s=(r[Wr+"Delay"]||"").split(", "),l=(r[Wr+"Duration"]||"").split(", "),c=eo(s,l),u=0,d=0;return"transition"===e?i>0&&(t="transition",u=i,d=a.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&Yr.test(r[Ur+"Property"])}}function eo(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return to(e)+to(n[t])})))}function to(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ro(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Nr(n.data.transition);if(!o(r)&&!a(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,c=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,p=r.appearClass,f=r.appearToClass,h=r.appearActiveClass,v=r.beforeEnter,b=r.enter,g=r.afterEnter,y=r.enterCancelled,w=r.beforeAppear,x=r.appear,_=r.afterAppear,k=r.appearCancelled,j=r.duration,T=Xe,S=Xe.$vnode;S&&S.parent;)T=S.context,S=S.parent;var P=!T._isMounted||!n.isRootInsert;if(!P||x||""===x){var O=P&&p?p:c,C=P&&h?h:d,I=P&&f?f:u,A=P&&w||v,E=P&&"function"==typeof x?x:b,z=P&&_||g,$=P&&k||y,L=m(l(j)?j.enter:j);0;var F=!1!==i&&!X,D=io(E),q=t._enterCb=R((function(){F&&(Kr(t,I),Kr(t,C)),q.cancelled?(F&&Kr(t,O),$&&$(t)):z&&z(t),t._enterCb=null}));n.data.show||le(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),E&&E(t,q)})),A&&A(t),F&&(Xr(t,O),Xr(t,C),Gr((function(){Kr(t,O),q.cancelled||(Xr(t,I),D||(ao(L)?setTimeout(q,L):Zr(t,s,q)))}))),n.data.show&&(e&&e(),E&&E(t,q)),F||D||q()}}}function oo(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Nr(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var i=r.css,s=r.type,c=r.leaveClass,u=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,f=r.leave,h=r.afterLeave,v=r.leaveCancelled,b=r.delayLeave,g=r.duration,y=!1!==i&&!X,w=io(f),x=m(l(g)?g.leave:g);0;var _=t._leaveCb=R((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Kr(t,u),Kr(t,d)),_.cancelled?(y&&Kr(t,c),v&&v(t)):(e(),h&&h(t)),t._leaveCb=null}));b?b(k):k()}function k(){_.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(Xr(t,c),Xr(t,d),Gr((function(){Kr(t,c),_.cancelled||(Xr(t,u),w||(ao(x)?setTimeout(_,x):Zr(t,s,_)))}))),f&&f(t,_),y||w||_())}}function ao(n){return"number"==typeof n&&!isNaN(n)}function io(n){if(o(n))return!1;var e=n.fns;return a(e)?io(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function so(n,e){!0!==e.data.show&&ro(e)}var lo=function(n){var e,t,r={},l=n.modules,c=n.nodeOps;for(e=0;e<nr.length;++e)for(r[nr[e]]=[],t=0;t<l.length;++t)a(l[t][nr[e]])&&r[nr[e]].push(l[t][nr[e]]);function u(n){var e=c.parentNode(n);a(e)&&c.removeChild(e,n)}function d(n,e,t,o,s,l,u){if(a(n.elm)&&a(l)&&(n=l[u]=yn(n)),n.isRootInsert=!s,!function(n,e,t,o){var s=n.data;if(a(s)){var l=a(n.componentInstance)&&s.keepAlive;if(a(s=s.hook)&&a(s=s.init)&&s(n,!1),a(n.componentInstance))return p(n,e),f(t,n.elm,o),i(l)&&function(n,e,t,o){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(i=s.data)&&a(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](Yt,s);e.push(s);break}f(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var d=n.data,m=n.children,v=n.tag;a(v)?(n.elm=n.ns?c.createElementNS(n.ns,v):c.createElement(v,n),g(n),h(n,m,e),a(d)&&b(n,e),f(t,n.elm,o)):i(n.isComment)?(n.elm=c.createComment(n.text),f(t,n.elm,o)):(n.elm=c.createTextNode(n.text),f(t,n.elm,o))}}function p(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(b(n,e),g(n)):(Zt(n),e.push(n))}function f(n,e,t){a(n)&&(a(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function b(n,t){for(var o=0;o<r.create.length;++o)r.create[o](Yt,n);a(e=n.data.hook)&&(a(e.create)&&e.create(Yt,n),a(e.insert)&&t.push(n))}function g(n){var e;if(a(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;a(e=Xe)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,r,o,a){for(;r<=o;++r)d(t[r],a,n,e,!1,t,r)}function w(n){var e,t,o=n.data;if(a(o))for(a(e=o.hook)&&a(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function x(n,e,t){for(;e<=t;++e){var r=n[e];a(r)&&(a(r.tag)?(_(r),w(r)):u(r.elm))}}function _(n,e){if(a(e)||a(n.data)){var t,o=r.remove.length+1;for(a(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,o),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&_(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else u(n.elm)}function k(n,e,t,r){for(var o=t;o<r;o++){var i=e[o];if(a(i)&&er(n,i))return o}}function j(n,e,t,s,l,u){if(n!==e){a(e.elm)&&a(s)&&(e=s[l]=yn(e));var p=e.elm=n.elm;if(i(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?P(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(i(e.isStatic)&&i(n.isStatic)&&e.key===n.key&&(i(e.isCloned)||i(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;a(h)&&a(f=h.hook)&&a(f=f.prepatch)&&f(n,e);var v=n.children,b=e.children;if(a(h)&&m(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);a(f=h.hook)&&a(f=f.update)&&f(n,e)}o(e.text)?a(v)&&a(b)?v!==b&&function(n,e,t,r,i){var s,l,u,p=0,f=0,h=e.length-1,m=e[0],v=e[h],b=t.length-1,g=t[0],w=t[b],_=!i;for(0;p<=h&&f<=b;)o(m)?m=e[++p]:o(v)?v=e[--h]:er(m,g)?(j(m,g,r,t,f),m=e[++p],g=t[++f]):er(v,w)?(j(v,w,r,t,b),v=e[--h],w=t[--b]):er(m,w)?(j(m,w,r,t,b),_&&c.insertBefore(n,m.elm,c.nextSibling(v.elm)),m=e[++p],w=t[--b]):er(v,g)?(j(v,g,r,t,f),_&&c.insertBefore(n,v.elm,m.elm),v=e[--h],g=t[++f]):(o(s)&&(s=tr(e,p,h)),o(l=a(g.key)?s[g.key]:k(g,e,p,h))?d(g,r,n,m.elm,!1,t,f):er(u=e[l],g)?(j(u,g,r,t,f),e[l]=void 0,_&&c.insertBefore(n,u.elm,m.elm)):d(g,r,n,m.elm,!1,t,f),g=t[++f]);p>h?y(n,o(t[b+1])?null:t[b+1].elm,t,f,b,r):f>b&&x(e,p,h)}(p,v,b,t,u):a(b)?(a(n.text)&&c.setTextContent(p,""),y(p,null,b,0,b.length-1,t)):a(v)?x(v,0,v.length-1):a(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),a(h)&&a(f=h.hook)&&a(f=f.postpatch)&&f(n,e)}}}function T(n,e,t){if(i(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=v("attrs,class,staticClass,staticStyle,key");function P(n,e,t,r){var o,s=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,i(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(o=l.hook)&&a(o=o.init)&&o(e,!0),a(o=e.componentInstance)))return p(e,t),!0;if(a(s)){if(a(c))if(n.hasChildNodes())if(a(o=l)&&a(o=o.domProps)&&a(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,f=0;f<c.length;f++){if(!d||!P(d,c[f],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else h(e,c,t);if(a(l)){var m=!1;for(var v in l)if(!S(v)){m=!0,b(e,t);break}!m&&l.class&&oe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,s){if(!o(e)){var l,u=!1,p=[];if(o(n))u=!0,d(e,p);else{var f=a(n.nodeType);if(!f&&er(n,e))j(n,e,p,null,null,s);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),i(t)&&P(n,e,p))return T(e,p,!0),n;l=n,n=new mn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,v=c.parentNode(h);if(d(e,p,h._leaveCb?null:v,c.nextSibling(h)),a(e.parent))for(var b=e.parent,g=m(e);b;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](b);if(b.elm=e.elm,g){for(var _=0;_<r.create.length;++_)r.create[_](Yt,b);var k=b.data.hook.insert;if(k.merged)for(var S=1;S<k.fns.length;S++)k.fns[S]()}else Zt(b);b=b.parent}a(v)?x([n],0,0):a(n.tag)&&w(n)}}return T(e,p,u),e.elm}a(n)&&w(n)}}({nodeOps:Xt,modules:[fr,vr,kr,Sr,Fr,H?{create:so,activate:so,remove:function(n,e){!0!==n.data.show?oo(n,e):e()}}:{}].concat(cr)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bo(n,"input")}));var co={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?le(t,"postpatch",(function(){co.componentUpdated(n,e,t)})):uo(n,e,t.context),n._vOptions=[].map.call(n.options,ho)):("textarea"===t.tag||Gt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",mo),n.addEventListener("compositionend",vo),n.addEventListener("change",vo),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){uo(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,ho);if(o.some((function(n,e){return!$(n,r[e])})))(n.multiple?e.value.some((function(n){return fo(n,o)})):e.value!==e.oldValue&&fo(e.value,o))&&bo(n,"change")}}};function uo(n,e,t){po(n,e,t),(G||K)&&setTimeout((function(){po(n,e,t)}),0)}function po(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],o)a=L(r,ho(i))>-1,i.selected!==a&&(i.selected=a);else if($(ho(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function fo(n,e){return e.every((function(e){return!$(e,n)}))}function ho(n){return"_value"in n?n._value:n.value}function mo(n){n.target.composing=!0}function vo(n){n.target.composing&&(n.target.composing=!1,bo(n.target,"input"))}function bo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function go(n){return!n.componentInstance||n.data&&n.data.transition?n:go(n.componentInstance._vnode)}var yo={model:co,show:{bind:function(n,e,t){var r=e.value,o=(t=go(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,ro(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=go(t)).data&&t.data.transition?(t.data.show=!0,r?ro(t,(function(){n.style.display=n.__vOriginalDisplay})):oo(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},wo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function xo(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?xo(He(e.children)):n}function _o(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var a in o)e[k(a)]=o[a];return e}function ko(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var jo=function(n){return n.tag||Ue(n)},To=function(n){return"show"===n.name},So={name:"transition",props:wo,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(jo)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=xo(o);if(!a)return o;if(this._leaving)return ko(n,o);var i="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?i+"comment":i+a.tag:s(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var l=(a.data||(a.data={})).transition=_o(this),c=this._vnode,u=xo(c);if(a.data.directives&&a.data.directives.some(To)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!Ue(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=C({},l);if("out-in"===r)return this._leaving=!0,le(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ko(n,o);if("in-out"===r){if(Ue(a))return c;var p,f=function(){p()};le(l,"afterEnter",f),le(l,"enterCancelled",f),le(d,"delayLeave",(function(n){p=n}))}}return o}}},Po=C({tag:String,moveClass:String},wo);function Oo(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Co(n){n.data.newPos=n.elm.getBoundingClientRect()}function Io(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+o+"px)",a.transitionDuration="0s"}}delete Po.mode;var Ao={Transition:So,TransitionGroup:{props:Po,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Ke(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=_o(this),s=0;s<o.length;s++){var l=o[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))a.push(l),t[l.key]=l,(l.data||(l.data={})).transition=i;else;}if(r){for(var c=[],u=[],d=0;d<r.length;d++){var p=r[d];p.data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):u.push(p)}this.kept=n(e,null,c),this.removed=u}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Oo),n.forEach(Co),n.forEach(Io),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Xr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Hr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Hr,n),t._moveCb=null,Kr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Vr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Br(t,n)})),qr(t,e),t.style.display="none",this.$el.appendChild(t);var r=no(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};kt.config.mustUseProp=function(n,e,t){return"value"===t&&Et(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},kt.config.isReservedTag=Jt,kt.config.isReservedAttr=At,kt.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},kt.config.isUnknownElement=function(n){if(!H)return!0;if(Jt(n))return!1;if(n=n.toLowerCase(),null!=Qt[n])return Qt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Qt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Qt[n]=/HTMLUnknownElement/.test(e.toString())},C(kt.options.directives,yo),C(kt.options.components,Ao),kt.prototype.__patch__=H?lo:A,kt.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new pt(n,r,A,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&H?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},H&&setTimeout((function(){q.devtools&&on&&on.emit("init",kt)}),0);var Eo=kt;
/*!
  * vue-router v3.5.1
  * (c) 2021 Evan You
  * @license MIT
  */function zo(n,e){for(var t in e)n[t]=e[t];return n}var $o=/[!'()*]/g,Lo=function(n){return"%"+n.charCodeAt(0).toString(16)},Ro=/%2C/g,Fo=function(n){return encodeURIComponent(n).replace($o,Lo).replace(Ro,",")};function Do(n){try{return decodeURIComponent(n)}catch(n){0}return n}var qo=function(n){return null==n||"object"==typeof n?n:String(n)};function Bo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Do(t.shift()),o=t.length>0?Do(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function No(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Fo(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Fo(e)):r.push(Fo(e)+"="+Fo(n)))})),r.join("&")}return Fo(e)+"="+Fo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Mo=/\/?$/;function Vo(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=Uo(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Jo(e,o),matched:n?Wo(n):[]};return t&&(i.redirectedFrom=Jo(t,o)),Object.freeze(i)}function Uo(n){if(Array.isArray(n))return n.map(Uo);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Uo(n[t]);return e}return n}var Ho=Vo(null,{path:"/"});function Wo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Jo(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||No)(r)+o}function Qo(n,e,t){return e===Ho?n===e:!!e&&(n.path&&e.path?n.path.replace(Mo,"")===e.path.replace(Mo,"")&&(t||n.hash===e.hash&&Go(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Go(n.query,e.query)&&Go(n.params,e.params))))}function Go(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?Go(a,i):String(a)===String(i)}))}function Xo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var Ko={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,a=e.data;a.routerView=!0;for(var i=o.$createElement,s=t.name,l=o.$route,c=o._routerViewCache||(o._routerViewCache={}),u=0,d=!1;o&&o._routerRoot!==o;){var p=o.$vnode?o.$vnode.data:{};p.routerView&&u++,p.keepAlive&&o._directInactive&&o._inactive&&(d=!0),o=o.$parent}if(a.routerViewDepth=u,d){var f=c[s],h=f&&f.component;return h?(f.configProps&&Zo(h,a,f.route,f.configProps),i(h,a,r)):i()}var m=l.matched[u],v=m&&m.components[s];if(!m||!v)return c[s]=null,i();c[s]={component:v},a.registerRouteInstance=function(n,e){var t=m.instances[s];(e&&t!==n||!e&&t===n)&&(m.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){m.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),Xo(l)};var b=m.props&&m.props[s];return b&&(zo(c[s],{route:l,configProps:b}),Zo(v,a,l,b)),i(v,a,r)}};function Zo(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=zo({},o);var a=e.attrs=e.attrs||{};for(var i in o)n.props&&i in n.props||(a[i]=o[i],delete o[i])}}function Yo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function na(n){return n.replace(/\/\//g,"/")}var ea=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ta=va,ra=la,oa=function(n,e){return ua(la(n,e),e)},aa=ua,ia=ma,sa=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function la(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=sa.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(a,u),a=u+l.length,c)i+=c[1];else{var d=n[a],p=t[2],f=t[3],h=t[4],m=t[5],v=t[6],b=t[7];i&&(r.push(i),i="");var g=null!=p&&null!=d&&d!==p,y="+"===v||"*"===v,w="?"===v||"*"===v,x=t[2]||s,_=h||m;r.push({name:f||o++,prefix:p||"",delimiter:x,optional:w,repeat:y,partial:g,asterisk:!!b,pattern:_?pa(_):b?".*":"[^"+da(x)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function ca(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ua(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",ha(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?ca:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ea(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=i(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function da(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function pa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fa(n,e){return n.keys=e,n}function ha(n){return n&&n.sensitive?"":"i"}function ma(n,e,t){ea(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=da(s);else{var l=da(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=da(t.delimiter||"/"),d=a.slice(-u.length)===u;return r||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=o?"$":r&&d?"":"(?="+u+"|$)",fa(new RegExp("^"+a,ha(t)),e)}function va(n,e,t){return ea(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fa(n,e)}(n,e):ea(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(va(n[o],e,t).source);return fa(new RegExp("(?:"+r.join("|")+")",ha(t)),e)}(n,e,t):function(n,e,t){return ma(la(n,t),e,t)}(n,e,t)}ta.parse=ra,ta.compile=oa,ta.tokensToFunction=aa,ta.tokensToRegExp=ia;var ba=Object.create(null);function ga(n,e,t){e=e||{};try{var r=ba[n]||(ba[n]=ta.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function ya(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var a=(o=zo({},n)).params;return a&&"object"==typeof a&&(o.params=zo({},a)),o}if(!o.path&&o.params&&e){(o=zo({},o))._normalized=!0;var i=zo(zo({},e.params),o.params);if(e.name)o.name=e.name,o.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;o.path=ga(s,i,e.path)}else 0;return o}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),c=e&&e.path||"/",u=l.path?Yo(l.path,c,t||o.append):c,d=function(n,e,t){void 0===e&&(e={});var r,o=t||Bo;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(qo):qo(i)}return r}(l.query,o.query,r&&r.options.parseQuery),p=o.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var wa,xa=function(){},_a={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),a=o.location,i=o.route,s=o.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,f=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,m=i.redirectedFrom?Vo(null,ya(i.redirectedFrom),null,t):i;l[h]=Qo(r,m,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(Mo,"/").indexOf(e.path.replace(Mo,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,m);var v=l[h]?this.ariaCurrentValue:null,b=function(n){ka(n)&&(e.replace?t.replace(a,xa):t.push(a,xa))},g={click:ka};Array.isArray(this.event)?this.event.forEach((function(n){g[n]=b})):g[this.event]=b;var y={class:l},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:b,isActive:l[f],isExactActive:l[h]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?n():n("span",{},w)}if("a"===this.tag)y.on=g,y.attrs={href:s,"aria-current":v};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var _=x.data=zo({},x.data);for(var k in _.on=_.on||{},_.on){var j=_.on[k];k in g&&(_.on[k]=Array.isArray(j)?j:[j])}for(var T in g)T in _.on?_.on[T].push(g[T]):_.on[T]=b;var S=x.data.attrs=zo({},x.data.attrs);S.href=s,S["aria-current"]=v}else y.on=g}return n(this.tag,y,this.$slots.default)}};function ka(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var ja="undefined"!=typeof window;function Ta(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return na(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var d={path:u,regex:Sa(u,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?na(i+"/"+o.path):void 0;n(e,t,r,o,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==o.alias)for(var p=Array.isArray(o.alias)?o.alias:[o.alias],f=0;f<p.length;++f){0;var h={path:p[f],children:o.children};n(e,t,r,h,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,i,s,n,o)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function Sa(n,e){return ta(n,[],e)}function Pa(n,e){var t=Ta(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=ya(n,t,!1,e),c=s.name;if(c){var u=a[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=ga(u.path,s.params),l(u,s,i)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=o[h];if(Oa(m.regex,s.path,s.params))return l(m,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(Vo(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var s=o,c=s.name,u=s.path,d=t.query,p=t.hash,f=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,f=s.hasOwnProperty("params")?s.params:f,c){a[c];return i({_normalized:!0,name:c,query:d,hash:p,params:f},void 0,t)}if(u){var h=function(n,e){return Yo(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:ga(h,f),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:ga(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):Vo(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ta([e||n],r,o,a,t),t&&Ta(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Ta(n,r,o,a)}}}function Oa(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?Do(r[o]):r[o])}return!0}var Ca=ja&&window.performance&&window.performance.now?window.performance:Date;function Ia(){return Ca.now().toFixed(3)}var Aa=Ia();function Ea(){return Aa}function za(n){return Aa=n}var $a=Object.create(null);function La(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=zo({},window.history.state);return t.key=Ea(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Da),function(){window.removeEventListener("popstate",Da)}}function Ra(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=Ea();if(n)return $a[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){Va(n,a)})).catch((function(n){0})):Va(i,a))}))}}function Fa(){var n=Ea();n&&($a[n]={x:window.pageXOffset,y:window.pageYOffset})}function Da(n){Fa(),n.state&&n.state.key&&za(n.state.key)}function qa(n){return Na(n.x)||Na(n.y)}function Ba(n){return{x:Na(n.x)?n.x:window.pageXOffset,y:Na(n.y)?n.y:window.pageYOffset}}function Na(n){return"number"==typeof n}var Ma=/^#\d/;function Va(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=Ma.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:Na((t=a).x)?t.x:0,y:Na(t.y)?t.y:0})}else qa(n)&&(e=Ba(n))}else r&&qa(n)&&(e=Ba(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Ua,Ha=ja&&((-1===(Ua=window.navigator.userAgent).indexOf("Android 2.")&&-1===Ua.indexOf("Android 4.0")||-1===Ua.indexOf("Mobile Safari")||-1!==Ua.indexOf("Chrome")||-1!==Ua.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Wa(n,e){Fa();var t=window.history;try{if(e){var r=zo({},t.state);r.key=Ea(),t.replaceState(r,"",n)}else t.pushState({key:za(Ia())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ja(n){Wa(n,!0)}function Qa(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}var Ga={redirected:2,aborted:4,cancelled:8,duplicated:16};function Xa(n,e){return Za(n,e,Ga.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Ya.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Ka(n,e){return Za(n,e,Ga.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Za(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var Ya=["params","query","hash"];function ni(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ei(n,e){return ni(n)&&n._isRouter&&(null==e||n.type===e)}function ti(n){return function(e,t,r){var o=!1,a=0,i=null;ri(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var l,c=ii((function(e){var o;((o=e).__esModule||ai&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:wa.extend(e),t.components[s]=e,--a<=0&&r()})),u=ii((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ni(n)?n:new Error(e),r(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),o||r()}}function ri(n,e){return oi(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function oi(n){return Array.prototype.concat.apply([],n)}var ai="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ii(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var si=function(n,e){this.router=n,this.base=function(n){if(!n)if(ja){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Ho,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function li(n,e,t,r){var o=ri(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=wa.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return oi(r?o.reverse():o)}function ci(n,e){if(e)return function(){return n.apply(e,arguments)}}si.prototype.listen=function(n){this.cb=n},si.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},si.prototype.onError=function(n){this.errorCbs.push(n)},si.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(ei(n,Ga.redirected)&&a===Ho||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},si.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!ei(n)&&ni(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(Qo(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),s(((i=Za(a=o,n,Ga.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,f=u.activated,h=[].concat(function(n){return li(n,"beforeRouteLeave",ci,!0)}(p),this.router.beforeHooks,function(n){return li(n,"beforeRouteUpdate",ci)}(d),f.map((function(n){return n.beforeEnter})),ti(f)),m=function(e,t){if(r.pending!==n)return s(Ka(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return Za(n,e,Ga.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):ni(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Xa(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Qa(h,m,(function(){Qa(function(n){return li(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(Ka(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Xo(n)}))}))}))},si.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},si.prototype.setupListeners=function(){},si.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Ho,this.pending=null};var ui=function(n){function e(e,t){n.call(this,e,t),this._startLocation=di(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Ha&&t;r&&this.listeners.push(La());var o=function(){var t=n.current,o=di(n.base);n.current===Ho&&o===n._startLocation||n.transitionTo(o,(function(n){r&&Ra(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Wa(na(r.base+n.fullPath)),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Ja(na(r.base+n.fullPath)),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(di(this.base)!==this.current.fullPath){var e=na(this.base+this.current.fullPath);n?Wa(e):Ja(e)}},e.prototype.getCurrentLocation=function(){return di(this.base)},e}(si);function di(n){var e=window.location.pathname;return n&&0===e.toLowerCase().indexOf(n.toLowerCase())&&(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var pi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=di(n);if(!/^\/#/.test(e))return window.location.replace(na(n+"/#"+e)),!0}(this.base)||fi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Ha&&e;t&&this.listeners.push(La());var r=function(){var e=n.current;fi()&&n.transitionTo(hi(),(function(r){t&&Ra(n.router,r,e,!0),Ha||bi(r.fullPath)}))},o=Ha?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){vi(n.fullPath),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){bi(n.fullPath),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;hi()!==e&&(n?vi(e):bi(e))},e.prototype.getCurrentLocation=function(){return hi()},e}(si);function fi(){var n=hi();return"/"===n.charAt(0)||(bi("/"+n),!1)}function hi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function mi(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function vi(n){Ha?Wa(mi(n)):window.location.hash=n}function bi(n){Ha?Ja(mi(n)):window.location.replace(mi(n))}var gi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ei(n,Ga.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(si),yi=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Pa(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Ha&&!1!==n.fallback,this.fallback&&(e="hash"),ja||(e="abstract"),this.mode=e,e){case"history":this.history=new ui(this,n.base);break;case"hash":this.history=new pi(this,n.base,this.fallback);break;case"abstract":this.history=new gi(this,n.base);break;default:0}},wi={currentRoute:{configurable:!0}};function xi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}yi.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},wi.currentRoute.get=function(){return this.history&&this.history.current},yi.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof ui||t instanceof pi){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;Ha&&o&&"fullPath"in n&&Ra(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},yi.prototype.beforeEach=function(n){return xi(this.beforeHooks,n)},yi.prototype.beforeResolve=function(n){return xi(this.resolveHooks,n)},yi.prototype.afterEach=function(n){return xi(this.afterHooks,n)},yi.prototype.onReady=function(n,e){this.history.onReady(n,e)},yi.prototype.onError=function(n){this.history.onError(n)},yi.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},yi.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},yi.prototype.go=function(n){this.history.go(n)},yi.prototype.back=function(){this.go(-1)},yi.prototype.forward=function(){this.go(1)},yi.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},yi.prototype.resolve=function(n,e,t){var r=ya(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?na(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},yi.prototype.getRoutes=function(){return this.matcher.getRoutes()},yi.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Ho&&this.history.transitionTo(this.history.getCurrentLocation())},yi.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Ho&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(yi.prototype,wi),yi.install=function n(e){if(!n.installed||wa!==e){n.installed=!0,wa=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Ko),e.component("RouterLink",_a);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},yi.version="3.5.1",yi.isNavigationFailure=ei,yi.NavigationFailureType=Ga,yi.START_LOCATION=Ho,ja&&window.Vue&&window.Vue.use(yi);var _i=yi;var ki={NotFound:()=>t.e(16).then(t.bind(null,223)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,222))},ji={"v-44d268af":()=>t.e(17).then(t.bind(null,226)),"v-9151a818":()=>t.e(18).then(t.bind(null,227)),"v-2fdcb37f":()=>t.e(21).then(t.bind(null,228)),"v-d2af4fc2":()=>t.e(24).then(t.bind(null,229)),"v-369d602a":()=>t.e(22).then(t.bind(null,230)),"v-d221e09a":()=>t.e(23).then(t.bind(null,231)),"v-1c221902":()=>t.e(20).then(t.bind(null,232)),"v-654b2ab9":()=>t.e(19).then(t.bind(null,233)),"v-9c284b9c":()=>t.e(25).then(t.bind(null,234)),"v-355bdaa1":()=>t.e(5).then(t.bind(null,235)),"v-5ee63579":()=>t.e(26).then(t.bind(null,236)),"v-25bb32df":()=>t.e(4).then(t.bind(null,237)),"v-58b38159":()=>t.e(27).then(t.bind(null,238)),"v-5f71c739":()=>t.e(29).then(t.bind(null,239)),"v-2b53d5dc":()=>t.e(30).then(t.bind(null,240)),"v-4d1fb77a":()=>t.e(31).then(t.bind(null,241)),"v-8cfa76c2":()=>t.e(28).then(t.bind(null,242)),"v-57d4d2af":()=>t.e(32).then(t.bind(null,243)),"v-2ee9a139":()=>t.e(6).then(t.bind(null,244)),"v-544c8bf7":()=>t.e(7).then(t.bind(null,245)),"v-54fd41b9":()=>t.e(3).then(t.bind(null,246)),"v-b17c92ce":()=>t.e(11).then(t.bind(null,247)),"v-05a6f19c":()=>t.e(34).then(t.bind(null,248)),"v-a3442b8e":()=>t.e(33).then(t.bind(null,249)),"v-4ee647e1":()=>t.e(37).then(t.bind(null,250)),"v-663bdb0e":()=>t.e(12).then(t.bind(null,251)),"v-e3ce978e":()=>t.e(13).then(t.bind(null,252)),"v-ee3428ce":()=>t.e(35).then(t.bind(null,253)),"v-4a1fa2e5":()=>t.e(38).then(t.bind(null,254)),"v-781ef711":()=>t.e(36).then(t.bind(null,255)),"v-53fc998e":()=>t.e(39).then(t.bind(null,256)),"v-f1fdf422":()=>t.e(40).then(t.bind(null,257)),"v-655c1b36":()=>t.e(44).then(t.bind(null,258)),"v-bbf4764e":()=>t.e(14).then(t.bind(null,259)),"v-5b00dab9":()=>t.e(41).then(t.bind(null,260)),"v-2604c9e3":()=>t.e(42).then(t.bind(null,261)),"v-25e7b55f":()=>t.e(45).then(t.bind(null,262)),"v-61109a1c":()=>t.e(46).then(t.bind(null,263)),"v-ced71a3e":()=>t.e(15).then(t.bind(null,264)),"v-392672d2":()=>t.e(49).then(t.bind(null,265)),"v-4810ac9f":()=>t.e(43).then(t.bind(null,266)),"v-7ee3a2d9":()=>t.e(51).then(t.bind(null,267)),"v-1e31d6f9":()=>t.e(47).then(t.bind(null,268)),"v-41a40162":()=>t.e(50).then(t.bind(null,269)),"v-621b90ce":()=>t.e(54).then(t.bind(null,270)),"v-e0b82d0e":()=>t.e(48).then(t.bind(null,271)),"v-104f3dd9":()=>t.e(52).then(t.bind(null,272)),"v-2311a39b":()=>t.e(57).then(t.bind(null,273)),"v-0bee68b9":()=>t.e(55).then(t.bind(null,274)),"v-4b85924e":()=>t.e(53).then(t.bind(null,275)),"v-36459e7f":()=>t.e(56).then(t.bind(null,276)),"v-1dda9912":()=>t.e(58).then(t.bind(null,277))};function Ti(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Si=/-(\w)/g,Pi=Ti(n=>n.replace(Si,(n,e)=>e?e.toUpperCase():"")),Oi=/\B([A-Z])/g,Ci=Ti(n=>n.replace(Oi,"-$1").toLowerCase()),Ii=Ti(n=>n.charAt(0).toUpperCase()+n.slice(1));function Ai(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ii(Pi(e))):n(Ii(e))||n(Ci(e))}const Ei=Object.assign({},ki,ji),zi=n=>Ei[n],$i=n=>ji[n],Li=n=>ki[n],Ri=n=>Eo.component(n);function Fi(n){return Ai($i,n)}function Di(n){return Ai(Li,n)}function qi(n){return Ai(zi,n)}function Bi(n){return Ai(Ri,n)}function Ni(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!Bi(n)&&qi(n)){const e=await qi(n)();Eo.component(n,e.default)}}))}function Mi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Vi=t(45),Ui=t.n(Vi),Hi={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${n[t]}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=Ji(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=Qi(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Ui()([{name:"description",content:this.$description}],n,this.siteMeta,Gi)},updateCanonicalLink(){Wi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Ji(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){Qi(null,this.currentMetaTags),Wi()}};function Wi(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Ji(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function Qi(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Gi(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Xi=t(46),Ki={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Xi)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],i=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(o===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Zi=t(12),Yi=t.n(Zi),ns=[Hi,Ki,{mounted(){Yi.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Eo.component(n.name)||Yi.a.start(),t()}),this.$router.afterEach(()=>{Yi.a.done(),this.isSidebarOpen=!1})}}],es={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Mi("layout",n),Eo.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ts=t(6),rs=Object(ts.a)(es,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(rs,"mixins",ns);const os=[{name:"v-44d268af",path:"/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-44d268af").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-9151a818",path:"/cpp/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-9151a818").then(t)}},{path:"/cpp/index.html",redirect:"/cpp/"},{name:"v-2fdcb37f",path:"/cpp/oop.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-2fdcb37f").then(t)}},{name:"v-d2af4fc2",path:"/cpp/snippet.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-d2af4fc2").then(t)}},{name:"v-369d602a",path:"/cpp/problems.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-369d602a").then(t)}},{name:"v-d221e09a",path:"/cpp/rules_naming.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-d221e09a").then(t)}},{name:"v-1c221902",path:"/cpp/keywords.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-1c221902").then(t)}},{name:"v-654b2ab9",path:"/cpp/header.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-654b2ab9").then(t)}},{name:"v-9c284b9c",path:"/frameworks/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-9c284b9c").then(t)}},{path:"/frameworks/index.html",redirect:"/frameworks/"},{name:"v-355bdaa1",path:"/dsa/approach.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-355bdaa1").then(t)}},{name:"v-5ee63579",path:"/frameworks/electron.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-5ee63579").then(t)}},{name:"v-25bb32df",path:"/dsa/basis.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-25bb32df").then(t)}},{name:"v-58b38159",path:"/frameworks/tensorflow.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-58b38159").then(t)}},{name:"v-5f71c739",path:"/http/cors.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-5f71c739").then(t)}},{name:"v-2b53d5dc",path:"/java/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-2b53d5dc").then(t)}},{path:"/java/index.html",redirect:"/java/"},{name:"v-4d1fb77a",path:"/java/basis.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-4d1fb77a").then(t)}},{name:"v-8cfa76c2",path:"/git/gitignore.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-8cfa76c2").then(t)}},{name:"v-57d4d2af",path:"/java/feature_jdk.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-57d4d2af").then(t)}},{name:"v-2ee9a139",path:"/javascript/asynchronous.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-2ee9a139").then(t)}},{name:"v-544c8bf7",path:"/java/design_patterns.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-544c8bf7").then(t)}},{name:"v-54fd41b9",path:"/java/multithreading.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-54fd41b9").then(t)}},{name:"v-b17c92ce",path:"/java/problems.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-b17c92ce").then(t)}},{name:"v-05a6f19c",path:"/javascript/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-05a6f19c").then(t)}},{path:"/javascript/index.html",redirect:"/javascript/"},{name:"v-a3442b8e",path:"/java/reflection.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-a3442b8e").then(t)}},{name:"v-4ee647e1",path:"/javascript/context_scope.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-4ee647e1").then(t)}},{name:"v-663bdb0e",path:"/javascript/background.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-663bdb0e").then(t)}},{name:"v-e3ce978e",path:"/javascript/built_in_object.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-e3ce978e").then(t)}},{name:"v-ee3428ce",path:"/javascript/class_and_module.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-ee3428ce").then(t)}},{name:"v-4a1fa2e5",path:"/javascript/dom.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-4a1fa2e5").then(t)}},{name:"v-781ef711",path:"/javascript/common_function.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-781ef711").then(t)}},{name:"v-53fc998e",path:"/javascript/function.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-53fc998e").then(t)}},{name:"v-f1fdf422",path:"/javascript/iteration.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-f1fdf422").then(t)}},{name:"v-655c1b36",path:"/linux/commands.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-655c1b36").then(t)}},{name:"v-bbf4764e",path:"/javascript/object.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-bbf4764e").then(t)}},{name:"v-5b00dab9",path:"/javascript/problems.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-5b00dab9").then(t)}},{name:"v-2604c9e3",path:"/lessons/discrete_mathematics.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-2604c9e3").then(t)}},{name:"v-25e7b55f",path:"/linux/shell.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-25e7b55f").then(t)}},{name:"v-61109a1c",path:"/nodejs/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-61109a1c").then(t)}},{path:"/nodejs/index.html",redirect:"/nodejs/"},{name:"v-ced71a3e",path:"/lessons/digital_circuits.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-ced71a3e").then(t)}},{name:"v-392672d2",path:"/python/",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-392672d2").then(t)}},{path:"/python/index.html",redirect:"/python/"},{name:"v-4810ac9f",path:"/lessons/ml_and_big_data.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-4810ac9f").then(t)}},{name:"v-7ee3a2d9",path:"/python/ducking_type.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-7ee3a2d9").then(t)}},{name:"v-1e31d6f9",path:"/nodejs/package_management.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-1e31d6f9").then(t)}},{name:"v-41a40162",path:"/python/built_in_things.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-41a40162").then(t)}},{name:"v-621b90ce",path:"/python/special.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-621b90ce").then(t)}},{name:"v-e0b82d0e",path:"/nodejs/problems.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-e0b82d0e").then(t)}},{name:"v-104f3dd9",path:"/python/problems.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-104f3dd9").then(t)}},{name:"v-2311a39b",path:"/tools/problems.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-2311a39b").then(t)}},{name:"v-0bee68b9",path:"/python/special_method.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-0bee68b9").then(t)}},{name:"v-4b85924e",path:"/python/rules_naming.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-4b85924e").then(t)}},{name:"v-36459e7f",path:"/react/basis.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-36459e7f").then(t)}},{name:"v-1dda9912",path:"/tools/taking_notes.html",component:rs,beforeEnter:(n,e,t)=>{Ni("Layout","v-1dda9912").then(t)}},{path:"*",component:rs}],as={title:"Situ Book",description:"Taking notes",base:"/",headTags:[["link",{rel:"icon",href:"/logo-book.svg"}],["link",{rel:"stylesheet",href:"/katex.min.css"}]],pages:[{title:"Situ Book",frontmatter:{},regularPath:"/",relativePath:"README.md",key:"v-44d268af",path:"/",headersStr:null,content:"# Situ Book\n\n\n\n> We shape our tools, thereafter our tools shape us.\n\nKeep a note, and one day it will keep you.",normalizedContent:"# situ book\n\n\n\n> we shape our tools, thereafter our tools shape us.\n\nkeep a note, and one day it will keep you.",charsets:{}},{title:"C++",frontmatter:{},regularPath:"/cpp/",relativePath:"cpp/README.md",key:"v-9151a818",path:"/cpp/",headersStr:null,content:"# C++\n\nIt is mighty but I am vegetable.",normalizedContent:"# c++\n\nit is mighty but i am vegetable.",charsets:{}},{title:"OOP(C++)",frontmatter:{},regularPath:"/cpp/oop.html",relativePath:"cpp/oop.md",key:"v-2fdcb37f",path:"/cpp/oop.html",headers:[{level:2,title:"Operators",slug:"operators",normalizedTitle:"operators",charIndex:52},{level:2,title:"Member function",slug:"member-function",normalizedTitle:"member function",charIndex:67},{level:2,title:"Instantiation",slug:"instantiation",normalizedTitle:"instantiation",charIndex:88},{level:2,title:"Virtual function",slug:"virtual-function",normalizedTitle:"virtual function",charIndex:107},{level:2,title:"Override",slug:"override",normalizedTitle:"override",charIndex:129},{level:2,title:"Modifier",slug:"modifier",normalizedTitle:"modifier",charIndex:143},{level:2,title:"Static keyword",slug:"static-keyword",normalizedTitle:"static keyword",charIndex:157},{level:2,title:"Friend keyword",slug:"friend-keyword",normalizedTitle:"friend keyword",charIndex:177},{level:2,title:"Inheritance",slug:"inheritance",normalizedTitle:"inheritance",charIndex:197},{level:2,title:"Multiple inheritance",slug:"multiple-inheritance",normalizedTitle:"multiple inheritance",charIndex:214},{level:2,title:"Constructors and member initializer lists",slug:"constructors-and-member-initializer-lists",normalizedTitle:"constructors and member initializer lists",charIndex:240},{level:2,title:"Constructor and Destructor",slug:"constructor-and-destructor",normalizedTitle:"constructor and destructor",charIndex:287},{level:2,title:"Copy Constructor",slug:"copy-constructor",normalizedTitle:"copy constructor",charIndex:319},{level:2,title:"Move Constructor",slug:"move-constructor",normalizedTitle:"move constructor",charIndex:341},{level:2,title:"Pointer",slug:"pointer",normalizedTitle:"pointer",charIndex:363},{level:2,title:"Function definition",slug:"function-definition",normalizedTitle:"function definition",charIndex:376},{level:2,title:"Default and delete",slug:"default-and-delete",normalizedTitle:"default and delete",charIndex:401},{level:2,title:"Operator overloading",slug:"operator-overloading",normalizedTitle:"operator overloading",charIndex:425},{level:2,title:"Const keyword",slug:"const-keyword",normalizedTitle:"const keyword",charIndex:451},{level:2,title:"Type casting",slug:"type-casting",normalizedTitle:"type casting",charIndex:470}],excerpt:'<h1 id="oop-c"><a class="header-anchor" href="#oop-c">#</a> OOP(C++)</h1>\n<p>前提：基于java中面向对象的知识储备</p>\n<p><div class="table-of-contents"><ul><li><a href="#oop-c">OOP(C++)</a></li></ul></div></p>\n<p>(个人笔记) 要不是大一下学校的OOP课要讲MFC...</p>\n',headersStr:"Operators Member function Instantiation Virtual function Override Modifier Static keyword Friend keyword Inheritance Multiple inheritance Constructors and member initializer lists Constructor and Destructor Copy Constructor Move Constructor Pointer Function definition Default and delete Operator overloading Const keyword Type casting",content:'# OOP(C++)\n\n前提：基于java中面向对象的知识储备\n\n\n\n * OOP(C++)\n   * Operators\n   * Member function\n   * Instantiation\n   * Virtual function\n   * Override\n   * Modifier\n   * Static keyword\n   * Friend keyword\n   * Inheritance\n   * Multiple inheritance\n   * Constructors and member initializer lists\n   * Constructor and Destructor\n   * Copy Constructor\n   * Move Constructor\n   * Pointer\n   * Function definition\n   * Default and delete\n   * Operator overloading\n   * Const keyword\n   * Type casting\n\n\n\n(个人笔记) 要不是大一下学校的OOP课要讲MFC...\n\n基于java中的OOP来学习C++的OOP（可 迁 移 学 习）（爆炸预定\n\n感觉C++中的OOP多了好多东西啊（太菜了）\n\n\n# Operators\n\n按优先级来说的。\n\nscope qualifier: ::，很直白，翻译过来就叫做作用域限定符\n\nmember access: .和->常见，前者是非指针变量用过的，后者是指针变量用的\n\nclass上的:，如同java里的extends\n\n\n# Member function\n\n这个其实怎么说呢，我就把它跟java里头的instance method混为一谈了。所以这样理解就没问题了。\n\n\n# Instantiation\n\n无参数的话，不用带parentheses\n\nTest test1;\n\nTest* test2 = new Test;\n\n\n前者开在stack上，后者开在heap上。（java直接扔heap上不香吗\n\n\n# Virtual function\n\n函数就有非虚函数，虚函数和纯虚函数这三种了，太草了。由于java的对象方法默认就是virtual的（JVM调用指令invokevirtual），然后java可以多态，要invoke的方法都是在runtime进行动态绑定的。所以C++里头的函数虚不虚，就很好理解了。\n\n比如java里头定义一个父类抽象方法的话，子类来实现。\n\n//father\npublic abstract void test();\n//son\n@Override\npublic void test() {\n  /** do sth */\n}\n\n\nC++就要用到纯虚函数了\n\n//father\nvirtual void test() = 0;\n//son\nvirtual void test()\n{\n  /** do sth */\n}\n\n\n如果父类的虚函数想有自己的实现的话，把= 0去掉，加自己的实现即可（此时仍然有多态）。但此时的父类就不是抽象类了，可以被实例化。\n\nclass Animal\n{\n    public:\n    virtual void eat()\n    {\n        std::cout << "I am eating food." << std::endl;\n    }\n};\n\nclass Chicken : public Animal\n{\n    public:\n    virtual void eat()\n    {\n        std::cout << "I am eating hay" << std::endl;\n    }\n};\n\n\n\n# Override\n\n该关键字(C++11)可以防止写虚函数重载的时候，不小心写错的大无语事件发生。\n\nvirtual void eat() override;\n\n\n\n# Modifier\n\n似乎因为没有jvav的package，所以这么几个modifier都没有了package access的restriction（因为根本没有package啊）。所以就很方便了。\n\npublic类的外部都能访问。\n\nprotected自己和派生类能访问。(！大不同！)\n\nprivate直接是私有，类里的能访问。\n\n\n# Static keyword\n\n这个也没啥大区别的，唯一的小区别就是访问static的方法或变量需要使用operator ::\n\n还有，根据C++17前（艹）的标准。define的时候必须要在类外面进行(除非为const的时候才能在类内做定义)\n\n//class Test\npublic:\n  static int i;\n\n// outside the class\nstatic int Test::i = 114514;\n\n//main\nTest::i // 114514\n\n\n为什么要这样做呢？估计要等到了解csapp之后了（\n\nC++17及之后可以inline\n\ninline static int i = 114514;\n\n\n\n# Friend keyword\n\n> The friend declaration appears in a class body and grants a function or another class access to private and protected members of the class where the friend declaration appears.\n\nclass Test\n{\npublic:\n  friend void getNum(Test test)\n  {\n    std::cout << test.num << std::endl;\n  }\nprivate:\n  int num = 114514;\n};\n\n// or\nfriend void getNum(Test test);\n\n// outside of the class\nvoid getNum(Test test)\n{\n  // implements here\n}\n\n\nTest test;\ngetNum(test); // 114514\n\n\n当然也可以在里头声明一个友元类，此时友元类里的成员函数都能访问到这个类的private field\n\n前提是有一个该类的对象，才能进行访问\n\n//In class Test\nfriend class Friend;\n\n//Friend\nclass Friend\n{\n  /** ... */\n  /** have the access to private field of Test */\n}\n\n\n\n# Inheritance\n\nclass Chicken : public Animal\n\n\n继承的话，要注意，C++继承的class默认是private的，（前期naive认知）所以（不一定）要加个public，否则外部无法使用父类的方法。（原来还能用scope qualifier艹）\n\n经查询继承类型有如下，比如上面的public Animal就是公有继承了\n\n 1. 公有继承\n 2. 保护继承\n 3. 私有继承\n\n原理是将所继承的父类member的accessibility给降级...public->protected->private\n\n比如在保护继承和私有的继承的情况下，如果想改变某一个member的accessibility（比如原来是public或protected的，但是继承后降级），可以使用scope qualifier...(差不多得了)\n\nclass Animal\n{\n    int i = 1141514;\npublic:\n    Animal() = default;\n    void foo() {}\n};\n\nclass Chicken : Animal\n{\npublic:\n    Animal::foo;\n};\n\nint main()\n{\n    Chicken foo;\n    foo.foo();\n}\n\n\n\n# Multiple inheritance\n\n主要是用来当Interface用吧（C++的OOP没有Interface...\n\nclass Foo : public BaseFoo, public BaseBar\n\n\n如果有命名冲突就用scope qualifier吧...\n\n然后还有歧义的问题，就是这样的\n\n#include <iostream>\n\nclass Base\n{\npublic:\n  Base() { std::cout << "Base was constructed" << \'\\n\'; }\n  void test()\n  {\n    std::cout << "tested" << \'\\n\';\n  }\n};\n\nclass Bar : public Base\n{\npublic:\n  Bar() { std::cout << "Bar was constructed" << \'\\n\'; }\n};\n\nclass Bar1 : public Base\n{\npublic:\n  Bar1() { std::cout << "Bar1 was constructed" << \'\\n\'; }\n};\n\nclass Foo : public Bar, public Bar1\n{\npublic:\n  Foo() { std::cout << "Foo was constructed" << \'\\n\'; }\n};\n\nint main()\n{\n  Foo foo;\n}\n\n\n输出\n\nBase was constructed\nBar was constructed\nBase was constructed\nBar1 was constructed\nFoo was constructed\n\n\n如果main里加foo.test()会报错ambiguous access of \'test\'，因为每个Bar类都分别有自己的一个父类对象。如下所示\n\nBase   Base\n |      |\nBar    Bar1\n   \\  /\n    Foo\n\n\n为避免这个问题，我们使用虚继承（virtual inheritance）...\n\n把两个Bar类的继承里的modifier加上关键字virtual，就会得到如下，两者继承到了同一个父类对象上。\n\nBase was constructed\nBar was constructed\nBar1 was constructed\nFoo was constructed\n\n\n此时的继承关系为\n\n   Base\n  /   \\\nBar    Bar1\n  \\   /\n   Foo\n\n\n\n# Constructors and member initializer lists\n\npublic:\n  Chicken() : Animal(arg)\n  {\n    /** do sth */\n  }\n\n\n相似地，我们也可以用来给field初始化\n\nprivate:\n  std::string text = nullptr;\npublic:\n  Foo() : text("114514")\n  {\n    /** do sth */\n  }\n\n\n\n# Constructor and Destructor\n\n常见，语法也是差不多，但是后者析构这个就没见过了（GC擦屁股太香了\n\n类的析构和构造，都是默认缺省的（无参数），这点都一样，当然也可以自己写实现\n\n//class Test\n~Test()\n{\n  std::cout << "instance deleted";\n}\n\n\n出栈或者delete的时候会被隐式调用\n\n方法命名就这，直接是constructor前加 ~\n\n\n# Copy Constructor\n\n然后就是这个了，同上，这个东西也是默认缺省的，像这样，传的必须要是一个引用类型（不传引用？你可以想想套娃调用...）。\n\nTest::Test(const Point&)\n\n\n其中这个类型，可以cv-qualified，其中const主要是用来应对rvalue的（const T&和T&&都能被赋值一个临时对象），如果copy constructor的参数类型不加const那么这个就会报错\n\n// in a function body\nreturn obj;\n\n\n本来java中的引用变量之间的赋值就是把这个变量的值赋给你而已。但是C++直接给你弄了个了新对象。\n\n//main\nTest test;\nTest test1 = test; //invoke Copy Constructor\n\n\n调用默认拷贝构造函数的时候，一切栈上的变量都被拷过去了(这不就是跟struct一模一样吗)。但是当然要自己实现的时候，就不是这样了（要自己一个一个加实现）\n\nTest test;\nTest test1;\ntest1 = test; // This is operator overloading, NOT invoking copy constructor\n\n\n此外，函数返回一个对象，传参(一个对象)进去函数的时候，也会调用copy constructor\n\n\n# Move Constructor\n\nC++11开始加入了rvalue reference，这是什么呢，一查cpprefernce就能看到短小精悍的解释\n\n> Rvalue references can be used to extend the lifetimes of temporary objects\n\n两个字来说就是续命\n\n还有std::move，类的构造器也有了移动构造函数\n\n//class Foo\npublic:\n  Foo(Foo&& bar); \n\n\n初始化并赋值一个新对象的时候，可以使用Move constructor\n\nFoo foo1;\nFoo foo2 = std::move(foo1);\n\n\n\n# Pointer\n\n * this\n\nthis跟java一样，C++只有成员函数才有的。记得member access要用operator ->\n\n * Pointer to an object\n\n这个java的引用变量是差不多的。声明也就这样\n\nClassType* pointer;\n\n\n用法也就那样，如\n\nTest test1;\nTest* pointer = &test1;\n\nTest* test2 = new Test;\n\n\n\n# Function definition\n\n来自cpluscplus.com\n\n> The only difference between defining a class member function completely within its class or to include only the prototype and later its definition, is that in the first case the function will automatically be considered an inline member function by the compiler, while in the second it will be a normal (not-inline) class member function, which in fact supposes no difference in behavior\n\n\n# Default and delete\n\n如果有带参的constructor，那么可以用=default来写默认constructor如Test(){}。\n\n如果要禁用某个函数，可以上=delete\n\nTest() = default;\nTest(const X&) = delete;\nTest& operator=(const X&) = delete;\n\n//main\nTest test;\nTest test1 = test; //wrong!\nTest test2;\ntest2 = test3; //wrong!\n\n\n\n# Operator overloading\n\n直接扔cppreference算了: 直达\n\n注意，一个重载运算符的函数，其operand必须有一个是枚举类型或者类类型。\n\n> When an operator appears in an expression, and at least one of its operands has a class type or an enumeration type\n\n其实返回值赋给谁的这个问题，我想了想，估计可以直接与基本类型的运算挂钩。结合一下操作符运算的本质特点就可以了！\n\n对应到方法呢？比如+是这样的，成员函数a.operator+(b)，非成员函数operator+(a, b)\n\n但是一些运算符是不能被重载为非成员函数的: =, (), [], ->\n\n有些运算符需要记录一下，代码扔到snippet里了\n\n\n# Const keyword\n\n一般来说呢，const是作用于它左边的（如果左边啥都没有的话就是作用于右边）。而这个关键字const能作用于变量、成员函数、类对象...\n\n关键是有const修饰的，就不能修改里面成员的内存空间。\n\n如果有Foo const foo;，那么这个对象变量（或指针）就不能访问非const方法，也不能修改成员了。如果有一个const方法，那么在这个方法体内，不能访问非const方法，也不能修改成员变量。（实质在后面说了）\n\n而我查了cppreference，里面这样说\n\n> const object - an object whose type is const-qualified, or a non-mutable subobject of a const object. Such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.\n\n并且const了的函数实质又是？是这样的，其实就是把这个函数里头的*this给const掉了。\n\n> In the body of a cv-qualified function, *this is cv-qualified, e.g. in a const member function, only other const member functions may be called normally. (A non-const member function may still be called if const_cast is applied or through an access path that does not involve this.)\n\n\n# Type casting\n\n面向SO编程\n\n在OOP里头一般用到的casting关键字，一般有static_cast, dynamic_cast, const_cast和reinterpret_cast和C风格cast）\n\n * static_cast是安全地，隐式地在类型之间进行转换(比如void, int, double, float)\n * dynamic_cast是在有继承关系的类之间的up cast, down cast and side cast（虽然上者也可以，但是上者对虚类down cast的支持不好）\n * const_cast可以对对象的指针或引用进行const约束的添加和删除\n * reinterpret_cast暴力casting，不管啥的\n\n一个例子\n\n#include <iostream>\n\nstruct Base\n{\n  int a = 114514;\n};\n\nstruct D : public Base\n{\n  int a = 1919810;\n};\n\nint main()\n{\n  D* d = new D;\n  std::cout << d->a << \'\\n\'; // 1919810\n  Base* b = dynamic_cast<Base*>(d); // upcast\n  std::cout << b->a; // 114514\n}\n',normalizedContent:'# oop(c++)\n\n前提：基于java中面向对象的知识储备\n\n\n\n * oop(c++)\n   * operators\n   * member function\n   * instantiation\n   * virtual function\n   * override\n   * modifier\n   * static keyword\n   * friend keyword\n   * inheritance\n   * multiple inheritance\n   * constructors and member initializer lists\n   * constructor and destructor\n   * copy constructor\n   * move constructor\n   * pointer\n   * function definition\n   * default and delete\n   * operator overloading\n   * const keyword\n   * type casting\n\n\n\n(个人笔记) 要不是大一下学校的oop课要讲mfc...\n\n基于java中的oop来学习c++的oop（可 迁 移 学 习）（爆炸预定\n\n感觉c++中的oop多了好多东西啊（太菜了）\n\n\n# operators\n\n按优先级来说的。\n\nscope qualifier: ::，很直白，翻译过来就叫做作用域限定符\n\nmember access: .和->常见，前者是非指针变量用过的，后者是指针变量用的\n\nclass上的:，如同java里的extends\n\n\n# member function\n\n这个其实怎么说呢，我就把它跟java里头的instance method混为一谈了。所以这样理解就没问题了。\n\n\n# instantiation\n\n无参数的话，不用带parentheses\n\ntest test1;\n\ntest* test2 = new test;\n\n\n前者开在stack上，后者开在heap上。（java直接扔heap上不香吗\n\n\n# virtual function\n\n函数就有非虚函数，虚函数和纯虚函数这三种了，太草了。由于java的对象方法默认就是virtual的（jvm调用指令invokevirtual），然后java可以多态，要invoke的方法都是在runtime进行动态绑定的。所以c++里头的函数虚不虚，就很好理解了。\n\n比如java里头定义一个父类抽象方法的话，子类来实现。\n\n//father\npublic abstract void test();\n//son\n@override\npublic void test() {\n  /** do sth */\n}\n\n\nc++就要用到纯虚函数了\n\n//father\nvirtual void test() = 0;\n//son\nvirtual void test()\n{\n  /** do sth */\n}\n\n\n如果父类的虚函数想有自己的实现的话，把= 0去掉，加自己的实现即可（此时仍然有多态）。但此时的父类就不是抽象类了，可以被实例化。\n\nclass animal\n{\n    public:\n    virtual void eat()\n    {\n        std::cout << "i am eating food." << std::endl;\n    }\n};\n\nclass chicken : public animal\n{\n    public:\n    virtual void eat()\n    {\n        std::cout << "i am eating hay" << std::endl;\n    }\n};\n\n\n\n# override\n\n该关键字(c++11)可以防止写虚函数重载的时候，不小心写错的大无语事件发生。\n\nvirtual void eat() override;\n\n\n\n# modifier\n\n似乎因为没有jvav的package，所以这么几个modifier都没有了package access的restriction（因为根本没有package啊）。所以就很方便了。\n\npublic类的外部都能访问。\n\nprotected自己和派生类能访问。(！大不同！)\n\nprivate直接是私有，类里的能访问。\n\n\n# static keyword\n\n这个也没啥大区别的，唯一的小区别就是访问static的方法或变量需要使用operator ::\n\n还有，根据c++17前（艹）的标准。define的时候必须要在类外面进行(除非为const的时候才能在类内做定义)\n\n//class test\npublic:\n  static int i;\n\n// outside the class\nstatic int test::i = 114514;\n\n//main\ntest::i // 114514\n\n\n为什么要这样做呢？估计要等到了解csapp之后了（\n\nc++17及之后可以inline\n\ninline static int i = 114514;\n\n\n\n# friend keyword\n\n> the friend declaration appears in a class body and grants a function or another class access to private and protected members of the class where the friend declaration appears.\n\nclass test\n{\npublic:\n  friend void getnum(test test)\n  {\n    std::cout << test.num << std::endl;\n  }\nprivate:\n  int num = 114514;\n};\n\n// or\nfriend void getnum(test test);\n\n// outside of the class\nvoid getnum(test test)\n{\n  // implements here\n}\n\n\ntest test;\ngetnum(test); // 114514\n\n\n当然也可以在里头声明一个友元类，此时友元类里的成员函数都能访问到这个类的private field\n\n前提是有一个该类的对象，才能进行访问\n\n//in class test\nfriend class friend;\n\n//friend\nclass friend\n{\n  /** ... */\n  /** have the access to private field of test */\n}\n\n\n\n# inheritance\n\nclass chicken : public animal\n\n\n继承的话，要注意，c++继承的class默认是private的，（前期naive认知）所以（不一定）要加个public，否则外部无法使用父类的方法。（原来还能用scope qualifier艹）\n\n经查询继承类型有如下，比如上面的public animal就是公有继承了\n\n 1. 公有继承\n 2. 保护继承\n 3. 私有继承\n\n原理是将所继承的父类member的accessibility给降级...public->protected->private\n\n比如在保护继承和私有的继承的情况下，如果想改变某一个member的accessibility（比如原来是public或protected的，但是继承后降级），可以使用scope qualifier...(差不多得了)\n\nclass animal\n{\n    int i = 1141514;\npublic:\n    animal() = default;\n    void foo() {}\n};\n\nclass chicken : animal\n{\npublic:\n    animal::foo;\n};\n\nint main()\n{\n    chicken foo;\n    foo.foo();\n}\n\n\n\n# multiple inheritance\n\n主要是用来当interface用吧（c++的oop没有interface...\n\nclass foo : public basefoo, public basebar\n\n\n如果有命名冲突就用scope qualifier吧...\n\n然后还有歧义的问题，就是这样的\n\n#include <iostream>\n\nclass base\n{\npublic:\n  base() { std::cout << "base was constructed" << \'\\n\'; }\n  void test()\n  {\n    std::cout << "tested" << \'\\n\';\n  }\n};\n\nclass bar : public base\n{\npublic:\n  bar() { std::cout << "bar was constructed" << \'\\n\'; }\n};\n\nclass bar1 : public base\n{\npublic:\n  bar1() { std::cout << "bar1 was constructed" << \'\\n\'; }\n};\n\nclass foo : public bar, public bar1\n{\npublic:\n  foo() { std::cout << "foo was constructed" << \'\\n\'; }\n};\n\nint main()\n{\n  foo foo;\n}\n\n\n输出\n\nbase was constructed\nbar was constructed\nbase was constructed\nbar1 was constructed\nfoo was constructed\n\n\n如果main里加foo.test()会报错ambiguous access of \'test\'，因为每个bar类都分别有自己的一个父类对象。如下所示\n\nbase   base\n |      |\nbar    bar1\n   \\  /\n    foo\n\n\n为避免这个问题，我们使用虚继承（virtual inheritance）...\n\n把两个bar类的继承里的modifier加上关键字virtual，就会得到如下，两者继承到了同一个父类对象上。\n\nbase was constructed\nbar was constructed\nbar1 was constructed\nfoo was constructed\n\n\n此时的继承关系为\n\n   base\n  /   \\\nbar    bar1\n  \\   /\n   foo\n\n\n\n# constructors and member initializer lists\n\npublic:\n  chicken() : animal(arg)\n  {\n    /** do sth */\n  }\n\n\n相似地，我们也可以用来给field初始化\n\nprivate:\n  std::string text = nullptr;\npublic:\n  foo() : text("114514")\n  {\n    /** do sth */\n  }\n\n\n\n# constructor and destructor\n\n常见，语法也是差不多，但是后者析构这个就没见过了（gc擦屁股太香了\n\n类的析构和构造，都是默认缺省的（无参数），这点都一样，当然也可以自己写实现\n\n//class test\n~test()\n{\n  std::cout << "instance deleted";\n}\n\n\n出栈或者delete的时候会被隐式调用\n\n方法命名就这，直接是constructor前加 ~\n\n\n# copy constructor\n\n然后就是这个了，同上，这个东西也是默认缺省的，像这样，传的必须要是一个引用类型（不传引用？你可以想想套娃调用...）。\n\ntest::test(const point&)\n\n\n其中这个类型，可以cv-qualified，其中const主要是用来应对rvalue的（const t&和t&&都能被赋值一个临时对象），如果copy constructor的参数类型不加const那么这个就会报错\n\n// in a function body\nreturn obj;\n\n\n本来java中的引用变量之间的赋值就是把这个变量的值赋给你而已。但是c++直接给你弄了个了新对象。\n\n//main\ntest test;\ntest test1 = test; //invoke copy constructor\n\n\n调用默认拷贝构造函数的时候，一切栈上的变量都被拷过去了(这不就是跟struct一模一样吗)。但是当然要自己实现的时候，就不是这样了（要自己一个一个加实现）\n\ntest test;\ntest test1;\ntest1 = test; // this is operator overloading, not invoking copy constructor\n\n\n此外，函数返回一个对象，传参(一个对象)进去函数的时候，也会调用copy constructor\n\n\n# move constructor\n\nc++11开始加入了rvalue reference，这是什么呢，一查cpprefernce就能看到短小精悍的解释\n\n> rvalue references can be used to extend the lifetimes of temporary objects\n\n两个字来说就是续命\n\n还有std::move，类的构造器也有了移动构造函数\n\n//class foo\npublic:\n  foo(foo&& bar); \n\n\n初始化并赋值一个新对象的时候，可以使用move constructor\n\nfoo foo1;\nfoo foo2 = std::move(foo1);\n\n\n\n# pointer\n\n * this\n\nthis跟java一样，c++只有成员函数才有的。记得member access要用operator ->\n\n * pointer to an object\n\n这个java的引用变量是差不多的。声明也就这样\n\nclasstype* pointer;\n\n\n用法也就那样，如\n\ntest test1;\ntest* pointer = &test1;\n\ntest* test2 = new test;\n\n\n\n# function definition\n\n来自cpluscplus.com\n\n> the only difference between defining a class member function completely within its class or to include only the prototype and later its definition, is that in the first case the function will automatically be considered an inline member function by the compiler, while in the second it will be a normal (not-inline) class member function, which in fact supposes no difference in behavior\n\n\n# default and delete\n\n如果有带参的constructor，那么可以用=default来写默认constructor如test(){}。\n\n如果要禁用某个函数，可以上=delete\n\ntest() = default;\ntest(const x&) = delete;\ntest& operator=(const x&) = delete;\n\n//main\ntest test;\ntest test1 = test; //wrong!\ntest test2;\ntest2 = test3; //wrong!\n\n\n\n# operator overloading\n\n直接扔cppreference算了: 直达\n\n注意，一个重载运算符的函数，其operand必须有一个是枚举类型或者类类型。\n\n> when an operator appears in an expression, and at least one of its operands has a class type or an enumeration type\n\n其实返回值赋给谁的这个问题，我想了想，估计可以直接与基本类型的运算挂钩。结合一下操作符运算的本质特点就可以了！\n\n对应到方法呢？比如+是这样的，成员函数a.operator+(b)，非成员函数operator+(a, b)\n\n但是一些运算符是不能被重载为非成员函数的: =, (), [], ->\n\n有些运算符需要记录一下，代码扔到snippet里了\n\n\n# const keyword\n\n一般来说呢，const是作用于它左边的（如果左边啥都没有的话就是作用于右边）。而这个关键字const能作用于变量、成员函数、类对象...\n\n关键是有const修饰的，就不能修改里面成员的内存空间。\n\n如果有foo const foo;，那么这个对象变量（或指针）就不能访问非const方法，也不能修改成员了。如果有一个const方法，那么在这个方法体内，不能访问非const方法，也不能修改成员变量。（实质在后面说了）\n\n而我查了cppreference，里面这样说\n\n> const object - an object whose type is const-qualified, or a non-mutable subobject of a const object. such object cannot be modified: attempt to do so directly is a compile-time error, and attempt to do so indirectly (e.g., by modifying the const object through a reference or pointer to non-const type) results in undefined behavior.\n\n并且const了的函数实质又是？是这样的，其实就是把这个函数里头的*this给const掉了。\n\n> in the body of a cv-qualified function, *this is cv-qualified, e.g. in a const member function, only other const member functions may be called normally. (a non-const member function may still be called if const_cast is applied or through an access path that does not involve this.)\n\n\n# type casting\n\n面向so编程\n\n在oop里头一般用到的casting关键字，一般有static_cast, dynamic_cast, const_cast和reinterpret_cast和c风格cast）\n\n * static_cast是安全地，隐式地在类型之间进行转换(比如void, int, double, float)\n * dynamic_cast是在有继承关系的类之间的up cast, down cast and side cast（虽然上者也可以，但是上者对虚类down cast的支持不好）\n * const_cast可以对对象的指针或引用进行const约束的添加和删除\n * reinterpret_cast暴力casting，不管啥的\n\n一个例子\n\n#include <iostream>\n\nstruct base\n{\n  int a = 114514;\n};\n\nstruct d : public base\n{\n  int a = 1919810;\n};\n\nint main()\n{\n  d* d = new d;\n  std::cout << d->a << \'\\n\'; // 1919810\n  base* b = dynamic_cast<base*>(d); // upcast\n  std::cout << b->a; // 114514\n}\n',charsets:{cjk:!0}},{title:"Code snippet(C++)",frontmatter:{},regularPath:"/cpp/snippet.html",relativePath:"cpp/snippet.md",key:"v-d2af4fc2",path:"/cpp/snippet.html",headers:[{level:2,title:"Operator overloading",slug:"operator-overloading",normalizedTitle:"operator overloading",charIndex:90},{level:2,title:"Modern C++",slug:"modern-c",normalizedTitle:"modern c++",charIndex:2459}],headersStr:"Operator overloading Modern C++",content:'# Code snippet(C++)\n\nFor convenience of looking up, I collect some C++ code snippets.\n\n\n# Operator overloading\n\n(special case)\n\n#include <iostream>\n\nstruct Foo\n{\n    int value;\n\n    // operator +\n    Foo operator+(const Foo& b)\n    {\n        std::cout << "+ was called" << std::endl;\n        return Foo{ this->value + b.value };\n    }\n\n    // assignment operator\n    // must supply an argument\n    Foo& operator=(const Foo& other)\n    {\n        std::cout << "operator = was called";\n        this->value = other.value;\n        return *this;\n    }\n\n    // when you use increment operator next to the assignment\n    // the returning value will be used to assign to lhs\n    // But if you put prefix or postfix ++ alone, returning type does nothing\n\n    // postfix ++, note that the int value dose nothing here\n    Foo operator++(int)\n    {\n        Foo old = *this;\n        operator++();\n        std::cout << "foo++ was called" << std::endl;\n        return old;\n    }\n\n    // prefix ++\n    Foo& operator++()\n    {\n        this->value += 1;\n        // do some increment operation here\n        std::cout << "++foo was called" << std::endl;\n        return *this;\n    }\n\n    // also the += operator\n    Foo& operator+=(const Foo& rhs)\n    {\n        this->value += rhs.value;\n        // addition of rhs to *this takes place here\n        std::cout << "+= operator was called" << std::endl;\n        return *this;\n    }\n\n    // function operator()\n    int operator()(int other)\n    {\n        return value + other;\n    }\n    // [] and -> is just like the operator()\n};\n\n// Since << and >> take user-defined type as the right argument (b in a@b), they must be implemented as non-member\nstd::ostream& operator<<(std::ostream& os, Foo foo)\n{\n    std::cout << foo.value;\n    return os;\n}\n\n// a non-member operator > function\nbool operator>(const Foo& lhs, const Foo& rhs)\n{\n    return lhs.value > rhs.value;\n}\n\nint main()\n{\n    Foo foo = { 114 };\n    Foo bar = { 514 };\n\n    Foo test1 = foo + bar;\n    std::cout << test1 << std::endl;\n\n    Foo test2;\n    test2 = foo;\n    std::cout << test2 << std::endl;\n\n    std::cout << (foo++) << std::endl;\n    std::cout << (++foo) << std::endl;\n\n    foo += bar;\n    std::cout << foo << std::endl;\n\n    std::cout << (foo > bar) << std::endl;\n\n    std::cout << foo(400) << std::endl;\n}\n\n/* OUTPUT\n+ was called\n628\noperator = was called114\n++foo was called\nfoo++ was called\n114\n++foo was called\n116\n+= operator was called\n630\n1\n1030\n*/\n\n\n\n# Modern C++\n\nPart of the features since C++11.\n\n#include <iostream>\n#include <memory>\n#include <vector>\n\nint main()\n{\n    // keyword auto\n    {\n        auto v = std::vector<int>{ 1, 1, 4, 5, 1 };\n        v.push_back(4);\n        auto fn = [](auto v) -> void\n        {\n            for (auto e : v)\n            {\n                std::cout << e << " ";\n            }\n            std::cout << \'\\n\';\n        };\n        fn(v);\n    }\n\n    // Lambda expression\n    {\n        int a = 0;\n        auto fn = [&](int b) -> int // trailing return type\n        {\n            return a + b; // capture a\'s reference ([=] is copy)\n        };\n        std::cout << fn(114514) << \'\\n\';\n    }\n\n    // decltype: declared type\n    {\n        auto fn = [](int x) { return x * x; };\n        decltype(fn) fn1 = fn;\n        std::cout << fn1(11) << \'\\n\';\n    }\n\n    // std::move and rvalue reference\n    {\n        std::string str1 = "1919810";\n        std::string str2 = std::move(str1);\n        std::cout << str1 << "\\n" << str2 << "\\n";\n        // what is rvalue reference\n        // definition: Rvalue references can be used to extend the lifetimes of temporary objects\n        int&& i = 1; // capture a temporary object, it will be destroyed when the stack is removed\n        auto fn = [](int&& o) { return o + 1; };\n        std::cout << fn(std::move(i)) << \'\\n\';\n    }\n\n    // type_traits\n    {\n        // it can be used to compare two objects\' type，\n        using T = int; // type alias\n        typedef std::int64_t U; // keyword typedef\n        auto predicate = std::is_same<T, U>::value;\n        std::cout << predicate << \'\\n\';\n    }\n\n    // initializer list (or list initialization list)\n    {\n        auto l = { 114, 514, 191, 9810 };\n        std::vector v(l); // can be used to initialize a vector\n        for (auto e : l) // enhanced for loop\n        {\n            std::cout << e << \'\\n\';\n        }\n    }\n\n    // smart pointer owns and manages the object\n    {\n        auto l = { 114, 514 };\n        auto v = std::vector<int>(l);\n        auto p = std::make_unique<decltype(v)>(std::move(v));\n        p->push_back(1919810);\n        for (auto& e : *p)\n        {\n            std::cout << e << \' \';\n        }\n        std::cout << std::endl;\n    }\n}\n',normalizedContent:'# code snippet(c++)\n\nfor convenience of looking up, i collect some c++ code snippets.\n\n\n# operator overloading\n\n(special case)\n\n#include <iostream>\n\nstruct foo\n{\n    int value;\n\n    // operator +\n    foo operator+(const foo& b)\n    {\n        std::cout << "+ was called" << std::endl;\n        return foo{ this->value + b.value };\n    }\n\n    // assignment operator\n    // must supply an argument\n    foo& operator=(const foo& other)\n    {\n        std::cout << "operator = was called";\n        this->value = other.value;\n        return *this;\n    }\n\n    // when you use increment operator next to the assignment\n    // the returning value will be used to assign to lhs\n    // but if you put prefix or postfix ++ alone, returning type does nothing\n\n    // postfix ++, note that the int value dose nothing here\n    foo operator++(int)\n    {\n        foo old = *this;\n        operator++();\n        std::cout << "foo++ was called" << std::endl;\n        return old;\n    }\n\n    // prefix ++\n    foo& operator++()\n    {\n        this->value += 1;\n        // do some increment operation here\n        std::cout << "++foo was called" << std::endl;\n        return *this;\n    }\n\n    // also the += operator\n    foo& operator+=(const foo& rhs)\n    {\n        this->value += rhs.value;\n        // addition of rhs to *this takes place here\n        std::cout << "+= operator was called" << std::endl;\n        return *this;\n    }\n\n    // function operator()\n    int operator()(int other)\n    {\n        return value + other;\n    }\n    // [] and -> is just like the operator()\n};\n\n// since << and >> take user-defined type as the right argument (b in a@b), they must be implemented as non-member\nstd::ostream& operator<<(std::ostream& os, foo foo)\n{\n    std::cout << foo.value;\n    return os;\n}\n\n// a non-member operator > function\nbool operator>(const foo& lhs, const foo& rhs)\n{\n    return lhs.value > rhs.value;\n}\n\nint main()\n{\n    foo foo = { 114 };\n    foo bar = { 514 };\n\n    foo test1 = foo + bar;\n    std::cout << test1 << std::endl;\n\n    foo test2;\n    test2 = foo;\n    std::cout << test2 << std::endl;\n\n    std::cout << (foo++) << std::endl;\n    std::cout << (++foo) << std::endl;\n\n    foo += bar;\n    std::cout << foo << std::endl;\n\n    std::cout << (foo > bar) << std::endl;\n\n    std::cout << foo(400) << std::endl;\n}\n\n/* output\n+ was called\n628\noperator = was called114\n++foo was called\nfoo++ was called\n114\n++foo was called\n116\n+= operator was called\n630\n1\n1030\n*/\n\n\n\n# modern c++\n\npart of the features since c++11.\n\n#include <iostream>\n#include <memory>\n#include <vector>\n\nint main()\n{\n    // keyword auto\n    {\n        auto v = std::vector<int>{ 1, 1, 4, 5, 1 };\n        v.push_back(4);\n        auto fn = [](auto v) -> void\n        {\n            for (auto e : v)\n            {\n                std::cout << e << " ";\n            }\n            std::cout << \'\\n\';\n        };\n        fn(v);\n    }\n\n    // lambda expression\n    {\n        int a = 0;\n        auto fn = [&](int b) -> int // trailing return type\n        {\n            return a + b; // capture a\'s reference ([=] is copy)\n        };\n        std::cout << fn(114514) << \'\\n\';\n    }\n\n    // decltype: declared type\n    {\n        auto fn = [](int x) { return x * x; };\n        decltype(fn) fn1 = fn;\n        std::cout << fn1(11) << \'\\n\';\n    }\n\n    // std::move and rvalue reference\n    {\n        std::string str1 = "1919810";\n        std::string str2 = std::move(str1);\n        std::cout << str1 << "\\n" << str2 << "\\n";\n        // what is rvalue reference\n        // definition: rvalue references can be used to extend the lifetimes of temporary objects\n        int&& i = 1; // capture a temporary object, it will be destroyed when the stack is removed\n        auto fn = [](int&& o) { return o + 1; };\n        std::cout << fn(std::move(i)) << \'\\n\';\n    }\n\n    // type_traits\n    {\n        // it can be used to compare two objects\' type，\n        using t = int; // type alias\n        typedef std::int64_t u; // keyword typedef\n        auto predicate = std::is_same<t, u>::value;\n        std::cout << predicate << \'\\n\';\n    }\n\n    // initializer list (or list initialization list)\n    {\n        auto l = { 114, 514, 191, 9810 };\n        std::vector v(l); // can be used to initialize a vector\n        for (auto e : l) // enhanced for loop\n        {\n            std::cout << e << \'\\n\';\n        }\n    }\n\n    // smart pointer owns and manages the object\n    {\n        auto l = { 114, 514 };\n        auto v = std::vector<int>(l);\n        auto p = std::make_unique<decltype(v)>(std::move(v));\n        p->push_back(1919810);\n        for (auto& e : *p)\n        {\n            std::cout << e << \' \';\n        }\n        std::cout << std::endl;\n    }\n}\n',charsets:{}},{title:"Problems(C/C++)",frontmatter:{},regularPath:"/cpp/problems.html",relativePath:"cpp/problems.md",key:"v-369d602a",path:"/cpp/problems.html",headers:[{level:2,title:"static keyword",slug:"static-keyword",normalizedTitle:"static keyword",charIndex:45},{level:2,title:"define vs typedef vs using",slug:"define-vs-typedef-vs-using",normalizedTitle:"define vs typedef vs using",charIndex:65},{level:2,title:"extern keyword",slug:"extern-keyword",normalizedTitle:"extern keyword",charIndex:97},{level:2,title:"只能重载为成员函数的运算符",slug:"只能重载为成员函数的运算符",normalizedTitle:"只能重载为成员函数的运算符",charIndex:117},{level:2,title:"Pointer to function",slug:"pointer-to-function",normalizedTitle:"pointer to function",charIndex:136}],headersStr:"static keyword define vs typedef vs using extern keyword 只能重载为成员函数的运算符 Pointer to function",content:'# Problems(C/C++)\n\n\n\n * Problems(C/C++)\n   * static keyword\n   * define vs typedef vs using\n   * extern keyword\n   * 只能重载为成员函数的运算符\n   * Pointer to function\n\n\n\n\n# static keyword\n\nHow does the keyword static works?\n\n其实一般就是用来遮掩隐藏的，因为用了static关键字的变量，它的作用域就不再是全局了，即使他被存于全局变量区域。然后另外一个就是静态地躺在了全局变量区里头，只被初始化一次。\n\n\n# define vs typedef vs using\n\n如果都是用来做type alias的话，就是这样（不过define还是别滥用\n\n#define T std::int64_t\nusing T = std::int64_t;\ntypedef std::int64_t T;\n\n\ntypedef 为什么顺序有点不一样呢，可以直接想想C风格的struct\n\ntypedef struct \n{\n    int foo;\n    int bar;\n} S;\n\n\n\n# extern keyword\n\n来自SO问题\n\n> A best way to declare and define global variables\n\n摘自原文的答案部分\n\nThe header is included by the one source file that defines the variable and by all the source files that reference the variable. For each program, one source file (and only one source file) defines the variable. Similarly, one header file (and only one header file) should declare the variable. The header file is crucial; it enables cross-checking between independent TUs (translation units — think source files) and ensures consistency.\n\n * file3.h\n\nextern int global_variable;  /* Declaration of the variable */\n\n\n * file1.c\n\n#include "file3.h"  /* Declaration made available here */\n#include "prog1.h"  /* Function declarations */\n\n/* Variable defined here */\nint global_variable = 37;    /* Definition checked against declaration */\n\nint increment(void) { return global_variable++; }\n\n\n * file2.c\n\n#include "file3.h"\n#include "prog1.h"\n#include <stdio.h>\n\nvoid use_it(void)\n{\n    printf("Global variable: %d\\n", global_variable++);\n}\n\n\n一些源码，electron里面的electron_constants.cc与electron_constants.h\n\n// electron_constants.h\nnamespace electron {\n    // The app-command in NativeWindow.\n    extern const char kBrowserForward[];\n    extern const char kBrowserBackward[];\n    // ...\n}\n\n// electron_constants.cc\n#include "shell/common/electron_constants.h"\n\nnamespace electron {\n    const char kBrowserForward[] = "browser-forward";\n    const char kBrowserBackward[] = "browser-backward";\n    // ...\n}\n\n\n\n# 只能重载为成员函数的运算符\n\n答案来源: StackOverflow\n\n摘抄原文如下，可能是为了一些情况的考虑，所以就禁止重载为非成员函数\n\n>  1. The assignment operator=(). Allowing non-member assignments seems to open the door for operators hijacking assignments, e.g., by overloading for different versions of const qualifications. Given that assignment operators are rather fundamental that seems to be undesirable.\n> \n>  2. The function call operator()(). The function call and overloading rules are sufficiently complicated as is. It seems ill-advised to complicate the rules further by allowing non-member function call operators.\n> \n>  3. The subscript operator[](). Using interesting index types it seems that could interfere with accesses to operators. Although there is little danger of hijacking overloads, there doesn\'t seem to be much gain but interesting potential to write highly non-obvious code.\n> \n>  4. The class member access operator->(). Off-hand I can\'t see any bad abuse of overloading this operator a non-member. On the other hand, I also can\'t see any. Also, the class member access operator has rather special rules and playing with potential overloads interfering with these seems an unnecessary complication.\n\n\n# Pointer to function\n\nvoid test()\n{\n    std::cout << "This is function test" << \'\\n\';\n}\n\n// main\ntypedef void (*f)(void);\nf fn = test;\n// or\nvoid (*func)(void) = test;\nfn(); // This is function test\n\n\n注意使用括号改变优先级...不然void* f(void)就是一个返回void*类型的函数了。来点茴香豆吧（\n\nint (*a[])() is a array of function pointer of the prototype int func()\n\nint (*f())[] is a function that returns a pointer to array\n\n但不允许有array of function\n\n来个复杂的，其实无非就是标识符被定义成了指针、数组、还是函数而已。\n\nint* const * (*f)(double)中，f是一个指向一个返回指向只读int*的指针的函数的指针，其实英语解释起来不是很拗口。\n\na function pointer that points to a function with prototype int* const * func(double) where its returning value is a pointer points to a read-only pointer-to-int',normalizedContent:'# problems(c/c++)\n\n\n\n * problems(c/c++)\n   * static keyword\n   * define vs typedef vs using\n   * extern keyword\n   * 只能重载为成员函数的运算符\n   * pointer to function\n\n\n\n\n# static keyword\n\nhow does the keyword static works?\n\n其实一般就是用来遮掩隐藏的，因为用了static关键字的变量，它的作用域就不再是全局了，即使他被存于全局变量区域。然后另外一个就是静态地躺在了全局变量区里头，只被初始化一次。\n\n\n# define vs typedef vs using\n\n如果都是用来做type alias的话，就是这样（不过define还是别滥用\n\n#define t std::int64_t\nusing t = std::int64_t;\ntypedef std::int64_t t;\n\n\ntypedef 为什么顺序有点不一样呢，可以直接想想c风格的struct\n\ntypedef struct \n{\n    int foo;\n    int bar;\n} s;\n\n\n\n# extern keyword\n\n来自so问题\n\n> a best way to declare and define global variables\n\n摘自原文的答案部分\n\nthe header is included by the one source file that defines the variable and by all the source files that reference the variable. for each program, one source file (and only one source file) defines the variable. similarly, one header file (and only one header file) should declare the variable. the header file is crucial; it enables cross-checking between independent tus (translation units — think source files) and ensures consistency.\n\n * file3.h\n\nextern int global_variable;  /* declaration of the variable */\n\n\n * file1.c\n\n#include "file3.h"  /* declaration made available here */\n#include "prog1.h"  /* function declarations */\n\n/* variable defined here */\nint global_variable = 37;    /* definition checked against declaration */\n\nint increment(void) { return global_variable++; }\n\n\n * file2.c\n\n#include "file3.h"\n#include "prog1.h"\n#include <stdio.h>\n\nvoid use_it(void)\n{\n    printf("global variable: %d\\n", global_variable++);\n}\n\n\n一些源码，electron里面的electron_constants.cc与electron_constants.h\n\n// electron_constants.h\nnamespace electron {\n    // the app-command in nativewindow.\n    extern const char kbrowserforward[];\n    extern const char kbrowserbackward[];\n    // ...\n}\n\n// electron_constants.cc\n#include "shell/common/electron_constants.h"\n\nnamespace electron {\n    const char kbrowserforward[] = "browser-forward";\n    const char kbrowserbackward[] = "browser-backward";\n    // ...\n}\n\n\n\n# 只能重载为成员函数的运算符\n\n答案来源: stackoverflow\n\n摘抄原文如下，可能是为了一些情况的考虑，所以就禁止重载为非成员函数\n\n>  1. the assignment operator=(). allowing non-member assignments seems to open the door for operators hijacking assignments, e.g., by overloading for different versions of const qualifications. given that assignment operators are rather fundamental that seems to be undesirable.\n> \n>  2. the function call operator()(). the function call and overloading rules are sufficiently complicated as is. it seems ill-advised to complicate the rules further by allowing non-member function call operators.\n> \n>  3. the subscript operator[](). using interesting index types it seems that could interfere with accesses to operators. although there is little danger of hijacking overloads, there doesn\'t seem to be much gain but interesting potential to write highly non-obvious code.\n> \n>  4. the class member access operator->(). off-hand i can\'t see any bad abuse of overloading this operator a non-member. on the other hand, i also can\'t see any. also, the class member access operator has rather special rules and playing with potential overloads interfering with these seems an unnecessary complication.\n\n\n# pointer to function\n\nvoid test()\n{\n    std::cout << "this is function test" << \'\\n\';\n}\n\n// main\ntypedef void (*f)(void);\nf fn = test;\n// or\nvoid (*func)(void) = test;\nfn(); // this is function test\n\n\n注意使用括号改变优先级...不然void* f(void)就是一个返回void*类型的函数了。来点茴香豆吧（\n\nint (*a[])() is a array of function pointer of the prototype int func()\n\nint (*f())[] is a function that returns a pointer to array\n\n但不允许有array of function\n\n来个复杂的，其实无非就是标识符被定义成了指针、数组、还是函数而已。\n\nint* const * (*f)(double)中，f是一个指向一个返回指向只读int*的指针的函数的指针，其实英语解释起来不是很拗口。\n\na function pointer that points to a function with prototype int* const * func(double) where its returning value is a pointer points to a read-only pointer-to-int',charsets:{cjk:!0}},{title:"Naming rules",frontmatter:{},regularPath:"/cpp/rules_naming.html",relativePath:"cpp/rules_naming.md",key:"v-d221e09a",path:"/cpp/rules_naming.html",headers:[{level:2,title:"Generic",slug:"generic",normalizedTitle:"generic",charIndex:44},{level:2,title:"Rules",slug:"rules",normalizedTitle:"rules",charIndex:873},{level:3,title:"Header file",slug:"header-file",normalizedTitle:"header file",charIndex:883},{level:3,title:"Type name",slug:"type-name",normalizedTitle:"type name",charIndex:1116},{level:3,title:"Function name",slug:"function-name",normalizedTitle:"function name",charIndex:1531},{level:3,title:"Const and Enumerate",slug:"const-and-enumerate",normalizedTitle:"const and enumerate",charIndex:1608},{level:3,title:"non-member variable and struct variable",slug:"non-member-variable-and-struct-variable",normalizedTitle:"non-member variable and struct variable",charIndex:1729},{level:3,title:"Member variable",slug:"member-variable",normalizedTitle:"member variable",charIndex:1896}],headersStr:"Generic Rules Header file Type name Function name Const and Enumerate non-member variable and struct variable Member variable",content:"# Naming rules\n\nA good repo: StyleGuide\n\n\n# Generic\n\n> Use names that describe the purpose or intent of the object. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Minimize the use of abbreviations that would likely be unknown to someone outside your project (especially acronyms and initialisms). Do not abbreviate by deleting letters within a word. As a rule of thumb, an abbreviation is probably OK if it's listed in Wikipedia. Generally speaking, descriptiveness should be proportional to the name's scope of visibility. For example, n may be a fine name within a 5-line function, but within the scope of a class, it's likely too vague.\n\n总之就是说，不要为了节省字母而节省字母，一个好的命名要做到describe the purpose or intent of the object即是描述好对象的意图。适度的缩写(abbreviation)可以，但是这个缩写是要人人皆知的，比如可以在Google或维基百科上面找到。\n\n\n# Rules\n\n\n# Header file\n\n空格可以使用dash(-)或者underscore(_)代替，也可以直接忽略空格和横杠和下划线，比如这些都是合法的。但要注意不要与/usr/include里面的重名。\n\n * my_useful_class.cc\n * my-useful-class.cc\n * myusefulclass.cc\n * myusefulclass_test.cc // _unittest and _regtest are deprecated.\n\n\n# Type name\n\n这个规则适用于class, enum, struct, type alias, type template parameter ：每个单词的首字母都要大写，不要加下划线或横杠。\n\n// classes and structs\nclass UrlTable { ...\nclass UrlTableTester { ...\nstruct UrlTableProperties { ...\n\n// typedefs\ntypedef hash_map<UrlTableProperties *, std::string> PropertiesMap;\n\n// using aliases\nusing PropertiesMap = hash_map<UrlTableProperties *, std::string>;\n\n// enums\nenum class UrlTableError { ...\n\n\n\n# Function name\n\n同class的命名规则\n\nAddTableEntry()\nDeleteUrl()\nOpenFileOrDie()\n\n\n\n# Const and Enumerate\n\n用k开头，并且命名方式是驼峰命名法\n\nconst int kDaysInAWeek = 7;\nconst int kAndroid8_0_0 = 24;  // Android 8.0.0\n\n\n\n# non-member variable and struct variable\n\n全部小写，空格用下划线代替\n\nstd::string table_name;  // OK - lowercase with underscore.\nstd::string tableName;   // Bad - mixed case.\n\n\n\n# Member variable\n\n与非成员变量一样的，只不过是在trailing位加一个underscore\n\nclass TableInfo {\n  ...\n private:\n  std::string table_name_;  // OK - underscore at end.\n  static Pool<TableInfo>* pool_;  // OK.\n};\n",normalizedContent:"# naming rules\n\na good repo: styleguide\n\n\n# generic\n\n> use names that describe the purpose or intent of the object. do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. minimize the use of abbreviations that would likely be unknown to someone outside your project (especially acronyms and initialisms). do not abbreviate by deleting letters within a word. as a rule of thumb, an abbreviation is probably ok if it's listed in wikipedia. generally speaking, descriptiveness should be proportional to the name's scope of visibility. for example, n may be a fine name within a 5-line function, but within the scope of a class, it's likely too vague.\n\n总之就是说，不要为了节省字母而节省字母，一个好的命名要做到describe the purpose or intent of the object即是描述好对象的意图。适度的缩写(abbreviation)可以，但是这个缩写是要人人皆知的，比如可以在google或维基百科上面找到。\n\n\n# rules\n\n\n# header file\n\n空格可以使用dash(-)或者underscore(_)代替，也可以直接忽略空格和横杠和下划线，比如这些都是合法的。但要注意不要与/usr/include里面的重名。\n\n * my_useful_class.cc\n * my-useful-class.cc\n * myusefulclass.cc\n * myusefulclass_test.cc // _unittest and _regtest are deprecated.\n\n\n# type name\n\n这个规则适用于class, enum, struct, type alias, type template parameter ：每个单词的首字母都要大写，不要加下划线或横杠。\n\n// classes and structs\nclass urltable { ...\nclass urltabletester { ...\nstruct urltableproperties { ...\n\n// typedefs\ntypedef hash_map<urltableproperties *, std::string> propertiesmap;\n\n// using aliases\nusing propertiesmap = hash_map<urltableproperties *, std::string>;\n\n// enums\nenum class urltableerror { ...\n\n\n\n# function name\n\n同class的命名规则\n\naddtableentry()\ndeleteurl()\nopenfileordie()\n\n\n\n# const and enumerate\n\n用k开头，并且命名方式是驼峰命名法\n\nconst int kdaysinaweek = 7;\nconst int kandroid8_0_0 = 24;  // android 8.0.0\n\n\n\n# non-member variable and struct variable\n\n全部小写，空格用下划线代替\n\nstd::string table_name;  // ok - lowercase with underscore.\nstd::string tablename;   // bad - mixed case.\n\n\n\n# member variable\n\n与非成员变量一样的，只不过是在trailing位加一个underscore\n\nclass tableinfo {\n  ...\n private:\n  std::string table_name_;  // ok - underscore at end.\n  static pool<tableinfo>* pool_;  // ok.\n};\n",charsets:{cjk:!0}},{title:"Keywords",frontmatter:{},regularPath:"/cpp/keywords.html",relativePath:"cpp/keywords.md",key:"v-1c221902",path:"/cpp/keywords.html",headersStr:null,content:"# Keywords\n\nsome keywords in C++...",normalizedContent:"# keywords\n\nsome keywords in c++...",charsets:{}},{title:"Header(C/C++)",frontmatter:{},regularPath:"/cpp/header.html",relativePath:"cpp/header.md",key:"v-654b2ab9",path:"/cpp/header.html",headers:[{level:2,title:"include",slug:"include",normalizedTitle:"include",charIndex:135}],headersStr:"include",content:'# Header(C/C++)\n\nC/C++可以在头文件里面做function, namespace, class, global variable和struct的声明，并在对应的cpp文件里面将它们给实现掉。\n\n即是将声明和实现分开到了.h和.cpp文件里面\n\n\n# include\n\n#include <xxx>与#include "xxx.h"，都相当于是把头文件里的东西粘到了现有的代码里头。嗯，顾名思义，就是include的字面意思\n\n比如说，我有一个foo.h和foo.cpp\n\n// foo.h\nnamespace foo\n{\n    extern int x;\n    extern const int kx;\n}\n// foo.cpp\ninclude "Foo.h"\n\nnamespace foo\n{\n    extern int x = 9;\n    extern const int kx = 114514;\n}\n\n\n那么用g++ -E foo.cpp -o foo.ii预编译一下foo.cpp，输出来的预编译文件foo.ii是这样的\n\n# 1 "Foo.cpp"\n# 1 "<built-in>"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "Foo.cpp"\n# 1 "Foo.h" 1\n       \n\nnamespace foo\n{\n extern int x;\n extern const int kx;\n}\n# 2 "Foo.cpp" 2\n\nnamespace foo\n{\n extern int x = 9;\n extern const int kx = 114514;\n}\n',normalizedContent:'# header(c/c++)\n\nc/c++可以在头文件里面做function, namespace, class, global variable和struct的声明，并在对应的cpp文件里面将它们给实现掉。\n\n即是将声明和实现分开到了.h和.cpp文件里面\n\n\n# include\n\n#include <xxx>与#include "xxx.h"，都相当于是把头文件里的东西粘到了现有的代码里头。嗯，顾名思义，就是include的字面意思\n\n比如说，我有一个foo.h和foo.cpp\n\n// foo.h\nnamespace foo\n{\n    extern int x;\n    extern const int kx;\n}\n// foo.cpp\ninclude "foo.h"\n\nnamespace foo\n{\n    extern int x = 9;\n    extern const int kx = 114514;\n}\n\n\n那么用g++ -e foo.cpp -o foo.ii预编译一下foo.cpp，输出来的预编译文件foo.ii是这样的\n\n# 1 "foo.cpp"\n# 1 "<built-in>"\n# 1 "<command-line>"\n# 1 "/usr/include/stdc-predef.h" 1 3 4\n# 1 "<command-line>" 2\n# 1 "foo.cpp"\n# 1 "foo.h" 1\n       \n\nnamespace foo\n{\n extern int x;\n extern const int kx;\n}\n# 2 "foo.cpp" 2\n\nnamespace foo\n{\n extern int x = 9;\n extern const int kx = 114514;\n}\n',charsets:{cjk:!0}},{title:"frameworks",frontmatter:{},regularPath:"/frameworks/",relativePath:"frameworks/README.md",key:"v-9c284b9c",path:"/frameworks/",headersStr:null,content:"# frameworks\n\n记录一下一些框架的essence和usage",normalizedContent:"# frameworks\n\n记录一下一些框架的essence和usage",charsets:{cjk:!0}},{title:"Approaches",frontmatter:{},regularPath:"/dsa/approach.html",relativePath:"dsa/approach.md",key:"v-355bdaa1",path:"/dsa/approach.html",headers:[{level:2,title:"Dynamic Programming",slug:"dynamic-programming",normalizedTitle:"dynamic programming",charIndex:17},{level:2,title:"Divide-and-Conquer",slug:"divide-and-conquer",normalizedTitle:"divide-and-conquer",charIndex:2091},{level:2,title:"Backtracking",slug:"backtracking",normalizedTitle:"backtracking",charIndex:2963}],headersStr:"Dynamic Programming Divide-and-Conquer Backtracking",content:'# Approaches\n\n\n# Dynamic Programming\n\n> Dynamic programming is the process of solving subproblems, then combining the solutions of the subproblems to obtain an overall solution.\n\n\n\nKey idea: 把子问题解决后存下结果，并在后面其余子问题的解决时使用这些结果。以避免对overlap的子问题的反复计算\n\n比如斐波拉契数列，可以用递归f(n)=f(n−1)+f(n−2)f(n)=f(n-1)+f(n-2)f(n)=f(n−1)+f(n−2)\n\n也可以用DP，记录下前面子问题的结果，解决后面的子问题的时候就用前面记录的结果\n\npublic static long fib(long n) {\n    long f0 = 0;\n    long f1 = 1;\n    long f2 = 1;\n\n    if (n == 0)\n        return f0;\n    else if (n == 1)\n        return f1;\n    else if (n == 2)\n        return f2;\n\n    for (long i = 3; i <= n; i++) {\n        f0 = f1;\n        f1 = f2;\n        f2 = f0 + f1;\n    }\n\n    return f2;\n}\n\n\n----------------------------------------\n\n又比如判断一个数是否为质数，除了一个个暴力取余数去找，也可以使用DP，利用之前存着的算出来的结果，来做后面的判断。\n\n原理主要是，如果有一个数iii，满足i=pqi=pqi=pq，其中p≤qp\\leq qp≤q且ppp为质数，那么iii就不是一个质数。这个ppp必须为质数，如果不是质数，那么就会有一个比ppp更小的质数满足条件（ppp不是质数的话，就可以被分解质因数）\n\npublic class EfficientPrimeNumbers {\n    public static void main(String[] args) {\n        final int NUMBER_PER_LINE = 10;\n        int current = 2;\n        int squareRoot = 1;\n        int count = 0;\n        List<Integer> list = new ArrayList<>();\n\n        int to;\n        try (Scanner input = new Scanner(System.in)) {\n            System.out.print("From 2 to ?: ");\n            to = input.nextInt();\n        }\n\n        while (current <= to) {\n            if (squareRoot * squareRoot < current) squareRoot++;\n\n            boolean isPrime = true;\n            for (int i = 0; i < list.size() && list.get(i) <= squareRoot; i++) {\n                if (current % list.get(i) == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n\n            if (isPrime) {\n                list.add(current);\n                count++;\n                System.out.printf("%10d", current);\n                if (count % NUMBER_PER_LINE == 0) {\n                    System.out.println();\n                }\n            }\n\n            current++;\n        }\n\n        System.out.println("\\nThere are " + count + " prime number(s) in the range from 2 to " + to);\n    }\n}\n\n\n\n# Divide-and-Conquer\n\n> The divide-and-conquer approach divides the problems into subproblems, solves the subproblems, and then combines the solutions of the subproblems to obtain the solution for the entire problem.\n\n这个叫做分治法。其中用到了递归(用于切割问题?)，但是分治并不会导致redundant的计算(重复计算如递归法计算斐波拉契数列)。\n\n\n\n简单地例子，使用这个来算出数组里头的最小数。\n\npublic class Example {\n    private static int min(int[] arr, int low, int high) {\n        if (high == low) {\n            return arr[low];\n        }\n        if (high - low == 1) {\n            return Math.min(arr[low], arr[high]);\n        }\n\n        int mid = (low + high) / 2;\n        int minL = min(arr, low, mid);\n        int minR = min(arr, mid + 1, high);\n\n        return Math.min(minL, minR);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {19, 1, 9, 8, 10};\n        System.out.println(min(arr, 0, arr.length - 1)); // 1\n    }\n}\n\n\n\n# Backtracking\n\n> The backtracking approach searches for a candidate solution incrementally, abandoning the option as soon as it determines the candidate cannot possibly be a valid solution, then looks for a new candidate.\n\n回溯法，记录好当前的步，向前进一步做尝试，如果不行就往回退，寻找下一个可能。\n\n\n\n比如常见的有八皇后问题\n\nimport java.util.Arrays;\n\npublic class EightQueenBacktracking {\n    final static int SIZE = 8;\n    final static int[] queen = new int[SIZE];\n\n    public static void main(String[] args) {\n        Arrays.fill(queen, -1);\n        if (search()) {\n            System.out.println(Arrays.toString(queen));\n        }\n    }\n\n    private static boolean search() {\n        int row = 0;\n        while (row >= 0 && row < SIZE) {\n            int find = find(row);\n            if (find < 0) {\n                queen[row] = -1;\n                row--;\n            } else {\n                queen[row] = find;\n                row++;\n            }\n        }\n\n        return row != -1;\n    }\n\n    private static int find(int row) {\n        // memorization\n        for (int i = queen[row] + 1; i < SIZE; i++) {\n            if (isValid(row, i)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean isValid(int row, int col) {\n        // traverse the array to check the problem\n        for (int i = 0; i < row; i++) {\n            // the same column, up-left and up-right from current queen\n            if (queen[i] == col || queen[i] == col - (row - i) || queen[i] == col + (row - i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n如图所示\n\n',normalizedContent:'# approaches\n\n\n# dynamic programming\n\n> dynamic programming is the process of solving subproblems, then combining the solutions of the subproblems to obtain an overall solution.\n\n\n\nkey idea: 把子问题解决后存下结果，并在后面其余子问题的解决时使用这些结果。以避免对overlap的子问题的反复计算\n\n比如斐波拉契数列，可以用递归f(n)=f(n−1)+f(n−2)f(n)=f(n-1)+f(n-2)f(n)=f(n−1)+f(n−2)\n\n也可以用dp，记录下前面子问题的结果，解决后面的子问题的时候就用前面记录的结果\n\npublic static long fib(long n) {\n    long f0 = 0;\n    long f1 = 1;\n    long f2 = 1;\n\n    if (n == 0)\n        return f0;\n    else if (n == 1)\n        return f1;\n    else if (n == 2)\n        return f2;\n\n    for (long i = 3; i <= n; i++) {\n        f0 = f1;\n        f1 = f2;\n        f2 = f0 + f1;\n    }\n\n    return f2;\n}\n\n\n----------------------------------------\n\n又比如判断一个数是否为质数，除了一个个暴力取余数去找，也可以使用dp，利用之前存着的算出来的结果，来做后面的判断。\n\n原理主要是，如果有一个数iii，满足i=pqi=pqi=pq，其中p≤qp\\leq qp≤q且ppp为质数，那么iii就不是一个质数。这个ppp必须为质数，如果不是质数，那么就会有一个比ppp更小的质数满足条件（ppp不是质数的话，就可以被分解质因数）\n\npublic class efficientprimenumbers {\n    public static void main(string[] args) {\n        final int number_per_line = 10;\n        int current = 2;\n        int squareroot = 1;\n        int count = 0;\n        list<integer> list = new arraylist<>();\n\n        int to;\n        try (scanner input = new scanner(system.in)) {\n            system.out.print("from 2 to ?: ");\n            to = input.nextint();\n        }\n\n        while (current <= to) {\n            if (squareroot * squareroot < current) squareroot++;\n\n            boolean isprime = true;\n            for (int i = 0; i < list.size() && list.get(i) <= squareroot; i++) {\n                if (current % list.get(i) == 0) {\n                    isprime = false;\n                    break;\n                }\n            }\n\n            if (isprime) {\n                list.add(current);\n                count++;\n                system.out.printf("%10d", current);\n                if (count % number_per_line == 0) {\n                    system.out.println();\n                }\n            }\n\n            current++;\n        }\n\n        system.out.println("\\nthere are " + count + " prime number(s) in the range from 2 to " + to);\n    }\n}\n\n\n\n# divide-and-conquer\n\n> the divide-and-conquer approach divides the problems into subproblems, solves the subproblems, and then combines the solutions of the subproblems to obtain the solution for the entire problem.\n\n这个叫做分治法。其中用到了递归(用于切割问题?)，但是分治并不会导致redundant的计算(重复计算如递归法计算斐波拉契数列)。\n\n\n\n简单地例子，使用这个来算出数组里头的最小数。\n\npublic class example {\n    private static int min(int[] arr, int low, int high) {\n        if (high == low) {\n            return arr[low];\n        }\n        if (high - low == 1) {\n            return math.min(arr[low], arr[high]);\n        }\n\n        int mid = (low + high) / 2;\n        int minl = min(arr, low, mid);\n        int minr = min(arr, mid + 1, high);\n\n        return math.min(minl, minr);\n    }\n\n    public static void main(string[] args) {\n        int[] arr = {19, 1, 9, 8, 10};\n        system.out.println(min(arr, 0, arr.length - 1)); // 1\n    }\n}\n\n\n\n# backtracking\n\n> the backtracking approach searches for a candidate solution incrementally, abandoning the option as soon as it determines the candidate cannot possibly be a valid solution, then looks for a new candidate.\n\n回溯法，记录好当前的步，向前进一步做尝试，如果不行就往回退，寻找下一个可能。\n\n\n\n比如常见的有八皇后问题\n\nimport java.util.arrays;\n\npublic class eightqueenbacktracking {\n    final static int size = 8;\n    final static int[] queen = new int[size];\n\n    public static void main(string[] args) {\n        arrays.fill(queen, -1);\n        if (search()) {\n            system.out.println(arrays.tostring(queen));\n        }\n    }\n\n    private static boolean search() {\n        int row = 0;\n        while (row >= 0 && row < size) {\n            int find = find(row);\n            if (find < 0) {\n                queen[row] = -1;\n                row--;\n            } else {\n                queen[row] = find;\n                row++;\n            }\n        }\n\n        return row != -1;\n    }\n\n    private static int find(int row) {\n        // memorization\n        for (int i = queen[row] + 1; i < size; i++) {\n            if (isvalid(row, i)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean isvalid(int row, int col) {\n        // traverse the array to check the problem\n        for (int i = 0; i < row; i++) {\n            // the same column, up-left and up-right from current queen\n            if (queen[i] == col || queen[i] == col - (row - i) || queen[i] == col + (row - i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n如图所示\n\n',charsets:{cjk:!0}},{title:"Electron",frontmatter:{},regularPath:"/frameworks/electron.html",relativePath:"frameworks/electron.md",key:"v-5ee63579",path:"/frameworks/electron.html",headers:[{level:2,title:"Essence",slug:"essence",normalizedTitle:"essence",charIndex:15}],headersStr:"Essence",content:"# Electron\n\n\n# Essence\n\n使用前端三大件来写跨平台的桌面应用。框架本身包括了三大部分 -- Chromium, nodejs和与native OS沟通的API\n\n> Build cross-platform desktop apps with JavaScript, HTML, and CSS\n\nElectron consists of three main pillars:\n\n * Chromium for displaying web content.\n * Node.js for working with the local filesystem and the operating system.\n * Custom APIs for working with often-needed OS native functions.",normalizedContent:"# electron\n\n\n# essence\n\n使用前端三大件来写跨平台的桌面应用。框架本身包括了三大部分 -- chromium, nodejs和与native os沟通的api\n\n> build cross-platform desktop apps with javascript, html, and css\n\nelectron consists of three main pillars:\n\n * chromium for displaying web content.\n * node.js for working with the local filesystem and the operating system.\n * custom apis for working with often-needed os native functions.",charsets:{cjk:!0}},{title:"基础储备",frontmatter:{},regularPath:"/dsa/basis.html",relativePath:"dsa/basis.md",key:"v-25bb32df",path:"/dsa/basis.html",headers:[{level:2,title:"Big O Notion",slug:"big-o-notion",normalizedTitle:"big o notion",charIndex:23},{level:2,title:"Complexity",slug:"complexity",normalizedTitle:"complexity",charIndex:41},{level:2,title:"Loop flow",slug:"loop-flow",normalizedTitle:"loop flow",charIndex:57},{level:2,title:"Determining Big O",slug:"determining-big-o",normalizedTitle:"determining big o",charIndex:72},{level:2,title:"Recurrence relation",slug:"recurrence-relation",normalizedTitle:"recurrence relation",charIndex:95}],headersStr:"Big O Notion Complexity Loop flow Determining Big O Recurrence relation",content:'# 基础储备\n\n\n\n * 基础储备\n   * Big O Notion\n   * Complexity\n   * Loop flow\n   * Determining Big O\n   * Recurrence relation\n\n\n\n\n# Big O Notion\n\n大O表示法可以用来表示时间复杂度和空间复杂度\n\nBig O means "order of magnitude"(数量级)\n\n> The big O notion estimates the execution time of an algorithm in relation to input size.\n\n即程序执行时间与输入规模的关系，表示算法的时间复杂度。\n\n比如从n个元素的数组中逐个地搜索一个元素，最坏的情况就是需要耗时n，而搜索2n个元素的话最坏情况是耗时2n。可以看出，随着输入规模线性增长，执行时间也呈现线性增长。因此复杂度是O(n)O(n)O(n)。\n\n这个算法的输入规模nnn和执行时间f(n)f(n)f(n)的关系如下表格，很容易得出f(n)=nf(n)=nf(n)=n。\n\n对比运行时间与输入规模之间的关系，就能得出大O了。\n\n下表也体现了，执行次数的多少（f(n)=n,f(n)=n/2,f(n)=100nf(n)=n,f(n)=n/2,f(n)=100nf(n)=n,f(n)=n/2,f(n)=100n）并不会影响执行时间的增长率。所以一般来说，算出最坏情况下的执行时间与输入规模关系的表达式，剃掉系数。用O(n)O(n)O(n)表示就行了\n\n\n\n常时间--如果一个算法的执行时间不随着输入规模的变化而变化，那么就是constant time。即O(1)O(1)O(1)\n\n忽略关系中的非主要的部分--比如T(n)=n3+2n+1T(n)=n^3+2n+1T(n)=n3+2n+1，这个时间复杂度就是O(n3)O(n^3)O(n3)\n\n> 举例T(n)=n3+nT(n)=n^3+nT(n)=n3+n：当n -> 100n时，变化主要是由n3n^3n3贡献的，而低次的nnn对变化的贡献可以忽略不计。时间复杂度就是O(n3)O(n^3)O(n3)\n\n计算大O的时候，常用的是最坏情况或平均情况。\n\n除此之外，大O表示法还可以用来表示空间复杂度\n\n\n# Complexity\n\nT(n)T(n)T(n)的不同，就有了不同的复杂度，把不同的函数T(n)T(n)T(n)画在同一个坐标轴上，如下\n\n\n\n增长的快慢有如下\n\nO(1)<O(logn)<O(n)<O(nlogn)<O(n2)<(O3)<O(2n)O(1)<O(logn)<O(n)<O(n logn)<O(n^2)<(O^3)<O(2^n) O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<(O3)<O(2n)\n\n\n# Loop flow\n\n虽然不知道发生了什么，但是还有人不知道while和for的关系？\n\n其实for loop可以说，是从while loop那里来的而已。while是基本。\n\nfor (int i = 0; i < n; i++) {\n    // do sth\n}\n\n\n等效于\n\nint i = 0;\nwhile (i < n) {\n    // do sth\n    i++;\n}\n\n\n然后do-while只是while中的判断语句的执行位置改变，导致loop body里的语句必被至少执行一次而已。（执行次数大于1的话，此时do-while与while就是完全一致了）\n\n得把它们的control flow贴上来，循环次数可不能错掉啊\n\n * while loop\n\n\n\n * do-while loop\n\n\n\n * for loop\n\n\n\n\n# Determining Big O\n\n可以使用上面的知识来确定大O，比较好训练的操作就是分析循环了。\n\n简的来说就是：算出T(n)T(n)T(n)的表达式\n\nfor (int i = 1; i <= n; i++) {\n    k = k + 5;\n}\n\n\n这是一个简单的循环。首先，执行k = k + 5耗时固定，是constant time，记作ccc，因此，每执行一次耗时ccc。\n\n又因为这个循环执行n次，所以得出输入规模与执行时间的函数表达式为\n\nT(n)=c∗n=O(n)T(n)=c*n=O(n) T(n)=c∗n=O(n)\n\nfor (int i = 1; i <= n; i++) {\n    for (int i = 1; i <= n; i++) {\n        k = k + 5;\n    }\n}\n\n\n一个简单的nest-loop。由上面的分析，很容易得到。\n\nT(n)=c∗n∗n=O(n2)T(n)=c*n*n=O(n^2) T(n)=c∗n∗n=O(n2)\n\nfor (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= i; j++) {\n        k += 5;\n    }\n}\n\n\n同样是一个嵌套循环，只不过里面的循环结束条件变了，随着i的变化而变化。此时照样可以分析得到\n\nT(n)=c∗(1+2+3+...+n)=c∗n(n+1)2=O(n2)T(n)=c*(1+2+3+...+n)=c*\\frac{n(n+1)}{2}=O(n^2) T(n)=c∗(1+2+3+...+n)=c∗2n(n+1) =O(n2)\n\nif (list.contains(e)) {\n    System.out.println(e);\n} else {\n    for (var e : list) {\n        System.out.println(e);\n    }\n}\n\n\n上面是一个条件判断的代码块，此时时间复杂度的计算就是：计算if做判断所需的时间，加上两个分支中的最最坏情况所需的时间。\n\nT(n)=if test time + worst-case time(if clause, else clause)\n\nT(n)=O(n)+O(n)=O(n)T(n)=O(n)+O(n)=O(n) T(n)=O(n)+O(n)=O(n)\n\nlong result = 1;\nfor (int i = 1; i <= n; i++) {\n    result *= a;\n}\n// or\nlong result = a;\nfor (int i = 1; i <= k; i++) {\n    result = result * result;\n}\n\n\n计算一个指数运算ana^nan的结果有两种操作。\n\n前者要跑nnn次result *= a，即2∗2∗2∗...∗22*2*2*...*22∗2∗2∗...∗2。后者只需要跑log2nlog_{2}nlog2 n次result = result * result，即((2n)n)n...)n((2^n)^n)^n...)^n((2n)n)n...)n\n\nN(IN ANA^NAN)   方法1的T(N)T(N)T(N)   方法2的T(N)T(N)T(N)\n1               1                  0\n2               2                  1\n4               4                  2\n8               8                  3\n16              16                 4\n32              32                 5\n...             ...                ...\nnnn             nnn                log2nlog_{2}nlog2 n\n\n由表格，前者的时间复杂度就是O(n)O(n)O(n)，后者的是O(logn)O(log n)O(logn)，这个就是对数时间复杂度了。\n\n\n# Recurrence relation\n\n递推关系式，形如f(x)=f(x−1)+f(x−2)f(x)=f(x-1)+f(x-2)f(x)=f(x−1)+f(x−2)这样的表达式\n\n举个例子，选择排序\n\nprivate static void sort(int[] array) {\n    for (int i = 0; i < array.length - 1; i++) {\n        int currentMin = array[i];\n        int currentMinIndex = i;\n\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[j] < currentMin) {\n                currentMin = array[j];\n                currentMinIndex = j;\n            }\n        }\n\n        if (currentMin != array[i]) {\n            array[currentMinIndex] = array[i];\n            array[i] = currentMin;\n        }\n    }\n}\n\n\n容易看出：让第n个元素与后面的元素比较的用时，第一次是n-1次比较，第二次就是n-2次...还有赋值交换的用时c\n\nT(n)=k(n−1)+c+k(n−2)+c+...+k+cT(n)=k(n-1)+c+k(n-2)+c+...+k+c T(n)=k(n−1)+c+k(n−2)+c+...+k+c\n\n=k(n−1)n2+c(n−1)=k\\frac{(n-1)n}{2}+c(n-1) =k2(n−1)n +c(n−1)\n\n=k(n22−n2)+cn−c=k(\\frac{n^2}{2}-\\frac{n}{2})+cn-c =k(2n2 −2n )+cn−c\n\n=O(n2)=O(n^2) =O(n2)\n\n上面选择排序的应该是\n\nT(n)=T(n−1)+k(n−1)+c,n≥1T(n)=T(n-1)+k(n-1)+c,n\\geq 1 T(n)=T(n−1)+k(n−1)+c,n≥1\n\n其中除了函数外多出来的那一坨k(n−1)+ck(n-1)+ck(n−1)+c，就是用大O表示的那部分了，此处的表示为O(n)O(n)O(n)，如下\n\nT(n)=T(n−1)+O(n),n≥1T(n)=T(n-1)+O(n),n\\geq 1 T(n)=T(n−1)+O(n),n≥1\n\n一些常见的递推关系式的形式如下\n\n',normalizedContent:'# 基础储备\n\n\n\n * 基础储备\n   * big o notion\n   * complexity\n   * loop flow\n   * determining big o\n   * recurrence relation\n\n\n\n\n# big o notion\n\n大o表示法可以用来表示时间复杂度和空间复杂度\n\nbig o means "order of magnitude"(数量级)\n\n> the big o notion estimates the execution time of an algorithm in relation to input size.\n\n即程序执行时间与输入规模的关系，表示算法的时间复杂度。\n\n比如从n个元素的数组中逐个地搜索一个元素，最坏的情况就是需要耗时n，而搜索2n个元素的话最坏情况是耗时2n。可以看出，随着输入规模线性增长，执行时间也呈现线性增长。因此复杂度是o(n)o(n)o(n)。\n\n这个算法的输入规模nnn和执行时间f(n)f(n)f(n)的关系如下表格，很容易得出f(n)=nf(n)=nf(n)=n。\n\n对比运行时间与输入规模之间的关系，就能得出大o了。\n\n下表也体现了，执行次数的多少（f(n)=n,f(n)=n/2,f(n)=100nf(n)=n,f(n)=n/2,f(n)=100nf(n)=n,f(n)=n/2,f(n)=100n）并不会影响执行时间的增长率。所以一般来说，算出最坏情况下的执行时间与输入规模关系的表达式，剃掉系数。用o(n)o(n)o(n)表示就行了\n\n\n\n常时间--如果一个算法的执行时间不随着输入规模的变化而变化，那么就是constant time。即o(1)o(1)o(1)\n\n忽略关系中的非主要的部分--比如t(n)=n3+2n+1t(n)=n^3+2n+1t(n)=n3+2n+1，这个时间复杂度就是o(n3)o(n^3)o(n3)\n\n> 举例t(n)=n3+nt(n)=n^3+nt(n)=n3+n：当n -> 100n时，变化主要是由n3n^3n3贡献的，而低次的nnn对变化的贡献可以忽略不计。时间复杂度就是o(n3)o(n^3)o(n3)\n\n计算大o的时候，常用的是最坏情况或平均情况。\n\n除此之外，大o表示法还可以用来表示空间复杂度\n\n\n# complexity\n\nt(n)t(n)t(n)的不同，就有了不同的复杂度，把不同的函数t(n)t(n)t(n)画在同一个坐标轴上，如下\n\n\n\n增长的快慢有如下\n\no(1)<o(logn)<o(n)<o(nlogn)<o(n2)<(o3)<o(2n)o(1)<o(logn)<o(n)<o(n logn)<o(n^2)<(o^3)<o(2^n) o(1)<o(logn)<o(n)<o(nlogn)<o(n2)<(o3)<o(2n)\n\n\n# loop flow\n\n虽然不知道发生了什么，但是还有人不知道while和for的关系？\n\n其实for loop可以说，是从while loop那里来的而已。while是基本。\n\nfor (int i = 0; i < n; i++) {\n    // do sth\n}\n\n\n等效于\n\nint i = 0;\nwhile (i < n) {\n    // do sth\n    i++;\n}\n\n\n然后do-while只是while中的判断语句的执行位置改变，导致loop body里的语句必被至少执行一次而已。（执行次数大于1的话，此时do-while与while就是完全一致了）\n\n得把它们的control flow贴上来，循环次数可不能错掉啊\n\n * while loop\n\n\n\n * do-while loop\n\n\n\n * for loop\n\n\n\n\n# determining big o\n\n可以使用上面的知识来确定大o，比较好训练的操作就是分析循环了。\n\n简的来说就是：算出t(n)t(n)t(n)的表达式\n\nfor (int i = 1; i <= n; i++) {\n    k = k + 5;\n}\n\n\n这是一个简单的循环。首先，执行k = k + 5耗时固定，是constant time，记作ccc，因此，每执行一次耗时ccc。\n\n又因为这个循环执行n次，所以得出输入规模与执行时间的函数表达式为\n\nt(n)=c∗n=o(n)t(n)=c*n=o(n) t(n)=c∗n=o(n)\n\nfor (int i = 1; i <= n; i++) {\n    for (int i = 1; i <= n; i++) {\n        k = k + 5;\n    }\n}\n\n\n一个简单的nest-loop。由上面的分析，很容易得到。\n\nt(n)=c∗n∗n=o(n2)t(n)=c*n*n=o(n^2) t(n)=c∗n∗n=o(n2)\n\nfor (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= i; j++) {\n        k += 5;\n    }\n}\n\n\n同样是一个嵌套循环，只不过里面的循环结束条件变了，随着i的变化而变化。此时照样可以分析得到\n\nt(n)=c∗(1+2+3+...+n)=c∗n(n+1)2=o(n2)t(n)=c*(1+2+3+...+n)=c*\\frac{n(n+1)}{2}=o(n^2) t(n)=c∗(1+2+3+...+n)=c∗2n(n+1) =o(n2)\n\nif (list.contains(e)) {\n    system.out.println(e);\n} else {\n    for (var e : list) {\n        system.out.println(e);\n    }\n}\n\n\n上面是一个条件判断的代码块，此时时间复杂度的计算就是：计算if做判断所需的时间，加上两个分支中的最最坏情况所需的时间。\n\nt(n)=if test time + worst-case time(if clause, else clause)\n\nt(n)=o(n)+o(n)=o(n)t(n)=o(n)+o(n)=o(n) t(n)=o(n)+o(n)=o(n)\n\nlong result = 1;\nfor (int i = 1; i <= n; i++) {\n    result *= a;\n}\n// or\nlong result = a;\nfor (int i = 1; i <= k; i++) {\n    result = result * result;\n}\n\n\n计算一个指数运算ana^nan的结果有两种操作。\n\n前者要跑nnn次result *= a，即2∗2∗2∗...∗22*2*2*...*22∗2∗2∗...∗2。后者只需要跑log2nlog_{2}nlog2 n次result = result * result，即((2n)n)n...)n((2^n)^n)^n...)^n((2n)n)n...)n\n\nn(in ana^nan)   方法1的t(n)t(n)t(n)   方法2的t(n)t(n)t(n)\n1               1                  0\n2               2                  1\n4               4                  2\n8               8                  3\n16              16                 4\n32              32                 5\n...             ...                ...\nnnn             nnn                log2nlog_{2}nlog2 n\n\n由表格，前者的时间复杂度就是o(n)o(n)o(n)，后者的是o(logn)o(log n)o(logn)，这个就是对数时间复杂度了。\n\n\n# recurrence relation\n\n递推关系式，形如f(x)=f(x−1)+f(x−2)f(x)=f(x-1)+f(x-2)f(x)=f(x−1)+f(x−2)这样的表达式\n\n举个例子，选择排序\n\nprivate static void sort(int[] array) {\n    for (int i = 0; i < array.length - 1; i++) {\n        int currentmin = array[i];\n        int currentminindex = i;\n\n        for (int j = i + 1; j < array.length; j++) {\n            if (array[j] < currentmin) {\n                currentmin = array[j];\n                currentminindex = j;\n            }\n        }\n\n        if (currentmin != array[i]) {\n            array[currentminindex] = array[i];\n            array[i] = currentmin;\n        }\n    }\n}\n\n\n容易看出：让第n个元素与后面的元素比较的用时，第一次是n-1次比较，第二次就是n-2次...还有赋值交换的用时c\n\nt(n)=k(n−1)+c+k(n−2)+c+...+k+ct(n)=k(n-1)+c+k(n-2)+c+...+k+c t(n)=k(n−1)+c+k(n−2)+c+...+k+c\n\n=k(n−1)n2+c(n−1)=k\\frac{(n-1)n}{2}+c(n-1) =k2(n−1)n +c(n−1)\n\n=k(n22−n2)+cn−c=k(\\frac{n^2}{2}-\\frac{n}{2})+cn-c =k(2n2 −2n )+cn−c\n\n=o(n2)=o(n^2) =o(n2)\n\n上面选择排序的应该是\n\nt(n)=t(n−1)+k(n−1)+c,n≥1t(n)=t(n-1)+k(n-1)+c,n\\geq 1 t(n)=t(n−1)+k(n−1)+c,n≥1\n\n其中除了函数外多出来的那一坨k(n−1)+ck(n-1)+ck(n−1)+c，就是用大o表示的那部分了，此处的表示为o(n)o(n)o(n)，如下\n\nt(n)=t(n−1)+o(n),n≥1t(n)=t(n-1)+o(n),n\\geq 1 t(n)=t(n−1)+o(n),n≥1\n\n一些常见的递推关系式的形式如下\n\n',charsets:{cjk:!0}},{title:"TensorFlow",frontmatter:{},regularPath:"/frameworks/tensorflow.html",relativePath:"frameworks/tensorflow.md",key:"v-58b38159",path:"/frameworks/tensorflow.html",headers:[{level:2,title:"取名",slug:"取名",normalizedTitle:"取名",charIndex:17}],headersStr:"取名",content:"# TensorFlow\n\n\n# 取名\n\nQ: 为什么取名为TensorFlow?\n\nA: 摘自Wiki，这个名字其实就是直接反映了这工具的工作实质--对高维数组进行操作，而高维数组又被称之为张量，即tensor，对张量(高维数组)的一条龙操作，也就成为了流，即flow\n\n> The name TensorFlow derives from the operations that such neural networks perform on multidimensional data arrays, which are referred to as tensors.\n\ntf对图片的操作，实质上就是对数组进行操作。\n\n----------------------------------------",normalizedContent:"# tensorflow\n\n\n# 取名\n\nq: 为什么取名为tensorflow?\n\na: 摘自wiki，这个名字其实就是直接反映了这工具的工作实质--对高维数组进行操作，而高维数组又被称之为张量，即tensor，对张量(高维数组)的一条龙操作，也就成为了流，即flow\n\n> the name tensorflow derives from the operations that such neural networks perform on multidimensional data arrays, which are referred to as tensors.\n\ntf对图片的操作，实质上就是对数组进行操作。\n\n----------------------------------------",charsets:{cjk:!0}},{title:"CORS",frontmatter:{},regularPath:"/http/cors.html",relativePath:"http/cors.md",key:"v-5f71c739",path:"/http/cors.html",headersStr:null,content:"# CORS\n\n全称为Cross-Origin Resource Sharing，即跨域资源共享",normalizedContent:"# cors\n\n全称为cross-origin resource sharing，即跨域资源共享",charsets:{cjk:!0}},{title:"导航页 Java",frontmatter:{},regularPath:"/java/",relativePath:"java/README.md",key:"v-2b53d5dc",path:"/java/",headersStr:null,content:"# 导航页 Java\n\n一个成熟、稳重、啰嗦的语言",normalizedContent:"# 导航页 java\n\n一个成熟、稳重、啰嗦的语言",charsets:{cjk:!0}},{title:"Basis",frontmatter:{},regularPath:"/java/basis.html",relativePath:"java/basis.md",key:"v-4d1fb77a",path:"/java/basis.html",headers:[{level:2,title:"Method Overloading",slug:"method-overloading",normalizedTitle:"method overloading",charIndex:25},{level:2,title:"Varargs",slug:"varargs",normalizedTitle:"varargs",charIndex:49},{level:2,title:"Generic Erasing",slug:"generic-erasing",normalizedTitle:"generic erasing",charIndex:62},{level:2,title:"MethodHandle",slug:"methodhandle",normalizedTitle:"methodhandle",charIndex:83},{level:2,title:"Union Type",slug:"union-type",normalizedTitle:"union type",charIndex:101},{level:2,title:"Intersection Type",slug:"intersection-type",normalizedTitle:"intersection type",charIndex:117},{level:2,title:"Enums",slug:"enums",normalizedTitle:"enums",charIndex:140}],headersStr:"Method Overloading Varargs Generic Erasing MethodHandle Union Type Intersection Type Enums",content:'# Basis\n\n\n\n * Basis\n   * Method Overloading\n   * Varargs\n   * Generic Erasing\n   * MethodHandle\n   * Union Type\n   * Intersection Type\n   * Enums\n\n\n\n\n# Method Overloading\n\n(嘿呀这是最naive的)我一直以为是同名同返回类型不同参...\n\n其实正确的是，只需要同名不同参。如下\n\n * Both must have the same method name.\n * Both must have different argument lists.\n\n\n# Varargs\n\n当有一个方法不是很确定参数的个数的时候，就可以使用可变参数了，其实在Java里头，可变参数的实质就是一个长度可变的数组。syntax如下\n\npublic void foo(Object foo, String... bars)\n\n\n比如说我们把可变参数里的元素全部print出来\n\nimport java.util.Arrays;\n\npublic class Example {\n    private static void foo(String description, int... args) {\n        System.out.println(Arrays.toString(args)); // [1, 9, 1, 9, 8, 1, 0]\n        System.out.println("Description: " + description); // Description: dssq\n\n        for (var e : args) {\n            System.out.print(e);\n        } // 1919810\n    }\n\n    public static void main(String[] args) {\n        foo("dssq", 1, 9, 1, 9, 8, 1, 0);\n    }\n}\n\n\n那么为什么不用数组做参数？区别请见下\n\nfoo(1, 9, 1, 9, 8, 1, 0);\nfoo(new int[]{1, 9, 1, 9, 8, 1, 0});\n\n\n自带API里头的一个好例子，就是String.format这个方法啦\n\npublic static String format​(String format, Object... args)\n// For example, invoke it with parameter("%s, %s", "foo", "bar")\n\n\n\n# Generic Erasing\n\n编译为字节码时compiler会将type parameter给擦除，即把type parameter给替换为实际的类型，擦除是如下这样的。\n\n当编译class, interface和method时，就会根据type parameter来进行擦除。\n\n当type parameter为unbound的时候，就会擦除为Object类型，比如\n\npublic static <T> void foo(T[] elements)\n\n\n被擦除为\n\npublic static void foo(Object[] elements)\n\n\nbounded的即像<T extends Number>的话，就是擦除为父类类型。\n\n而当编译上面这些之外的code的话，就会是像下面这样进行擦除，以确保类型安全\n\n> Insert type casts if necessary to preserve type safety.\n\n比如有这个东西\n\nList<String> list = new ArrayList<>();\nlist.add("dssq");\nString str = list.get(0);\n\n\n编译时候就会被擦除为(类似的)\n\nList list = new ArrayList();\nlist.add("dssq");\nString str = (String)(list.get(0));\n\n\n\n# MethodHandle\n\n> A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values. These transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution.\n\npublic class Test {\n    public static void main(String[] args) throws Throwable {\n        MethodType methodType;\n        MethodHandle methodHandle;\n        MethodHandles.Lookup lookup = MethodHandles.lookup();\n        methodType = MethodType.methodType(String.class, char.class, char.class);\n        System.out.println(methodType); // (char,char)String\n        methodHandle = lookup.findVirtual(String.class, "replace", methodType);\n\n        String s = (String) methodHandle.invokeExact("hello", \'h\', \'y\');\n        System.out.println(s); // yello\n    }\n}\n\n\n从中可以知道，原来方法的签名是这样子的。\n\n(待更)\n\n\n# Union Type\n\n使用Bitwise-OR运算符，即|，一般是用于try-catch block里面的exception catching。比如我们从文件反序列化对象的时候，可能会同时出现两个exception: IOException和ClassNotFoundException，所以这个时候，Union Type就有用了。\n\n就像是这样，下面是一个try-catch block\n\npublic class Test {\n    public static void main(String[] args) {\n        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("obj.dat"))) {\n            Object obj = in.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n# Intersection Type\n\n使用Bitwise-AND运算符，即&，可以用于generic中的wild card和对lambda表达式的casting，格式为A & B，A B指的是类或接口类型，比如Object & Runnable\n\n * 泛型\n\n比如<T extends Object & Serializable>。代码见下\n\npublic class Test {\n    static class Foo {\n\n    }\n\n    interface Bar {\n\n    }\n\n    static class MyClass extends Foo implements Bar {\n\n    }\n\n\n    private static <T extends Foo & Bar> void test(T t) {\n\n    }\n\n    public static void main(String[] args) {\n        test(new MyClass());\n    }\n}\n\n\n * Lambda casting\n\n可以直接把Lambda表达式的类型给cast一下，可以得到有实现了一个接口的匿名类的这么一个效果\n\npublic class Test {\n    public static void main(String[] args) {\n        Runnable task = (Runnable & Serializable) () -> System.out.println("Test");\n        Class<?> clz = task.getClass();\n        for (var e : clz.getInterfaces()) {\n            System.out.println(e);\n        }\n    }\n}\n\n/** OUTPUT\ninterface java.lang.Runnable\ninterface java.io.Serializable\n*/\n\n\n\n# Enums\n\n枚举类型(Enumerated Type)，代码结构跟class是差不多的，这玩意也是一个class，其实就是把class关键字改成enum而已。\n\n自带name()和ordinate()，且extends Object implements Comparable，所以有compareTo()和Object自带的方法\n\n枚举类里面的元素，可以看成是一个已经实例化了的该类型的constant。带参就ELEMENT(param)不带就ELEMENT\n\npackage appendixH;\n\npublic enum TrafficLight {\n    RED("Please stop"), GREEN("Please go"),\n    YELLOW("Please caution");\n\n    private final String description;\n\n    private TrafficLight(String description) {\n        this.description = description;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n}\n\nclass TestTrafficLight {\n    public static void main(String[] args) {\n        TrafficLight light = TrafficLight.GREEN;\n        System.out.println(light.getDescription());\n        System.out.println(light.name());\n        System.out.println(light.ordinal());\n    }\n}\n',normalizedContent:'# basis\n\n\n\n * basis\n   * method overloading\n   * varargs\n   * generic erasing\n   * methodhandle\n   * union type\n   * intersection type\n   * enums\n\n\n\n\n# method overloading\n\n(嘿呀这是最naive的)我一直以为是同名同返回类型不同参...\n\n其实正确的是，只需要同名不同参。如下\n\n * both must have the same method name.\n * both must have different argument lists.\n\n\n# varargs\n\n当有一个方法不是很确定参数的个数的时候，就可以使用可变参数了，其实在java里头，可变参数的实质就是一个长度可变的数组。syntax如下\n\npublic void foo(object foo, string... bars)\n\n\n比如说我们把可变参数里的元素全部print出来\n\nimport java.util.arrays;\n\npublic class example {\n    private static void foo(string description, int... args) {\n        system.out.println(arrays.tostring(args)); // [1, 9, 1, 9, 8, 1, 0]\n        system.out.println("description: " + description); // description: dssq\n\n        for (var e : args) {\n            system.out.print(e);\n        } // 1919810\n    }\n\n    public static void main(string[] args) {\n        foo("dssq", 1, 9, 1, 9, 8, 1, 0);\n    }\n}\n\n\n那么为什么不用数组做参数？区别请见下\n\nfoo(1, 9, 1, 9, 8, 1, 0);\nfoo(new int[]{1, 9, 1, 9, 8, 1, 0});\n\n\n自带api里头的一个好例子，就是string.format这个方法啦\n\npublic static string format​(string format, object... args)\n// for example, invoke it with parameter("%s, %s", "foo", "bar")\n\n\n\n# generic erasing\n\n编译为字节码时compiler会将type parameter给擦除，即把type parameter给替换为实际的类型，擦除是如下这样的。\n\n当编译class, interface和method时，就会根据type parameter来进行擦除。\n\n当type parameter为unbound的时候，就会擦除为object类型，比如\n\npublic static <t> void foo(t[] elements)\n\n\n被擦除为\n\npublic static void foo(object[] elements)\n\n\nbounded的即像<t extends number>的话，就是擦除为父类类型。\n\n而当编译上面这些之外的code的话，就会是像下面这样进行擦除，以确保类型安全\n\n> insert type casts if necessary to preserve type safety.\n\n比如有这个东西\n\nlist<string> list = new arraylist<>();\nlist.add("dssq");\nstring str = list.get(0);\n\n\n编译时候就会被擦除为(类似的)\n\nlist list = new arraylist();\nlist.add("dssq");\nstring str = (string)(list.get(0));\n\n\n\n# methodhandle\n\n> a method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values. these transformations are quite general, and include such patterns as conversion, insertion, deletion, and substitution.\n\npublic class test {\n    public static void main(string[] args) throws throwable {\n        methodtype methodtype;\n        methodhandle methodhandle;\n        methodhandles.lookup lookup = methodhandles.lookup();\n        methodtype = methodtype.methodtype(string.class, char.class, char.class);\n        system.out.println(methodtype); // (char,char)string\n        methodhandle = lookup.findvirtual(string.class, "replace", methodtype);\n\n        string s = (string) methodhandle.invokeexact("hello", \'h\', \'y\');\n        system.out.println(s); // yello\n    }\n}\n\n\n从中可以知道，原来方法的签名是这样子的。\n\n(待更)\n\n\n# union type\n\n使用bitwise-or运算符，即|，一般是用于try-catch block里面的exception catching。比如我们从文件反序列化对象的时候，可能会同时出现两个exception: ioexception和classnotfoundexception，所以这个时候，union type就有用了。\n\n就像是这样，下面是一个try-catch block\n\npublic class test {\n    public static void main(string[] args) {\n        try (objectinputstream in = new objectinputstream(new fileinputstream("obj.dat"))) {\n            object obj = in.readobject();\n        } catch (ioexception | classnotfoundexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n\n# intersection type\n\n使用bitwise-and运算符，即&，可以用于generic中的wild card和对lambda表达式的casting，格式为a & b，a b指的是类或接口类型，比如object & runnable\n\n * 泛型\n\n比如<t extends object & serializable>。代码见下\n\npublic class test {\n    static class foo {\n\n    }\n\n    interface bar {\n\n    }\n\n    static class myclass extends foo implements bar {\n\n    }\n\n\n    private static <t extends foo & bar> void test(t t) {\n\n    }\n\n    public static void main(string[] args) {\n        test(new myclass());\n    }\n}\n\n\n * lambda casting\n\n可以直接把lambda表达式的类型给cast一下，可以得到有实现了一个接口的匿名类的这么一个效果\n\npublic class test {\n    public static void main(string[] args) {\n        runnable task = (runnable & serializable) () -> system.out.println("test");\n        class<?> clz = task.getclass();\n        for (var e : clz.getinterfaces()) {\n            system.out.println(e);\n        }\n    }\n}\n\n/** output\ninterface java.lang.runnable\ninterface java.io.serializable\n*/\n\n\n\n# enums\n\n枚举类型(enumerated type)，代码结构跟class是差不多的，这玩意也是一个class，其实就是把class关键字改成enum而已。\n\n自带name()和ordinate()，且extends object implements comparable，所以有compareto()和object自带的方法\n\n枚举类里面的元素，可以看成是一个已经实例化了的该类型的constant。带参就element(param)不带就element\n\npackage appendixh;\n\npublic enum trafficlight {\n    red("please stop"), green("please go"),\n    yellow("please caution");\n\n    private final string description;\n\n    private trafficlight(string description) {\n        this.description = description;\n    }\n\n    public string getdescription() {\n        return description;\n    }\n}\n\nclass testtrafficlight {\n    public static void main(string[] args) {\n        trafficlight light = trafficlight.green;\n        system.out.println(light.getdescription());\n        system.out.println(light.name());\n        system.out.println(light.ordinal());\n    }\n}\n',charsets:{cjk:!0}},{title:"gitignore",frontmatter:{},regularPath:"/git/gitignore.html",relativePath:"git/gitignore.md",key:"v-8cfa76c2",path:"/git/gitignore.html",headers:[{level:2,title:"Patterns",slug:"patterns",normalizedTitle:"patterns",charIndex:55}],headersStr:"Patterns",content:"# gitignore\n\ngit-scm docs\n\n用于忽略一些指定的untracked file\n\n\n# Patterns\n\n * separator(/)\n\n只要分隔符/出现在开头或者(和)中间，就会出现相对目录的关系，是相对于本.gitignore文件的(前面/不/都没有问题的)\n\n出现在最后的话，这个pattern仅能match到目录，而不能match同名的文件\n\n * asterisk(*)\n\n通配，match除了slash(/)之外的所有东东，也就是说只能match本层目录里的文件和文件夹\n\n * token ?\n\nmatch一个字符\n\n * range\n\n匹配一个在[a-zA-z]内的字符，有regex的味道了\n\n * asterisk(**)\n\nleading：表示每个目录里头match的东西比如**/foo/bar表示匹配每个目录里面的foo/bar\n\ntrailing: 表示在某目录里头所有的文件比如bar/**\n\ncenter: 表示目录通配比如foo/**/bar，可以是foo/114/514/bar",normalizedContent:"# gitignore\n\ngit-scm docs\n\n用于忽略一些指定的untracked file\n\n\n# patterns\n\n * separator(/)\n\n只要分隔符/出现在开头或者(和)中间，就会出现相对目录的关系，是相对于本.gitignore文件的(前面/不/都没有问题的)\n\n出现在最后的话，这个pattern仅能match到目录，而不能match同名的文件\n\n * asterisk(*)\n\n通配，match除了slash(/)之外的所有东东，也就是说只能match本层目录里的文件和文件夹\n\n * token ?\n\nmatch一个字符\n\n * range\n\n匹配一个在[a-za-z]内的字符，有regex的味道了\n\n * asterisk(**)\n\nleading：表示每个目录里头match的东西比如**/foo/bar表示匹配每个目录里面的foo/bar\n\ntrailing: 表示在某目录里头所有的文件比如bar/**\n\ncenter: 表示目录通配比如foo/**/bar，可以是foo/114/514/bar",charsets:{cjk:!0}},{title:"Feature",frontmatter:{},regularPath:"/java/feature_jdk.html",relativePath:"java/feature_jdk.md",key:"v-57d4d2af",path:"/java/feature_jdk.html",headers:[{level:2,title:"Local Variable Inference",slug:"local-variable-inference",normalizedTitle:"local variable inference",charIndex:29},{level:2,title:"Non-denoted Type",slug:"non-denoted-type",normalizedTitle:"non-denoted type",charIndex:59},{level:2,title:"Text block",slug:"text-block",normalizedTitle:"text block",charIndex:81},{level:2,title:"record keyword",slug:"record-keyword",normalizedTitle:"record keyword",charIndex:97},{level:2,title:"enhanced switch",slug:"enhanced-switch",normalizedTitle:"enhanced switch",charIndex:117},{level:2,title:"JShell",slug:"jshell",normalizedTitle:"jshell",charIndex:138},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:150}],headersStr:"Local Variable Inference Non-denoted Type Text block record keyword enhanced switch JShell instanceof",content:'# Feature\n\n\n\n * Feature\n   * Local Variable Inference\n   * Non-denoted Type\n   * Text block\n   * record keyword\n   * enhanced switch\n   * JShell\n   * instanceof\n\n\n\n下面是一些我会用到的JDK1.8+的还不错的新特性\n\n\n# Local Variable Inference\n\n(Since Java10)局部变量类型推导\n\n这个不是关键字，不是关键字！，他是一个类型，是类型！\n\n现在自动类型推导在Java上也可以了！(香)\n\n不过缺点是在编译时被实际类型替换(无伤大雅)\n\n一个痛点得到了完美的解决，比如类型Set<Map<K, V>.Entry<K, V>>\n\nvar map = new HashMap<String, Integer>();\nvar entrySet = map.entrySet(); // Set<Map<String, Integer>.Entry<String, Integer>>\n\n\n但是这玩意不想C++的auto那么万能，有一些场景是用不了的\n\n其实只需要注意到一个小小的本质：在编译时被实际类型替换，并且是局部变量\n\n * 匿名λ expression\n\nvar lambda = s -> System.out::println; // NOT OK! Can\'t infer the type of lambda\nvar lambda = new Consumer<String>() {\n    @Override\n    public void accept(String s) {\n        System.out.println(s);\n    }\n}; // OK! Because the type of lambda is known\n\n\n * 方法参数列表\n\npublic void test(var foo) // not allowed\n\n\n * 仅声明\n\nvar x; // not allowed\n\n\n * 赋个null\n\nvar x = null; // not allowed\n\n\n * try-catch block\n\n你永远不知道在运行时前的编译时，你要catch的Exception是什么类型。\n\ntry {\n\n} catch (var e) // not allowed!\n\n\n\n# Non-denoted Type\n\n(Since Java10)这个跟接口和抽象类是不一样的。\n\n> Java has a number of non-denotable types - that is to say types that can exist within your program, but for which there’s no way to explicitly write out the name for that type. A good example of a non-denotable type is an anonymous class - you can add fields and methods to it, but you won’t be able to write the name of the anonymous class in your Java code. The diamond operator can’t be used with anonymous classes. Var is less restricted and can be used to support some non-denotable types - specifically anonymous classes and intersection types.\n\n在Java10里，我们可以基于一个存在的类，来创建一个新类，不过这个新类却没有相对应的新类型名字。这个就叫做Non-denoted Type，声明这种对象的时候必须要用var(因为根本没有存在的类型)，下面的代码用Object做declared type就会报错。\n\npublic class Test {\n    public static void main(String[] args) {\n        var obj = new Object() {\n            final String s = "114514";\n\n            public String test() {\n                return "From test(): " + s;\n            }\n\n            @Override\n            public String toString() {\n                return s;\n            }\n        };\n\n        System.out.println(obj.test()); // From test(): 114514\n    }\n}\n\n\n\n# Text block\n\n(Since Java15)对于多行字符串，终于可以不用加号拼接字符串了\n\nPython, YES!!!\n\nString example = """\n        This is a \n        multi-line example.\n        Wow, so python-liked(\n        """;\n\nSystem.out.println(example);\n\n/** OUTPUT\nThis is a\nmulti-line example.\nWow, so python-liked(\n*/\n\n\n\n# record keyword\n\n目前preview，要等未来的Java16(目前2021/03/21)\n\n\n# enhanced switch\n\n(Since Java14)见这里: 链接\n\nwhen are you?(\n\n可以当成赋值表达式用了，真香。所以赋值也好，return也好，都可以的。->后若是一个code block，那么就要用yield来说明返回值。\n\npublic class Test {\n    enum Foo {\n        ONE, TWO, THREE, FOUR, FIVE\n    }\n\n    public static void main(String[] args) {\n        var bar = Foo.ONE;\n        String s = switch(bar) {\n            case ONE, TWO   -> "case 1";\n            case THREE      -> { var i = 0; yield "case 2"; }\n            case FOUR, FIVE -> "case 3";\n            default         -> {\n                System.out.println("No case matched");\n                yield "case 0";\n            }\n        };\n    }\n}\n\n\n不过赋值时候，要注意全部情况，否则就会报错（不愧是严格的Java）\n\n非赋值的switch，也是这样。主要是:to->, omit break。\n\n\n# JShell\n\n(Since Java9)很像动态语言如py的command prompt啊（\n\n使用的话直接cmd输入即可\n\njshell\n\n\n\n# instanceof\n\n(Preview)待更...',normalizedContent:'# feature\n\n\n\n * feature\n   * local variable inference\n   * non-denoted type\n   * text block\n   * record keyword\n   * enhanced switch\n   * jshell\n   * instanceof\n\n\n\n下面是一些我会用到的jdk1.8+的还不错的新特性\n\n\n# local variable inference\n\n(since java10)局部变量类型推导\n\n这个不是关键字，不是关键字！，他是一个类型，是类型！\n\n现在自动类型推导在java上也可以了！(香)\n\n不过缺点是在编译时被实际类型替换(无伤大雅)\n\n一个痛点得到了完美的解决，比如类型set<map<k, v>.entry<k, v>>\n\nvar map = new hashmap<string, integer>();\nvar entryset = map.entryset(); // set<map<string, integer>.entry<string, integer>>\n\n\n但是这玩意不想c++的auto那么万能，有一些场景是用不了的\n\n其实只需要注意到一个小小的本质：在编译时被实际类型替换，并且是局部变量\n\n * 匿名λ expression\n\nvar lambda = s -> system.out::println; // not ok! can\'t infer the type of lambda\nvar lambda = new consumer<string>() {\n    @override\n    public void accept(string s) {\n        system.out.println(s);\n    }\n}; // ok! because the type of lambda is known\n\n\n * 方法参数列表\n\npublic void test(var foo) // not allowed\n\n\n * 仅声明\n\nvar x; // not allowed\n\n\n * 赋个null\n\nvar x = null; // not allowed\n\n\n * try-catch block\n\n你永远不知道在运行时前的编译时，你要catch的exception是什么类型。\n\ntry {\n\n} catch (var e) // not allowed!\n\n\n\n# non-denoted type\n\n(since java10)这个跟接口和抽象类是不一样的。\n\n> java has a number of non-denotable types - that is to say types that can exist within your program, but for which there’s no way to explicitly write out the name for that type. a good example of a non-denotable type is an anonymous class - you can add fields and methods to it, but you won’t be able to write the name of the anonymous class in your java code. the diamond operator can’t be used with anonymous classes. var is less restricted and can be used to support some non-denotable types - specifically anonymous classes and intersection types.\n\n在java10里，我们可以基于一个存在的类，来创建一个新类，不过这个新类却没有相对应的新类型名字。这个就叫做non-denoted type，声明这种对象的时候必须要用var(因为根本没有存在的类型)，下面的代码用object做declared type就会报错。\n\npublic class test {\n    public static void main(string[] args) {\n        var obj = new object() {\n            final string s = "114514";\n\n            public string test() {\n                return "from test(): " + s;\n            }\n\n            @override\n            public string tostring() {\n                return s;\n            }\n        };\n\n        system.out.println(obj.test()); // from test(): 114514\n    }\n}\n\n\n\n# text block\n\n(since java15)对于多行字符串，终于可以不用加号拼接字符串了\n\npython, yes!!!\n\nstring example = """\n        this is a \n        multi-line example.\n        wow, so python-liked(\n        """;\n\nsystem.out.println(example);\n\n/** output\nthis is a\nmulti-line example.\nwow, so python-liked(\n*/\n\n\n\n# record keyword\n\n目前preview，要等未来的java16(目前2021/03/21)\n\n\n# enhanced switch\n\n(since java14)见这里: 链接\n\nwhen are you?(\n\n可以当成赋值表达式用了，真香。所以赋值也好，return也好，都可以的。->后若是一个code block，那么就要用yield来说明返回值。\n\npublic class test {\n    enum foo {\n        one, two, three, four, five\n    }\n\n    public static void main(string[] args) {\n        var bar = foo.one;\n        string s = switch(bar) {\n            case one, two   -> "case 1";\n            case three      -> { var i = 0; yield "case 2"; }\n            case four, five -> "case 3";\n            default         -> {\n                system.out.println("no case matched");\n                yield "case 0";\n            }\n        };\n    }\n}\n\n\n不过赋值时候，要注意全部情况，否则就会报错（不愧是严格的java）\n\n非赋值的switch，也是这样。主要是:to->, omit break。\n\n\n# jshell\n\n(since java9)很像动态语言如py的command prompt啊（\n\n使用的话直接cmd输入即可\n\njshell\n\n\n\n# instanceof\n\n(preview)待更...',charsets:{cjk:!0}},{title:"Asynchronous",frontmatter:{},regularPath:"/javascript/asynchronous.html",relativePath:"javascript/asynchronous.md",key:"v-2ee9a139",path:"/javascript/asynchronous.html",headers:[{level:2,title:"Intro",slug:"intro",normalizedTitle:"intro",charIndex:19},{level:2,title:"Callback",slug:"callback",normalizedTitle:"callback",charIndex:237},{level:2,title:"Implementation",slug:"implementation",normalizedTitle:"implementation",charIndex:464},{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:1219},{level:3,title:"Stage",slug:"stage",normalizedTitle:"stage",charIndex:1464},{level:3,title:"Instantiation",slug:"instantiation",normalizedTitle:"instantiation",charIndex:2068},{level:3,title:"Examples",slug:"examples",normalizedTitle:"examples",charIndex:2591},{level:3,title:"async",slug:"async",normalizedTitle:"async",charIndex:2846},{level:3,title:"await",slug:"await",normalizedTitle:"await",charIndex:3575}],headersStr:"Intro Callback Implementation Promise Stage Instantiation Examples async await",content:'# Asynchronous\n\n\n# Intro\n\n一般代码是顺序执行的。但是，如果你的页面，要做一点时间长一点的事情(比如说网络请求，读取json等)。那么，在这些事情执行的时候，后面的语句就会在等待，此时整个页面就会冻住。直到执行完前面的语句。\n\n一个例子就是alert()这个函数，在点击OK之前，后面的代码都不会被执行，这个函数可以很好地演示同步的缺点。\n\n但是此处我们可以用异步，让这些耗时比较长的事情扔到后台执行，等执行完成后，处理callback\n\n\n\n\n# Callback\n\nCallback function就是一个函数，作为参数，传给会在后台运行的函数\n\n> Async callbacks are functions that are specified as arguments when calling a function which will start executing code in the background.\n\n * 一般来说，当异步操作完成之后，这个回调函数就会被调用。\n\n\n# Implementation\n\njs运行的主线程只有一条，但目前对于操作系统的理解不是很深刻，我只知道js是单线程非阻式的实现。\n\n那大致是怎么样的呢？摘自MDN\n\n> Async operations like promises are put into an event queue, which runs after the main thread has finished processing so that they do not block subsequent JavaScript code from running. The queued operations will complete as soon as possible then return their results to the JavaScript environment.\n\n看起来要异步执行的操作，先是被存放在一个事件队列里头了，然后再在主运行线程空闲的时候来执行。\n\n我们也可以用一段代码来试一下，可以在循环console.log()输出114514次一个变量，然后设置一个3秒的setTimeout()来输出hello world\n\nsetTimeout(() => console.log("Hello world"), 3000);\nfor (var i = 0; i < 114514; i++) { console.log(i) }\n\n\n理论上三秒就能执行输出hello world了，但是等了十多秒，也就是for循环结束之后才输出。（这就是在主线程空闲时再执行）\n\n114512\n114513\nHello world\n\n\n异步的任务是用线程池里头的后台线程来handle的。整个过程如图所示\n\n\n\n\n# Promise\n\nPromise都是异步的，这是ES2015引进来的新东西\n\n> In essence, it\'s the browser\'s way of saying "I promise to get back to you with the answer as soon as I can," hence the name "promise."\n\nPromise表示一个操作的中间状态，可以handle一个在未来才已知的量，在未来这个未知的量变为已知之后，就可以处理它了。\n\n\n# Stage\n\nPromise对象有三种状态: pending, fulfilled 和 rejected\n\n * pending: initial state, neither fulfilled nor rejected.\n * fulfilled: meaning that the operation was completed successfully.\n * rejected: meaning that the operation failed.\n\n\n\n由于方法then()与catch()与finally()都返回一个Promise，这个Promise的result呢...只有then()能更改Promise对象的resolved value。因此Promise可以被链式调用。像这样\n\nconst calc = new Promise((resolve, reject) => {\n    resolve(4);\n}).then(val => val ** 2)\n  .then(val => val ** 2)\n  .then(val => val ** 2)\n  .then(val => console.log(val)); // 65536\n\n\n其中，then()中的参数onRejection是可选的，error也可以由catch(onRejection)来handle\n\n\n# Instantiation\n\nlet promise = new Promise(function(resolve, reject) {\n  // the function is executed automatically when the promise is constructed\n\n  // after 1 second signal that the job is done with the result "done"\n  setTimeout(() => resolve("done"), 1000);\n  // or done with the result "error"\n  // setTimeout(() => reject("error", 1000));\n});\n\n\n当Promise对象得到结果之后，必是下面两者之一\n\n * resolve(value) — if the job finished successfully, with result value.\n * reject(error) — if an error occurred, error is the error object.\n\n\n\n\n# Examples\n\n由于Promise保证了是异步，因此就算是看起来可以马上被执行的函数，也只会在栈空了、过了一个clock-tick之后被执行\n\nconst promiseA = new Promise( (resolutionFunc,rejectionFunc) => {\n    resolutionFunc(777);\n});\n// At this point, "promiseA" is already settled.\npromiseA.then( (val) => console.log("asynchronous logging has val:",val) );\nconsole.log("immediate logging");\n\n// produces output in this order:\n// immediate logging\n// asynchronous logging has val: 777\n\n\n----------------------------------------\n\n * 与callback的区别\n\n> Promises have some similarities to old-style callbacks. They are essentially a returned object to which you attach callback functions, rather than having to pass callbacks into a function.\n\n它们本质都是一个返回的对象，我们可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。\n\n----------------------------------------\n\n\n# async\n\n加async的函数，就会是一个Promise-based function，返回值就会是一个Promise\n\nlet hello = async function() { return "Hello" };\nhello(); // Promise {<fulfilled>: "hello"}\nhello().then((value) => console.log(value)); // hello\n\n\n\n# await\n\n> The await operator is used to wait for a Promise\n\n[rv] = await expression;\n// rv: Returns the fulfilled value of the promise, or the value itself if it\'s not a Promise.\n// expression: A Promise or any value to wait for.\n\n\n在Promise-based的函数调用前，加await，可以让code暂时停下，直到这个promise被fulfill，并返回结果的值，而不是Promise\n\n// a function that returns a Promise\nfunction resolveAfter2Seconds(x) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(x);\n    }, 2000);\n  });\n}\n\nasync function f1() {\n  // works only inside async functions\n  var x = await resolveAfter2Seconds(10);\n  console.log(x); // 10\n}\n\nf1();\n\n\n而如果把await去掉,就会打印出 Promise {<pending>}\n\nvar x = resolveAfter2Seconds(10); // await was removed\n\n\n还可以直接get到thenable对象的值...thenable可以是一个对象，但是这个对象里头有then函数，并且函数的样子长得很像一个Promise的话。那await就会把它当成一个Promise。\n\n一般可以用来做自定义\n\nlet show = v => console.log(v);\n\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    show(resolve); // [Function (anonymous)]\n    setTimeout(() => resolve(this.num * 2), 1000); // 8\n  }\n}\n\nnew Promise(resolve => resolve(4))\n  .then(result => {\n    return new Thenable(result); // 4\n  })\n  .then(show); // shows 2 after 1000ms\n\n\nawait还可以把reject()的给catch住，不过暂时还不知道有什么用...\n\nlet f = async () => {\n  try {\n      let x = await Promise.reject(4);\n  } catch(e) {\n      console.log(114514)\n  }\n};\n\nf(); // 114514\n',normalizedContent:'# asynchronous\n\n\n# intro\n\n一般代码是顺序执行的。但是，如果你的页面，要做一点时间长一点的事情(比如说网络请求，读取json等)。那么，在这些事情执行的时候，后面的语句就会在等待，此时整个页面就会冻住。直到执行完前面的语句。\n\n一个例子就是alert()这个函数，在点击ok之前，后面的代码都不会被执行，这个函数可以很好地演示同步的缺点。\n\n但是此处我们可以用异步，让这些耗时比较长的事情扔到后台执行，等执行完成后，处理callback\n\n\n\n\n# callback\n\ncallback function就是一个函数，作为参数，传给会在后台运行的函数\n\n> async callbacks are functions that are specified as arguments when calling a function which will start executing code in the background.\n\n * 一般来说，当异步操作完成之后，这个回调函数就会被调用。\n\n\n# implementation\n\njs运行的主线程只有一条，但目前对于操作系统的理解不是很深刻，我只知道js是单线程非阻式的实现。\n\n那大致是怎么样的呢？摘自mdn\n\n> async operations like promises are put into an event queue, which runs after the main thread has finished processing so that they do not block subsequent javascript code from running. the queued operations will complete as soon as possible then return their results to the javascript environment.\n\n看起来要异步执行的操作，先是被存放在一个事件队列里头了，然后再在主运行线程空闲的时候来执行。\n\n我们也可以用一段代码来试一下，可以在循环console.log()输出114514次一个变量，然后设置一个3秒的settimeout()来输出hello world\n\nsettimeout(() => console.log("hello world"), 3000);\nfor (var i = 0; i < 114514; i++) { console.log(i) }\n\n\n理论上三秒就能执行输出hello world了，但是等了十多秒，也就是for循环结束之后才输出。（这就是在主线程空闲时再执行）\n\n114512\n114513\nhello world\n\n\n异步的任务是用线程池里头的后台线程来handle的。整个过程如图所示\n\n\n\n\n# promise\n\npromise都是异步的，这是es2015引进来的新东西\n\n> in essence, it\'s the browser\'s way of saying "i promise to get back to you with the answer as soon as i can," hence the name "promise."\n\npromise表示一个操作的中间状态，可以handle一个在未来才已知的量，在未来这个未知的量变为已知之后，就可以处理它了。\n\n\n# stage\n\npromise对象有三种状态: pending, fulfilled 和 rejected\n\n * pending: initial state, neither fulfilled nor rejected.\n * fulfilled: meaning that the operation was completed successfully.\n * rejected: meaning that the operation failed.\n\n\n\n由于方法then()与catch()与finally()都返回一个promise，这个promise的result呢...只有then()能更改promise对象的resolved value。因此promise可以被链式调用。像这样\n\nconst calc = new promise((resolve, reject) => {\n    resolve(4);\n}).then(val => val ** 2)\n  .then(val => val ** 2)\n  .then(val => val ** 2)\n  .then(val => console.log(val)); // 65536\n\n\n其中，then()中的参数onrejection是可选的，error也可以由catch(onrejection)来handle\n\n\n# instantiation\n\nlet promise = new promise(function(resolve, reject) {\n  // the function is executed automatically when the promise is constructed\n\n  // after 1 second signal that the job is done with the result "done"\n  settimeout(() => resolve("done"), 1000);\n  // or done with the result "error"\n  // settimeout(() => reject("error", 1000));\n});\n\n\n当promise对象得到结果之后，必是下面两者之一\n\n * resolve(value) — if the job finished successfully, with result value.\n * reject(error) — if an error occurred, error is the error object.\n\n\n\n\n# examples\n\n由于promise保证了是异步，因此就算是看起来可以马上被执行的函数，也只会在栈空了、过了一个clock-tick之后被执行\n\nconst promisea = new promise( (resolutionfunc,rejectionfunc) => {\n    resolutionfunc(777);\n});\n// at this point, "promisea" is already settled.\npromisea.then( (val) => console.log("asynchronous logging has val:",val) );\nconsole.log("immediate logging");\n\n// produces output in this order:\n// immediate logging\n// asynchronous logging has val: 777\n\n\n----------------------------------------\n\n * 与callback的区别\n\n> promises have some similarities to old-style callbacks. they are essentially a returned object to which you attach callback functions, rather than having to pass callbacks into a function.\n\n它们本质都是一个返回的对象，我们可以将回调函数附加到该对象上，而不必将回调作为参数传递给另一个函数。\n\n----------------------------------------\n\n\n# async\n\n加async的函数，就会是一个promise-based function，返回值就会是一个promise\n\nlet hello = async function() { return "hello" };\nhello(); // promise {<fulfilled>: "hello"}\nhello().then((value) => console.log(value)); // hello\n\n\n\n# await\n\n> the await operator is used to wait for a promise\n\n[rv] = await expression;\n// rv: returns the fulfilled value of the promise, or the value itself if it\'s not a promise.\n// expression: a promise or any value to wait for.\n\n\n在promise-based的函数调用前，加await，可以让code暂时停下，直到这个promise被fulfill，并返回结果的值，而不是promise\n\n// a function that returns a promise\nfunction resolveafter2seconds(x) {\n  return new promise(resolve => {\n    settimeout(() => {\n      resolve(x);\n    }, 2000);\n  });\n}\n\nasync function f1() {\n  // works only inside async functions\n  var x = await resolveafter2seconds(10);\n  console.log(x); // 10\n}\n\nf1();\n\n\n而如果把await去掉,就会打印出 promise {<pending>}\n\nvar x = resolveafter2seconds(10); // await was removed\n\n\n还可以直接get到thenable对象的值...thenable可以是一个对象，但是这个对象里头有then函数，并且函数的样子长得很像一个promise的话。那await就会把它当成一个promise。\n\n一般可以用来做自定义\n\nlet show = v => console.log(v);\n\nclass thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    show(resolve); // [function (anonymous)]\n    settimeout(() => resolve(this.num * 2), 1000); // 8\n  }\n}\n\nnew promise(resolve => resolve(4))\n  .then(result => {\n    return new thenable(result); // 4\n  })\n  .then(show); // shows 2 after 1000ms\n\n\nawait还可以把reject()的给catch住，不过暂时还不知道有什么用...\n\nlet f = async () => {\n  try {\n      let x = await promise.reject(4);\n  } catch(e) {\n      console.log(114514)\n  }\n};\n\nf(); // 114514\n',charsets:{cjk:!0}},{title:"Design patterns",frontmatter:{},regularPath:"/java/design_patterns.html",relativePath:"java/design_patterns.md",key:"v-544c8bf7",path:"/java/design_patterns.html",headers:[{level:2,title:"Observer Pattern(JavaFX)",slug:"observer-pattern-javafx",normalizedTitle:"observer pattern(javafx)",charIndex:31},{level:3,title:"写在前面",slug:"写在前面",normalizedTitle:"写在前面",charIndex:82},{level:3,title:"上手之前",slug:"上手之前",normalizedTitle:"上手之前",charIndex:303},{level:3,title:"开始胡乱分析",slug:"开始胡乱分析",normalizedTitle:"开始胡乱分析",charIndex:2024},{level:3,title:"亲手试错",slug:"亲手试错",normalizedTitle:"亲手试错",charIndex:13482},{level:3,title:"最后总结",slug:"最后总结",normalizedTitle:"最后总结",charIndex:16758}],headersStr:"Observer Pattern(JavaFX) 写在前面 上手之前 开始胡乱分析 亲手试错 最后总结",content:'# Design patterns\n\n此页面有待重改\n\n\n# Observer Pattern(JavaFX)\n\n本文中的JavaFX版本号为11.0.9\n\n\n# 写在前面\n\n最近的军训真的又干燥又冷，我感到十分不舒服。不过军训的中午，拥有长达两个钟的吃饭与休息时间。闲来无事，我就捡起了好两个星期没有接触的Java（这两个星期游戏+复习+发烧，时间都没耗光了）\n\n那么言归正传，之前我学了并会在一些简单的实际应用中使用Java的OOP，并了解到了一些设计模式。最近又想了解一下Observer Pattern（观察者模式），那么我能否通过阅读我所熟练使用的JavaFX源码来了解这个设计模式呢？\n\n\n# 上手之前\n\n“知己知彼，百战百胜。”这句话还是一样重要，所以我先去找了下观察者模式的解释。\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n通俗地讲，就是对象在更新的时候，顺便通知其他对象，从而使得其他对象得到更新？\n\n我写了一段使用JavaFX代码，运行后，窗口中的宽度与高度大小信息都会随着窗体的大小变化而更新。如下\n\nimport javafx.application.Application;\nimport javafx.beans.InvalidationListener;\nimport javafx.beans.Observable;\nimport javafx.beans.property.ReadOnlyDoubleProperty;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.layout.VBox;\nimport javafx.scene.text.Text;\nimport javafx.stage.Stage;\n\npublic class JavaFXBinding extends Application {\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n        VBox pane = new VBox(5);\n        Text textWidth = new Text();\n        Text textHeight = new Text();\n        pane.getChildren().addAll(textHeight, textWidth);\n        pane.setAlignment(Pos.CENTER);\n\n        //set invalidation listener\n        primaryStage.widthProperty().addListener(new InvalidationListener() {\n            @Override\n            public void invalidated(Observable observable) {\n                String width = String.format("Width: %.2f", ((ReadOnlyDoubleProperty)observable).get());\n                textHeight.setText(width);\n            }\n        });\n        primaryStage.heightProperty().addListener(new InvalidationListener() {\n            @Override\n            public void invalidated(Observable observable) {\n                String height = String.format("Height: %.2f", ((ReadOnlyDoubleProperty)observable).get());\n                textWidth.setText(height);\n            }\n        });\n\n        Scene scene = new Scene(pane);\n        primaryStage.setTitle("TEST");\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n}\n\n\n并且有使用IDEA IDE\n\n\n# 开始胡乱分析\n\n可以看出，窗口里头Text的字符串变换是通过这一段代码实现的。这里以Width（窗体宽度）来说。\n\nprimaryStage.widthProperty().addListener(new InvalidationListener() {\n    @Override\n    public void invalidated(Observable observable) {\n        String width = String.format("Width: %.2f", ((ReadOnlyDoubleProperty)observable).get());\n        textHeight.setText(width);\n    }\n});\n\n\n从这段代码来看，应该是通过invoke widthProperty()来获取primaryStage这个对象里头的ReadOnlyDoubleProperty宽度width，然后对其invoke addListener(javafx.beans.InvalidationListener listener)方法来添加listener。\n\n那我们先跳转到primaryStage这个对象的widthProperty()方法所在位置。\n\n我们在javafx.stage.Windows类下发现了这个，并根据上下文，再复制了其他的片段，如下所示。\n\nprivate ReadOnlyDoubleWrapper width = new ReadOnlyDoubleWrapper(this, "width", Double.NaN);\n\npublic final ReadOnlyDoubleProperty widthProperty() { \n    return width.getReadOnlyProperty(); \n}\n\n\n这里出现了不同的两个类型，并且里面涉及到的方法又去到了其他的类，查了一下jfx的文档，发现了类之间的继承关系如下。\n\nClass ReadOnlyDoubleWrapper\njava.lang.Object\njavafx.beans.binding.NumberExpressionBase\njavafx.beans.binding.DoubleExpression\njavafx.beans.property.ReadOnlyDoubleProperty\njavafx.beans.property.DoubleProperty\njavafx.beans.property.DoublePropertyBase\njavafx.beans.property.SimpleDoubleProperty\njavafx.beans.property.ReadOnlyDoubleWrapper\n\nAll Implemented Interfaces:\nNumberExpression, Observable, Property<Number>, ReadOnlyProperty<Number>, ObservableDoubleValue, ObservableNumberValue, ObservableValue<Number>, WritableDoubleValue, WritableNumberValue, WritableValue<Number>\n\npublic abstract class ReadOnlyDoubleProperty extends DoubleExpression implements ReadOnlyProperty<Number>\npublic class ReadOnlyDoubleWrapper extends SimpleDoubleProperty\n\n\n\n\n由上可见，ReadOnlyDoubleProperty是一个抽象类，而ReadOnlyDoubleWrapper是一个concrete的实实在在的类。通过下面的分析可以查出，一个ReadOnlyDoubleWrapper是如何被construct的。\n\n我们首先在ReadOnlyDoubleWrapper的constructor里头发现了with-arg的super()，也就是说它显示地invoke了父类的constructor。父类里的constructor也是如此的操作，直到来到了类DoublePropertyBase才停了下来。\n\n//class ReadOnlyDoubleWrapper\npublic ReadOnlyDoubleWrapper(Object bean, String name,\n        double initialValue) {\n    super(bean, name, initialValue);\n}\n\n//class SimpleDoubleProperty\npublic SimpleDoubleProperty(Object bean, String name, double initialValue) {\n    super(initialValue);\n    this.bean = bean;\n    this.name = (name == null) ? DEFAULT_NAME : name;\n}\n//class DoublePropertyBase\npublic DoublePropertyBase(double initialValue) {\n    this.value = initialValue;\n}\n\n\n那么，最后返回的是个什么对象？仔细地查看了一下如下的代码，发现这是通过一个私有类ReadOnlyPropertyImpl将一个可写的property转化为了一个只读的property\n\nprivate ReadOnlyPropertyImpl readOnlyProperty;\n\npublic ReadOnlyDoubleProperty getReadOnlyProperty() {\n    if (readOnlyProperty == null) {\n        readOnlyProperty = new ReadOnlyPropertyImpl();\n    }\n    return readOnlyProperty;\n}\n\nprivate class ReadOnlyPropertyImpl extends ReadOnlyDoublePropertyBase {\n\n    @Override\n    public double get() {\n        return ReadOnlyDoubleWrapper.this.get();\n    }\n\n    @Override\n    public Object getBean() {\n        return ReadOnlyDoubleWrapper.this.getBean();\n    }\n\n    @Override\n    public String getName() {\n        return ReadOnlyDoubleWrapper.this.getName();\n    }\n};\n\n\n这个私有类的继承关系如下，为了更好看，我去IDEA上生成了关系图\n\nClass ReadOnlyDoublePropertyBase\njava.lang.Object\njavafx.beans.binding.NumberExpressionBase\njavafx.beans.binding.DoubleExpression\njavafx.beans.property.ReadOnlyDoubleProperty\njavafx.beans.property.ReadOnlyDoublePropertyBase\njavafx.beans.property.ReadOnlyDoubleWrapper.ReadOnlyPropertyImpl\n\nAll Implemented Interfaces:\nNumberExpression, Observable, ReadOnlyProperty<Number>, ObservableDoubleValue, ObservableNumberValue, ObservableValue<Number>\n\n\n\n\n啊，因为在Stage里头的width需要更改，所以要是个可读可写的property。但可以用一个内部私有类，把一个property肛成一个read-only property。并根据dynamic binding将ObservableDoubleValue和ReadOnlyProperty里头的方法给实现掉（原先是在类DoublePropertyBase和SimpleDoubleProperty里头实现的）。实在是妙！\n\n并且查阅文档可以发现内部私有类ReadOnlyPropertyImpl与Listener有关的方法，全部在ReadOnlyDoublePropertyBase类里头。\n\n所以我们要看addListener的实现，就要去DoublePropertyBase这个类里头看了。如下所示\n\nExpressionHelper<Number> helper;\n@Override\npublic void addListener(InvalidationListener listener) {\n    helper = ExpressionHelper.addListener(helper, this, listener);\n}\n\n\naz，里面竟然还有一个ExpressionHelper？？？不管是马是驴，先溜出来看看。看起来这个ExpressionHelper是个抽象类，提供了许多abstract方法，然后由这个抽象类里头concrete的私有内部类实现。调用这个类里面的东西，经过阅读，其实几乎都是从static方法里头把value pass进去处理的。\n\n选择性地抽出ExpressionHelper的部分代码。\n\nprotected final ObservableValue<T> observable;\n\nprivate ExpressionHelper(ObservableValue<T> observable) {\n    this.observable = observable;\n}\n\npublic static <T> ExpressionHelper<T> addListener(ExpressionHelper<T> helper, ObservableValue<T> observable, InvalidationListener listener) {\n    if ((observable == null) || (listener == null)) {\n        throw new NullPointerException();\n    }\n    observable.getValue(); // validate observable\n    return (helper == null)? new SingleInvalidation<T>(observable, listener) : helper.addListener(listener);\n}\n\n//part of the code\nprivate static class SingleInvalidation<T> extends ExpressionHelper<T> {\n\n    private final InvalidationListener listener;\n\n    private SingleInvalidation(ObservableValue<T> expression, InvalidationListener listener) {\n        super(expression);\n        this.listener = listener;\n    }\n\n    @Override\n    protected ExpressionHelper<T> addListener(InvalidationListener listener) {\n        return new Generic<T>(observable, this.listener, listener);\n    }\n}\n\n//part of the code\nprivate static class Generic<T> extends ExpressionHelper<T> {\n\n    private InvalidationListener[] invalidationListeners;\n    private ChangeListener<? super T>[] changeListeners;\n    private int invalidationSize;\n    private int changeSize;\n    private boolean locked;\n    private T currentValue;\n\n    private Generic(ObservableValue<T> observable, InvalidationListener listener0, InvalidationListener listener1) {\n        super(observable);\n        this.invalidationListeners = new InvalidationListener[] {listener0, listener1};\n        this.invalidationSize = 2;\n    }\n\n    @Override\n    protected Generic<T> addListener(InvalidationListener listener) {\n        if (invalidationListeners == null) {\n            invalidationListeners = new InvalidationListener[] {listener};\n            invalidationSize = 1;\n        } else {\n            final int oldCapacity = invalidationListeners.length;\n            if (locked) {\n                final int newCapacity = (invalidationSize < oldCapacity)? oldCapacity : (oldCapacity * 3)/2 + 1;\n                invalidationListeners = Arrays.copyOf(invalidationListeners, newCapacity);\n            } else if (invalidationSize == oldCapacity) {\n                invalidationSize = trim(invalidationSize, invalidationListeners);\n                if (invalidationSize == oldCapacity) {\n                    final int newCapacity = (oldCapacity * 3)/2 + 1;\n                    invalidationListeners = Arrays.copyOf(invalidationListeners, newCapacity);\n                }\n            }\n            invalidationListeners[invalidationSize++] = listener;\n        }\n        return this;\n    }\n}\n\n\n根据SingleInvalidation的英语意思，可以猜测这个类是专门处理只有一个listener的情况的，再结合Generic的constructor的代码和SingleInvalidation中addListener()，在new这个对象的时候顺便也把Observable通过super(expression);给赋值进去了。并可以猜测，当有超过一个listener嗷嗷待哺的时候，ExpressionHelper中的static方法就会return一个Generic对象给DoublePropertyBase中的helper对象。也就是说，所有的listener都被保存在了property对象的helper对象里头。\n\n那么，言归正传，到底property的value变化是怎么样让listener们知道的呢？\n\n那么，在这个例子里头，width property的更改，是随着窗体大小的更改而更改的。那么我猜测可以通过看javafx.stage.Windows里头的方法来找到根源。\n\npublic final void setWidth(double value) {\n    width.set(value);\n    peerBoundsConfigurator.setWindowWidth(value);\n    widthExplicit = true;\n}\n\n\n可以看出，这个width是通过set(double value)方法更改值的。通过IDE强大的定位功能，我一番小操作，就来到了DoublePropertyBase里头，找到了这么点代码\n\n@Override\npublic void set(double newValue) {\n    if (isBound()) {\n        throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n                getBean().getClass().getSimpleName() + "." + getName() + " : ": "") + "A bound value cannot be set.");\n    }\n    if (value != newValue) {\n        value = newValue;\n        markInvalid();\n    }\n}\n\nprivate void markInvalid() {\n    if (valid) {\n        valid = false;\n        invalidated();\n        fireValueChangedEvent();\n    }\n}\n\n\n但是，我们做出监听的对象是ReadOnlyDoubleWrapper啊，那么怎么就只定位到了DoublePropertyBase呢？大脑告诉我，IDE不是万能的，只是我自己太菜导致万万不能而已。回想刚刚上面记录的继承关系图和width的实际类型，我顺藤摸瓜，来到了ReadOnlyDoubleWrapper，果不其然，找到了Override的方法\n\nprivate ReadOnlyPropertyImpl readOnlyProperty;\n\n@Override\nprotected void fireValueChangedEvent() {\n    super.fireValueChangedEvent();\n    if (readOnlyProperty != null) {\n        readOnlyProperty.fireValueChangedEvent();\n    }\n}\n\n\n又根据ReadOnlyDoubleWrapper的继承关系图，我找到了。ReadOnlyDoublePropertyBase里头的这个方法的确是被调用了。\n\nprotected void fireValueChangedEvent() {\n    ExpressionHelper.fireValueChangedEvent(helper);\n}\n\n\n来到这里，就已经稳得一笔了，我们只需要定位到ReadOnlyDoublePropertyBase里头的helper实际所属的类，找到fireValueChangedEvent()方法即可\n\n//ExpressionHelper (Part)\npublic static <T> void fireValueChangedEvent(ExpressionHelper<T> helper) {\n    if (helper != null) {\n        helper.fireValueChangedEvent();\n    }\n}\n\n//SingleInvalidator (Part)\nprotected final ObservableValue<T> observable;\n\n@Override\nprotected void fireValueChangedEvent() {\n    try {\n        listener.invalidated(observable);\n    } catch (Exception e) {\n        Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n    }\n}\n\n//Generic (Part)\nprivate static class Generic<T> extends ExpressionHelper<T> {\n    private InvalidationListener[] invalidationListeners;\n    private ChangeListener<? super T>[] changeListeners;\n    private int invalidationSize;\n    private int changeSize;\n    private boolean locked;\n    private T currentValue;\n\n    @Override\n    protected void fireValueChangedEvent() {\n        final InvalidationListener[] curInvalidationList = invalidationListeners;\n        final int curInvalidationSize = invalidationSize;\n        final ChangeListener<? super T>[] curChangeList = changeListeners;\n        final int curChangeSize = changeSize;\n\n        try {\n            locked = true;\n            for (int i = 0; i < curInvalidationSize; i++) {\n                try {\n                    curInvalidationList[i].invalidated(observable);\n                } catch (Exception e) {\n                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n                }\n            }\n            if (curChangeSize > 0) {\n                final T oldValue = currentValue;\n                currentValue = observable.getValue();\n                final boolean changed = (currentValue == null)? (oldValue != null) : !currentValue.equals(oldValue);\n                if (changed) {\n                    for (int i = 0; i < curChangeSize; i++) {\n                        try {\n                            curChangeList[i].changed(observable, oldValue, currentValue);\n                        } catch (Exception e) {\n                            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n                        }\n                    }\n                }\n            }\n        } finally {\n            locked = false;\n        }\n    }\n}\n\n\n从SingleInvalidation中的fireValueChangedEvent()中可以看出，直接对已经实现了的InvalidationListener进行方法invoke，如果是一个以上的话，就是for循环分别调用不同InvalidationListener的invalidated()方法，其中还有一些其他的判断，跟这里暂时没啥关系，先不提。\n\n那么，做出了推理之后，是不是要Debug验证一下呢？于是我在IDE中，给这里下了个Breakpoint\n\n//ReadOnlyDoublePropertyBase\nExpressionHelper.fireValueChangedEvent(helper);//breakpoint here\n\n\n从Frame来看，我的思路被验证了，是正确的\n\n\n\n\n# 亲手试错\n\n竟然不明不白地就这样分析了一通InvalidationListener的实现，对Observer Pattern也有了更进一步的了解。于是垃圾地模拟了一下好像现实的场景：有一个商店里面有商品要抢购，而顾客们迫切地想知道商品的补货信息。但是，你是一个Customer，而不一定是一个Subscriber。\n\n思路就是，实现一个Subscription接口，然后由Customer实现，最后Store里头存储着subscribers，并会提醒subscriber们关于价格和库存的更新。\n\npackage test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Observer {\n    public static void main(String[] args) {\n        Store store = new Store();\n        Customer customer = new Customer("Situ");\n        Customer customer1 = new Customer("Tony");\n        customer.subscribe(store);\n        customer1.subscribe(store);\n\n        store.updatePrice(1919810);\n        store.updateStock(false);\n        customer1.unsubscribe(store);\n        store.updateStock(true);\n        customer.unsubscribe(store);\n    }\n}\n\nclass Store {\n    private final List<Subscription> subscribers = new ArrayList<>();\n    private final Product product = new Product();\n\n    void addSubscriber(Subscription subscriber) {\n        System.out.println("A subscriber subscribes the product!");\n        subscribers.add(subscriber);\n    }\n\n    void removeSubscriber(Subscription subscriber) {\n        System.out.println("A subscriber unsubscribes the product!");\n        subscribers.remove(subscriber);\n    }\n\n    void updateStock(boolean status) {\n        product.setStock(status);\n        subscribers.forEach(subscription -> subscription.notifyStock(product));\n    }\n\n    void updatePrice(int price) {\n        product.setPrice(price);\n        subscribers.forEach(subscription -> subscription.notifyPriceChange(product));\n    }\n}\n\nclass Product {\n    private int price;\n    private boolean stock;\n\n    Product() {\n        price = 114514;\n        stock = false;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n\n    public void setStock(boolean status) {\n        stock = status;\n    }\n\n    public boolean getStock() {\n        return stock;\n    }\n}\n\ninterface Subscription {\n    void notifyStock(Product product);\n    void notifyPriceChange(Product product);\n}\n\nclass Customer implements Subscription {\n    private final String name;\n\n    Customer(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void notifyStock(Product product) {\n        System.out.println("Hi, " + getName() + ". The product is "\n                + (product.getStock() ? "in stock" : "out of stock"));\n    }\n\n    @Override\n    public void notifyPriceChange(Product product) {\n        System.out.println("Hi, " + getName()\n                + ". The price of product is changed. New price is $" + product.getPrice());\n    }\n\n    public void subscribe(Store store) {\n        store.addSubscriber(this);\n    }\n\n    public void unsubscribe(Store store) {\n        store.removeSubscriber(this);\n    }\n}\n\n\n运行结果为\n\nA subscriber subscribes the product!\nA subscriber subscribes the product!\nHi, Situ. The price of product is changed. New price is $1919810\nHi, Tony. The price of product is changed. New price is $1919810\nHi, Situ. The product is out of stock\nHi, Tony. The product is out of stock\nA subscriber unsubscribes the product!\nHi, Situ. The product is in stock\nA subscriber unsubscribes the product!\n\n\n\n# 最后总结\n\n(套话)观察者模式是一种前人总结的有用的编程经验，适用于各种中大型OOP项目中。\n\n总的来说，我就感受到了，这种pattern有些许优点：\n\n 1. 在运行时可以即刻建立俩对象之间的关系\n 2. 遵循开闭原则，subscriber和publisher的代码单独修改时候互不影响\n\n缺点嘛。。。我还太弱了，找不出多少优缺点，不过我感觉这些subscriber在被通知的时候是直接按某种顺序的？也就是说不能通知指定一个subscriber？\n\n最后，阅读这么一小撮源码，也发现到了一些操作我在书上没见过的，看来这就是“纸上得来终觉浅”？\n\n如果有什么不妥的，请大佬在评论区指出。',normalizedContent:'# design patterns\n\n此页面有待重改\n\n\n# observer pattern(javafx)\n\n本文中的javafx版本号为11.0.9\n\n\n# 写在前面\n\n最近的军训真的又干燥又冷，我感到十分不舒服。不过军训的中午，拥有长达两个钟的吃饭与休息时间。闲来无事，我就捡起了好两个星期没有接触的java（这两个星期游戏+复习+发烧，时间都没耗光了）\n\n那么言归正传，之前我学了并会在一些简单的实际应用中使用java的oop，并了解到了一些设计模式。最近又想了解一下observer pattern（观察者模式），那么我能否通过阅读我所熟练使用的javafx源码来了解这个设计模式呢？\n\n\n# 上手之前\n\n“知己知彼，百战百胜。”这句话还是一样重要，所以我先去找了下观察者模式的解释。\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n通俗地讲，就是对象在更新的时候，顺便通知其他对象，从而使得其他对象得到更新？\n\n我写了一段使用javafx代码，运行后，窗口中的宽度与高度大小信息都会随着窗体的大小变化而更新。如下\n\nimport javafx.application.application;\nimport javafx.beans.invalidationlistener;\nimport javafx.beans.observable;\nimport javafx.beans.property.readonlydoubleproperty;\nimport javafx.geometry.pos;\nimport javafx.scene.scene;\nimport javafx.scene.layout.vbox;\nimport javafx.scene.text.text;\nimport javafx.stage.stage;\n\npublic class javafxbinding extends application {\n    @override\n    public void start(stage primarystage) throws exception {\n        vbox pane = new vbox(5);\n        text textwidth = new text();\n        text textheight = new text();\n        pane.getchildren().addall(textheight, textwidth);\n        pane.setalignment(pos.center);\n\n        //set invalidation listener\n        primarystage.widthproperty().addlistener(new invalidationlistener() {\n            @override\n            public void invalidated(observable observable) {\n                string width = string.format("width: %.2f", ((readonlydoubleproperty)observable).get());\n                textheight.settext(width);\n            }\n        });\n        primarystage.heightproperty().addlistener(new invalidationlistener() {\n            @override\n            public void invalidated(observable observable) {\n                string height = string.format("height: %.2f", ((readonlydoubleproperty)observable).get());\n                textwidth.settext(height);\n            }\n        });\n\n        scene scene = new scene(pane);\n        primarystage.settitle("test");\n        primarystage.setscene(scene);\n        primarystage.show();\n    }\n}\n\n\n并且有使用idea ide\n\n\n# 开始胡乱分析\n\n可以看出，窗口里头text的字符串变换是通过这一段代码实现的。这里以width（窗体宽度）来说。\n\nprimarystage.widthproperty().addlistener(new invalidationlistener() {\n    @override\n    public void invalidated(observable observable) {\n        string width = string.format("width: %.2f", ((readonlydoubleproperty)observable).get());\n        textheight.settext(width);\n    }\n});\n\n\n从这段代码来看，应该是通过invoke widthproperty()来获取primarystage这个对象里头的readonlydoubleproperty宽度width，然后对其invoke addlistener(javafx.beans.invalidationlistener listener)方法来添加listener。\n\n那我们先跳转到primarystage这个对象的widthproperty()方法所在位置。\n\n我们在javafx.stage.windows类下发现了这个，并根据上下文，再复制了其他的片段，如下所示。\n\nprivate readonlydoublewrapper width = new readonlydoublewrapper(this, "width", double.nan);\n\npublic final readonlydoubleproperty widthproperty() { \n    return width.getreadonlyproperty(); \n}\n\n\n这里出现了不同的两个类型，并且里面涉及到的方法又去到了其他的类，查了一下jfx的文档，发现了类之间的继承关系如下。\n\nclass readonlydoublewrapper\njava.lang.object\njavafx.beans.binding.numberexpressionbase\njavafx.beans.binding.doubleexpression\njavafx.beans.property.readonlydoubleproperty\njavafx.beans.property.doubleproperty\njavafx.beans.property.doublepropertybase\njavafx.beans.property.simpledoubleproperty\njavafx.beans.property.readonlydoublewrapper\n\nall implemented interfaces:\nnumberexpression, observable, property<number>, readonlyproperty<number>, observabledoublevalue, observablenumbervalue, observablevalue<number>, writabledoublevalue, writablenumbervalue, writablevalue<number>\n\npublic abstract class readonlydoubleproperty extends doubleexpression implements readonlyproperty<number>\npublic class readonlydoublewrapper extends simpledoubleproperty\n\n\n\n\n由上可见，readonlydoubleproperty是一个抽象类，而readonlydoublewrapper是一个concrete的实实在在的类。通过下面的分析可以查出，一个readonlydoublewrapper是如何被construct的。\n\n我们首先在readonlydoublewrapper的constructor里头发现了with-arg的super()，也就是说它显示地invoke了父类的constructor。父类里的constructor也是如此的操作，直到来到了类doublepropertybase才停了下来。\n\n//class readonlydoublewrapper\npublic readonlydoublewrapper(object bean, string name,\n        double initialvalue) {\n    super(bean, name, initialvalue);\n}\n\n//class simpledoubleproperty\npublic simpledoubleproperty(object bean, string name, double initialvalue) {\n    super(initialvalue);\n    this.bean = bean;\n    this.name = (name == null) ? default_name : name;\n}\n//class doublepropertybase\npublic doublepropertybase(double initialvalue) {\n    this.value = initialvalue;\n}\n\n\n那么，最后返回的是个什么对象？仔细地查看了一下如下的代码，发现这是通过一个私有类readonlypropertyimpl将一个可写的property转化为了一个只读的property\n\nprivate readonlypropertyimpl readonlyproperty;\n\npublic readonlydoubleproperty getreadonlyproperty() {\n    if (readonlyproperty == null) {\n        readonlyproperty = new readonlypropertyimpl();\n    }\n    return readonlyproperty;\n}\n\nprivate class readonlypropertyimpl extends readonlydoublepropertybase {\n\n    @override\n    public double get() {\n        return readonlydoublewrapper.this.get();\n    }\n\n    @override\n    public object getbean() {\n        return readonlydoublewrapper.this.getbean();\n    }\n\n    @override\n    public string getname() {\n        return readonlydoublewrapper.this.getname();\n    }\n};\n\n\n这个私有类的继承关系如下，为了更好看，我去idea上生成了关系图\n\nclass readonlydoublepropertybase\njava.lang.object\njavafx.beans.binding.numberexpressionbase\njavafx.beans.binding.doubleexpression\njavafx.beans.property.readonlydoubleproperty\njavafx.beans.property.readonlydoublepropertybase\njavafx.beans.property.readonlydoublewrapper.readonlypropertyimpl\n\nall implemented interfaces:\nnumberexpression, observable, readonlyproperty<number>, observabledoublevalue, observablenumbervalue, observablevalue<number>\n\n\n\n\n啊，因为在stage里头的width需要更改，所以要是个可读可写的property。但可以用一个内部私有类，把一个property肛成一个read-only property。并根据dynamic binding将observabledoublevalue和readonlyproperty里头的方法给实现掉（原先是在类doublepropertybase和simpledoubleproperty里头实现的）。实在是妙！\n\n并且查阅文档可以发现内部私有类readonlypropertyimpl与listener有关的方法，全部在readonlydoublepropertybase类里头。\n\n所以我们要看addlistener的实现，就要去doublepropertybase这个类里头看了。如下所示\n\nexpressionhelper<number> helper;\n@override\npublic void addlistener(invalidationlistener listener) {\n    helper = expressionhelper.addlistener(helper, this, listener);\n}\n\n\naz，里面竟然还有一个expressionhelper？？？不管是马是驴，先溜出来看看。看起来这个expressionhelper是个抽象类，提供了许多abstract方法，然后由这个抽象类里头concrete的私有内部类实现。调用这个类里面的东西，经过阅读，其实几乎都是从static方法里头把value pass进去处理的。\n\n选择性地抽出expressionhelper的部分代码。\n\nprotected final observablevalue<t> observable;\n\nprivate expressionhelper(observablevalue<t> observable) {\n    this.observable = observable;\n}\n\npublic static <t> expressionhelper<t> addlistener(expressionhelper<t> helper, observablevalue<t> observable, invalidationlistener listener) {\n    if ((observable == null) || (listener == null)) {\n        throw new nullpointerexception();\n    }\n    observable.getvalue(); // validate observable\n    return (helper == null)? new singleinvalidation<t>(observable, listener) : helper.addlistener(listener);\n}\n\n//part of the code\nprivate static class singleinvalidation<t> extends expressionhelper<t> {\n\n    private final invalidationlistener listener;\n\n    private singleinvalidation(observablevalue<t> expression, invalidationlistener listener) {\n        super(expression);\n        this.listener = listener;\n    }\n\n    @override\n    protected expressionhelper<t> addlistener(invalidationlistener listener) {\n        return new generic<t>(observable, this.listener, listener);\n    }\n}\n\n//part of the code\nprivate static class generic<t> extends expressionhelper<t> {\n\n    private invalidationlistener[] invalidationlisteners;\n    private changelistener<? super t>[] changelisteners;\n    private int invalidationsize;\n    private int changesize;\n    private boolean locked;\n    private t currentvalue;\n\n    private generic(observablevalue<t> observable, invalidationlistener listener0, invalidationlistener listener1) {\n        super(observable);\n        this.invalidationlisteners = new invalidationlistener[] {listener0, listener1};\n        this.invalidationsize = 2;\n    }\n\n    @override\n    protected generic<t> addlistener(invalidationlistener listener) {\n        if (invalidationlisteners == null) {\n            invalidationlisteners = new invalidationlistener[] {listener};\n            invalidationsize = 1;\n        } else {\n            final int oldcapacity = invalidationlisteners.length;\n            if (locked) {\n                final int newcapacity = (invalidationsize < oldcapacity)? oldcapacity : (oldcapacity * 3)/2 + 1;\n                invalidationlisteners = arrays.copyof(invalidationlisteners, newcapacity);\n            } else if (invalidationsize == oldcapacity) {\n                invalidationsize = trim(invalidationsize, invalidationlisteners);\n                if (invalidationsize == oldcapacity) {\n                    final int newcapacity = (oldcapacity * 3)/2 + 1;\n                    invalidationlisteners = arrays.copyof(invalidationlisteners, newcapacity);\n                }\n            }\n            invalidationlisteners[invalidationsize++] = listener;\n        }\n        return this;\n    }\n}\n\n\n根据singleinvalidation的英语意思，可以猜测这个类是专门处理只有一个listener的情况的，再结合generic的constructor的代码和singleinvalidation中addlistener()，在new这个对象的时候顺便也把observable通过super(expression);给赋值进去了。并可以猜测，当有超过一个listener嗷嗷待哺的时候，expressionhelper中的static方法就会return一个generic对象给doublepropertybase中的helper对象。也就是说，所有的listener都被保存在了property对象的helper对象里头。\n\n那么，言归正传，到底property的value变化是怎么样让listener们知道的呢？\n\n那么，在这个例子里头，width property的更改，是随着窗体大小的更改而更改的。那么我猜测可以通过看javafx.stage.windows里头的方法来找到根源。\n\npublic final void setwidth(double value) {\n    width.set(value);\n    peerboundsconfigurator.setwindowwidth(value);\n    widthexplicit = true;\n}\n\n\n可以看出，这个width是通过set(double value)方法更改值的。通过ide强大的定位功能，我一番小操作，就来到了doublepropertybase里头，找到了这么点代码\n\n@override\npublic void set(double newvalue) {\n    if (isbound()) {\n        throw new java.lang.runtimeexception((getbean() != null && getname() != null ?\n                getbean().getclass().getsimplename() + "." + getname() + " : ": "") + "a bound value cannot be set.");\n    }\n    if (value != newvalue) {\n        value = newvalue;\n        markinvalid();\n    }\n}\n\nprivate void markinvalid() {\n    if (valid) {\n        valid = false;\n        invalidated();\n        firevaluechangedevent();\n    }\n}\n\n\n但是，我们做出监听的对象是readonlydoublewrapper啊，那么怎么就只定位到了doublepropertybase呢？大脑告诉我，ide不是万能的，只是我自己太菜导致万万不能而已。回想刚刚上面记录的继承关系图和width的实际类型，我顺藤摸瓜，来到了readonlydoublewrapper，果不其然，找到了override的方法\n\nprivate readonlypropertyimpl readonlyproperty;\n\n@override\nprotected void firevaluechangedevent() {\n    super.firevaluechangedevent();\n    if (readonlyproperty != null) {\n        readonlyproperty.firevaluechangedevent();\n    }\n}\n\n\n又根据readonlydoublewrapper的继承关系图，我找到了。readonlydoublepropertybase里头的这个方法的确是被调用了。\n\nprotected void firevaluechangedevent() {\n    expressionhelper.firevaluechangedevent(helper);\n}\n\n\n来到这里，就已经稳得一笔了，我们只需要定位到readonlydoublepropertybase里头的helper实际所属的类，找到firevaluechangedevent()方法即可\n\n//expressionhelper (part)\npublic static <t> void firevaluechangedevent(expressionhelper<t> helper) {\n    if (helper != null) {\n        helper.firevaluechangedevent();\n    }\n}\n\n//singleinvalidator (part)\nprotected final observablevalue<t> observable;\n\n@override\nprotected void firevaluechangedevent() {\n    try {\n        listener.invalidated(observable);\n    } catch (exception e) {\n        thread.currentthread().getuncaughtexceptionhandler().uncaughtexception(thread.currentthread(), e);\n    }\n}\n\n//generic (part)\nprivate static class generic<t> extends expressionhelper<t> {\n    private invalidationlistener[] invalidationlisteners;\n    private changelistener<? super t>[] changelisteners;\n    private int invalidationsize;\n    private int changesize;\n    private boolean locked;\n    private t currentvalue;\n\n    @override\n    protected void firevaluechangedevent() {\n        final invalidationlistener[] curinvalidationlist = invalidationlisteners;\n        final int curinvalidationsize = invalidationsize;\n        final changelistener<? super t>[] curchangelist = changelisteners;\n        final int curchangesize = changesize;\n\n        try {\n            locked = true;\n            for (int i = 0; i < curinvalidationsize; i++) {\n                try {\n                    curinvalidationlist[i].invalidated(observable);\n                } catch (exception e) {\n                    thread.currentthread().getuncaughtexceptionhandler().uncaughtexception(thread.currentthread(), e);\n                }\n            }\n            if (curchangesize > 0) {\n                final t oldvalue = currentvalue;\n                currentvalue = observable.getvalue();\n                final boolean changed = (currentvalue == null)? (oldvalue != null) : !currentvalue.equals(oldvalue);\n                if (changed) {\n                    for (int i = 0; i < curchangesize; i++) {\n                        try {\n                            curchangelist[i].changed(observable, oldvalue, currentvalue);\n                        } catch (exception e) {\n                            thread.currentthread().getuncaughtexceptionhandler().uncaughtexception(thread.currentthread(), e);\n                        }\n                    }\n                }\n            }\n        } finally {\n            locked = false;\n        }\n    }\n}\n\n\n从singleinvalidation中的firevaluechangedevent()中可以看出，直接对已经实现了的invalidationlistener进行方法invoke，如果是一个以上的话，就是for循环分别调用不同invalidationlistener的invalidated()方法，其中还有一些其他的判断，跟这里暂时没啥关系，先不提。\n\n那么，做出了推理之后，是不是要debug验证一下呢？于是我在ide中，给这里下了个breakpoint\n\n//readonlydoublepropertybase\nexpressionhelper.firevaluechangedevent(helper);//breakpoint here\n\n\n从frame来看，我的思路被验证了，是正确的\n\n\n\n\n# 亲手试错\n\n竟然不明不白地就这样分析了一通invalidationlistener的实现，对observer pattern也有了更进一步的了解。于是垃圾地模拟了一下好像现实的场景：有一个商店里面有商品要抢购，而顾客们迫切地想知道商品的补货信息。但是，你是一个customer，而不一定是一个subscriber。\n\n思路就是，实现一个subscription接口，然后由customer实现，最后store里头存储着subscribers，并会提醒subscriber们关于价格和库存的更新。\n\npackage test;\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class observer {\n    public static void main(string[] args) {\n        store store = new store();\n        customer customer = new customer("situ");\n        customer customer1 = new customer("tony");\n        customer.subscribe(store);\n        customer1.subscribe(store);\n\n        store.updateprice(1919810);\n        store.updatestock(false);\n        customer1.unsubscribe(store);\n        store.updatestock(true);\n        customer.unsubscribe(store);\n    }\n}\n\nclass store {\n    private final list<subscription> subscribers = new arraylist<>();\n    private final product product = new product();\n\n    void addsubscriber(subscription subscriber) {\n        system.out.println("a subscriber subscribes the product!");\n        subscribers.add(subscriber);\n    }\n\n    void removesubscriber(subscription subscriber) {\n        system.out.println("a subscriber unsubscribes the product!");\n        subscribers.remove(subscriber);\n    }\n\n    void updatestock(boolean status) {\n        product.setstock(status);\n        subscribers.foreach(subscription -> subscription.notifystock(product));\n    }\n\n    void updateprice(int price) {\n        product.setprice(price);\n        subscribers.foreach(subscription -> subscription.notifypricechange(product));\n    }\n}\n\nclass product {\n    private int price;\n    private boolean stock;\n\n    product() {\n        price = 114514;\n        stock = false;\n    }\n\n    public int getprice() {\n        return price;\n    }\n\n    public void setprice(int price) {\n        this.price = price;\n    }\n\n    public void setstock(boolean status) {\n        stock = status;\n    }\n\n    public boolean getstock() {\n        return stock;\n    }\n}\n\ninterface subscription {\n    void notifystock(product product);\n    void notifypricechange(product product);\n}\n\nclass customer implements subscription {\n    private final string name;\n\n    customer(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    @override\n    public void notifystock(product product) {\n        system.out.println("hi, " + getname() + ". the product is "\n                + (product.getstock() ? "in stock" : "out of stock"));\n    }\n\n    @override\n    public void notifypricechange(product product) {\n        system.out.println("hi, " + getname()\n                + ". the price of product is changed. new price is $" + product.getprice());\n    }\n\n    public void subscribe(store store) {\n        store.addsubscriber(this);\n    }\n\n    public void unsubscribe(store store) {\n        store.removesubscriber(this);\n    }\n}\n\n\n运行结果为\n\na subscriber subscribes the product!\na subscriber subscribes the product!\nhi, situ. the price of product is changed. new price is $1919810\nhi, tony. the price of product is changed. new price is $1919810\nhi, situ. the product is out of stock\nhi, tony. the product is out of stock\na subscriber unsubscribes the product!\nhi, situ. the product is in stock\na subscriber unsubscribes the product!\n\n\n\n# 最后总结\n\n(套话)观察者模式是一种前人总结的有用的编程经验，适用于各种中大型oop项目中。\n\n总的来说，我就感受到了，这种pattern有些许优点：\n\n 1. 在运行时可以即刻建立俩对象之间的关系\n 2. 遵循开闭原则，subscriber和publisher的代码单独修改时候互不影响\n\n缺点嘛。。。我还太弱了，找不出多少优缺点，不过我感觉这些subscriber在被通知的时候是直接按某种顺序的？也就是说不能通知指定一个subscriber？\n\n最后，阅读这么一小撮源码，也发现到了一些操作我在书上没见过的，看来这就是“纸上得来终觉浅”？\n\n如果有什么不妥的，请大佬在评论区指出。',charsets:{cjk:!0}},{title:"MultiThreading",frontmatter:{},regularPath:"/java/multithreading.html",relativePath:"java/multithreading.md",key:"v-54fd41b9",path:"/java/multithreading.html",headers:[{level:2,title:"新建Thread与Task",slug:"新建thread与task",normalizedTitle:"新建thread与task",charIndex:215},{level:2,title:"线程池",slug:"线程池",normalizedTitle:"线程池",charIndex:683},{level:2,title:"线程同步",slug:"线程同步",normalizedTitle:"线程同步",charIndex:752},{level:2,title:"线程协助",slug:"线程协助",normalizedTitle:"线程协助",charIndex:3818},{level:2,title:"Blocking Queue",slug:"blocking-queue",normalizedTitle:"blocking queue",charIndex:4126},{level:2,title:"Semaphores",slug:"semaphores",normalizedTitle:"semaphores",charIndex:4311},{level:2,title:"死锁",slug:"死锁",normalizedTitle:"死锁",charIndex:4630},{level:2,title:"线程的状态",slug:"线程的状态",normalizedTitle:"线程的状态",charIndex:4682}],headersStr:"新建Thread与Task 线程池 线程同步 线程协助 Blocking Queue Semaphores 死锁 线程的状态",content:'# MultiThreading\n\n这是用来记录Java多线程编程相关内容的\n\n线程是什么呢？我觉得可以这样来表述吧：一个Program变成Process之后，系统分配了一定的资源。在一个process里头，可以有一或多个Thread即线程在里头跑。\n\n那么实际运行的时候，多条线程之间，是怎么跑起来的呢？如图\n\n线程这些东西一般都要在操作系统课程里面再深入学习了吧，那下面就开始记录java里面的多线程编程的基础概念了\n\n\n# 新建Thread与Task\n\nJava中有一个interface叫做Runnable，顾名思义就是用来表示Thread要执行的任务。而传入一个Runnable进入Thread，Thread在start()或者run()的时候就会invoke这个Runnable里面对应的run()方法啦。\n\n我们可以新建一个Runnable然后在其里头Override掉run()这个方法，也可以创建一个实现这个接口的类，更有甚者，还可以直接extend于Thread类（不推荐这个做法）\n\nThread类里头有一些方法要有个印象，也要对这个类里面一些Deprecated的方法进行规避，并了解原因。\n\n\n\n//TODO:为什么有一些方法如stop()被Deprecate了呢？\n\n对了，对于多线程编程，我觉得画图是一个挺好的方法，直接画几条线表示线程，有下面一些图还是挺实用的\n\n\n\n然后我用的教程的32.5小节就以jfx来示范了在特定线程下所执行的特定方法。（这跟安卓开发的UI thread有着异曲同工）（这个就不摘抄了，直接看书就行）\n\n\n# 线程池\n\n线程池的英语是Thread pool，顾名思义就是有一堆线程在里头的一个池子，我们可以用它来分配线程给不同的Task。\n\n\n# 线程同步\n\n多个线程同时操作一个数据，很容易使得这个数据corrupted（数据腐败？） 这个是使用了一个经典例子：银行存款或者是生产者消费者关系来举例。\n\npackage chapter32;\n\nimport java.util.concurrent.*;\n\npublic class AccountWithoutSync {\n    private static final Account account = new Account();\n\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        // Create and launch 100 threads\n        for (int i = 0; i < 100; i++) {\n            executor.execute(new AddAPennyTask());\n        }\n\n        executor.shutdown();\n\n        // Wait until all tasks are finished\n        while (!executor.isTerminated()) {\n        }\n\n        System.out.println("What is balance? " + account.getBalance());\n    }\n\n    // A thread for adding a penny to the account\n    private static class AddAPennyTask implements Runnable {\n        public void run() {\n            account.deposit(1);\n        }\n    }\n\n    // An inner class for account\n    private static class Account {\n        private int balance = 0;\n\n        public int getBalance() {\n            return balance;\n        }\n\n        public void deposit(int amount) {\n            int newBalance = balance + amount;\n            //balance += amount;\n\n            // This delay is deliberately added to magnify the\n            // data-corruption problem and make it easy to see.\n            try {\n                Thread.sleep(5);\n            }\n            catch (InterruptedException ignored) {\n            }\n\n            balance = newBalance;\n        }\n    }\n}\n\n\n其实上面的这段代码可能有如下的运行情况\n\n这种情况呢就是所谓的线程不安全啦，这个安全不安全的词语经常有见到，所以还是要了解一下的。(摘抄自原文) Obviously, the problem is that Task 1 and Task 2 are accessing a common resource in a way that causes a conflict. This is a common problem, known as a race condition, in multithreaded programs. A class is said to be thread-safe if an object of the class does not cause a race condition in the presence of multiple threads. As demonstrated in the preced- ing example, the Account class is not thread-safe.\n\n所以为了解决同时跑同一个代码块的情况，我们可以给他加上一个关键字synchronized来使一块代码或类线程同步。如下\n\npublic synchronized void deposit(int amount)\n\n\n代码运行起来就会像这样子了，实际原理是给对象配了把锁。只有拿到锁的线程才能对这个对象的对象方法进行访问（这句话可以理解为每个对象都有自己的唯一的一把锁，而这个锁可以apply在实例方法或者static方法上的） 结合上下文就可以知道，一个线程要想进入这块代码区域，就要拿下面代码的expr的锁，这锁没被其他线程拿走就自己拿了开始执行，执行完之后再释放。反之，就要等拿了锁的线程释放这把锁。\n\n使用是像下面这样子\n\nsynchronized (expr) {\n    statements;\n}\n\n\n这里的expr其实就是对象引用，account在这里就是指的class Account（实例锁）（也可以填入Account.class（类锁）或者this（this用的时候你要确定这个this指的是谁）)，也就是说account对象运行到这里的时候，都要拿锁，如果锁被其他同类拿了，就要等同类把lock给release掉\n\n但是，synchronized只是方便了我们的使用，其实这个线程同步的实质就是加了lock嘛，java里头也有Lock这个类，我们可以直接使用它。（前面的synchronized利用的是类或者一个对象上的锁，而这个类是直接新创建了一个Lock对象，这个对象实际就是一把锁）\n\n怎么用呢，先实例化一个static的Lock，然后在想要线程同步的代码块前后使用即可\n\nprivate static Lock lock = new ReentrantLock(); // Create a lock\n\nlock.lock(); // Acquire the lock\ntry {\n    int newBalance = balance + amount;\n\n    // This delay is deliberately added to magnify the\n    // data-corruption problem and make it easy to see.\n    Thread.sleep(5);\n\n    balance = newBalance;\n}\ncatch (InterruptedException ex) {\n}\nfinally {\n    lock.unlock(); // Release the lock\n}\n\n\n\n# 线程协助\n\n这里不讲位置了，主要是笔记，自己看的懂就行了。await()是让这条线程放掉锁，然后idle在那个代码处，等待其他地方传来的signal即是其他线程调用了signal() signalAll()\n\n英语就是Thread cooperate了吧，也可以叫做Thread coordinate\n\n就是从Lock对象里调用方法newCondition()来获得一个对应Lock对象的Condition\n\n下面是一个取款存款的操作，取款的话当然是不能透支啊，所以我们可以在取款和存款的两条线程里头，加入一个newDeposit条件来进行线程之间的沟通合作。\n\n详细的实现代码，请翻书到32.9小节那里。\n\n\n# Blocking Queue\n\n其实从刚刚的Condition那里，如果我们要判断一个队列是否满或空来控制存入取出的线程，就可以使用Condition来控制了。但，jvav官方就给了一些现成的东西。\n\n其实是从Collection Framework那边延伸出来的，只不过多了一些自己特有的method罢了。\n\n(...说白了就是一个容量有限的队列而已...)\n\n\n# Semaphores\n\n这翻译过来叫做信号塔...?算了还是用英语顶住吧。这个跟Lock是几乎一致的，但是它可以允许多个线程拿到锁进入（1~n个）。\n\nprivate static Semaphore semaphore = new Semaphore(1)\npublic void deposit(int amount) { \n    try {\n        semaphore.acquire();\n        //codes\n    } catch (InterruptedException ex) {\n\n    } finally {\n        semaphore.release();\n    }\n}\n\n\n\n# 死锁\n\nemm这个可以像学校的计算机导论说的进程要文件资源那样理解，（换个无非就是线程想要锁嘛\n\n\n# 线程的状态\n\n线程的状态大概可以分为五种吧：New Ready Running Blocked Finished\n\n先是一张图\n\n然后是解释\n\n> Tasks are executed in threads. Threads can be in one of the five states: New, Ready, Running, Blocked, or Finished (see Figure 32.25).\n> \n> When a thread is newly created, it enters the New state. After a thread is started by calling its start() method, it enters the Ready state. A ready thread is runnable but may not be running yet. The operating system has to allocate CPU time to it.\n> \n> When a ready thread begins executing, it enters the Running state. A running thread can enter the Ready state if its given CPU time expires or its yield() method is called.\n> \n> A thread can enter the Blocked state (i.e., become inactive) for several reasons. It may have invoked the join(), sleep(), or wait() method. It may be waiting for an I/O operation to finish. A blocked thread may be reactivated when the action inactivating it is reversed. For example, if a thread has been put to sleep and the sleep time has expired, the thread is reactivated and enters the Ready state. Finally, a thread is Finished if it completes the execution of its run() method.\n> \n> The isAlive() method is used to find out the state of a thread. It returns true if a thread is in the Ready, Blocked, or Running state; it returns false if a thread is new and has not started or if it is finished.\n> \n> The interrupt() method interrupts a thread in the following way: If a thread is currently in the Ready or Running state, its interrupted flag is set; if a thread is currently blocked, it is awakened and enters the Ready state, and a java.lang.InterruptedException is thrown.',normalizedContent:'# multithreading\n\n这是用来记录java多线程编程相关内容的\n\n线程是什么呢？我觉得可以这样来表述吧：一个program变成process之后，系统分配了一定的资源。在一个process里头，可以有一或多个thread即线程在里头跑。\n\n那么实际运行的时候，多条线程之间，是怎么跑起来的呢？如图\n\n线程这些东西一般都要在操作系统课程里面再深入学习了吧，那下面就开始记录java里面的多线程编程的基础概念了\n\n\n# 新建thread与task\n\njava中有一个interface叫做runnable，顾名思义就是用来表示thread要执行的任务。而传入一个runnable进入thread，thread在start()或者run()的时候就会invoke这个runnable里面对应的run()方法啦。\n\n我们可以新建一个runnable然后在其里头override掉run()这个方法，也可以创建一个实现这个接口的类，更有甚者，还可以直接extend于thread类（不推荐这个做法）\n\nthread类里头有一些方法要有个印象，也要对这个类里面一些deprecated的方法进行规避，并了解原因。\n\n\n\n//todo:为什么有一些方法如stop()被deprecate了呢？\n\n对了，对于多线程编程，我觉得画图是一个挺好的方法，直接画几条线表示线程，有下面一些图还是挺实用的\n\n\n\n然后我用的教程的32.5小节就以jfx来示范了在特定线程下所执行的特定方法。（这跟安卓开发的ui thread有着异曲同工）（这个就不摘抄了，直接看书就行）\n\n\n# 线程池\n\n线程池的英语是thread pool，顾名思义就是有一堆线程在里头的一个池子，我们可以用它来分配线程给不同的task。\n\n\n# 线程同步\n\n多个线程同时操作一个数据，很容易使得这个数据corrupted（数据腐败？） 这个是使用了一个经典例子：银行存款或者是生产者消费者关系来举例。\n\npackage chapter32;\n\nimport java.util.concurrent.*;\n\npublic class accountwithoutsync {\n    private static final account account = new account();\n\n    public static void main(string[] args) {\n        executorservice executor = executors.newcachedthreadpool();\n\n        // create and launch 100 threads\n        for (int i = 0; i < 100; i++) {\n            executor.execute(new addapennytask());\n        }\n\n        executor.shutdown();\n\n        // wait until all tasks are finished\n        while (!executor.isterminated()) {\n        }\n\n        system.out.println("what is balance? " + account.getbalance());\n    }\n\n    // a thread for adding a penny to the account\n    private static class addapennytask implements runnable {\n        public void run() {\n            account.deposit(1);\n        }\n    }\n\n    // an inner class for account\n    private static class account {\n        private int balance = 0;\n\n        public int getbalance() {\n            return balance;\n        }\n\n        public void deposit(int amount) {\n            int newbalance = balance + amount;\n            //balance += amount;\n\n            // this delay is deliberately added to magnify the\n            // data-corruption problem and make it easy to see.\n            try {\n                thread.sleep(5);\n            }\n            catch (interruptedexception ignored) {\n            }\n\n            balance = newbalance;\n        }\n    }\n}\n\n\n其实上面的这段代码可能有如下的运行情况\n\n这种情况呢就是所谓的线程不安全啦，这个安全不安全的词语经常有见到，所以还是要了解一下的。(摘抄自原文) obviously, the problem is that task 1 and task 2 are accessing a common resource in a way that causes a conflict. this is a common problem, known as a race condition, in multithreaded programs. a class is said to be thread-safe if an object of the class does not cause a race condition in the presence of multiple threads. as demonstrated in the preced- ing example, the account class is not thread-safe.\n\n所以为了解决同时跑同一个代码块的情况，我们可以给他加上一个关键字synchronized来使一块代码或类线程同步。如下\n\npublic synchronized void deposit(int amount)\n\n\n代码运行起来就会像这样子了，实际原理是给对象配了把锁。只有拿到锁的线程才能对这个对象的对象方法进行访问（这句话可以理解为每个对象都有自己的唯一的一把锁，而这个锁可以apply在实例方法或者static方法上的） 结合上下文就可以知道，一个线程要想进入这块代码区域，就要拿下面代码的expr的锁，这锁没被其他线程拿走就自己拿了开始执行，执行完之后再释放。反之，就要等拿了锁的线程释放这把锁。\n\n使用是像下面这样子\n\nsynchronized (expr) {\n    statements;\n}\n\n\n这里的expr其实就是对象引用，account在这里就是指的class account（实例锁）（也可以填入account.class（类锁）或者this（this用的时候你要确定这个this指的是谁）)，也就是说account对象运行到这里的时候，都要拿锁，如果锁被其他同类拿了，就要等同类把lock给release掉\n\n但是，synchronized只是方便了我们的使用，其实这个线程同步的实质就是加了lock嘛，java里头也有lock这个类，我们可以直接使用它。（前面的synchronized利用的是类或者一个对象上的锁，而这个类是直接新创建了一个lock对象，这个对象实际就是一把锁）\n\n怎么用呢，先实例化一个static的lock，然后在想要线程同步的代码块前后使用即可\n\nprivate static lock lock = new reentrantlock(); // create a lock\n\nlock.lock(); // acquire the lock\ntry {\n    int newbalance = balance + amount;\n\n    // this delay is deliberately added to magnify the\n    // data-corruption problem and make it easy to see.\n    thread.sleep(5);\n\n    balance = newbalance;\n}\ncatch (interruptedexception ex) {\n}\nfinally {\n    lock.unlock(); // release the lock\n}\n\n\n\n# 线程协助\n\n这里不讲位置了，主要是笔记，自己看的懂就行了。await()是让这条线程放掉锁，然后idle在那个代码处，等待其他地方传来的signal即是其他线程调用了signal() signalall()\n\n英语就是thread cooperate了吧，也可以叫做thread coordinate\n\n就是从lock对象里调用方法newcondition()来获得一个对应lock对象的condition\n\n下面是一个取款存款的操作，取款的话当然是不能透支啊，所以我们可以在取款和存款的两条线程里头，加入一个newdeposit条件来进行线程之间的沟通合作。\n\n详细的实现代码，请翻书到32.9小节那里。\n\n\n# blocking queue\n\n其实从刚刚的condition那里，如果我们要判断一个队列是否满或空来控制存入取出的线程，就可以使用condition来控制了。但，jvav官方就给了一些现成的东西。\n\n其实是从collection framework那边延伸出来的，只不过多了一些自己特有的method罢了。\n\n(...说白了就是一个容量有限的队列而已...)\n\n\n# semaphores\n\n这翻译过来叫做信号塔...?算了还是用英语顶住吧。这个跟lock是几乎一致的，但是它可以允许多个线程拿到锁进入（1~n个）。\n\nprivate static semaphore semaphore = new semaphore(1)\npublic void deposit(int amount) { \n    try {\n        semaphore.acquire();\n        //codes\n    } catch (interruptedexception ex) {\n\n    } finally {\n        semaphore.release();\n    }\n}\n\n\n\n# 死锁\n\nemm这个可以像学校的计算机导论说的进程要文件资源那样理解，（换个无非就是线程想要锁嘛\n\n\n# 线程的状态\n\n线程的状态大概可以分为五种吧：new ready running blocked finished\n\n先是一张图\n\n然后是解释\n\n> tasks are executed in threads. threads can be in one of the five states: new, ready, running, blocked, or finished (see figure 32.25).\n> \n> when a thread is newly created, it enters the new state. after a thread is started by calling its start() method, it enters the ready state. a ready thread is runnable but may not be running yet. the operating system has to allocate cpu time to it.\n> \n> when a ready thread begins executing, it enters the running state. a running thread can enter the ready state if its given cpu time expires or its yield() method is called.\n> \n> a thread can enter the blocked state (i.e., become inactive) for several reasons. it may have invoked the join(), sleep(), or wait() method. it may be waiting for an i/o operation to finish. a blocked thread may be reactivated when the action inactivating it is reversed. for example, if a thread has been put to sleep and the sleep time has expired, the thread is reactivated and enters the ready state. finally, a thread is finished if it completes the execution of its run() method.\n> \n> the isalive() method is used to find out the state of a thread. it returns true if a thread is in the ready, blocked, or running state; it returns false if a thread is new and has not started or if it is finished.\n> \n> the interrupt() method interrupts a thread in the following way: if a thread is currently in the ready or running state, its interrupted flag is set; if a thread is currently blocked, it is awakened and enters the ready state, and a java.lang.interruptedexception is thrown.',charsets:{cjk:!0}},{title:"Problems",frontmatter:{},regularPath:"/java/problems.html",relativePath:"java/problems.md",key:"v-b17c92ce",path:"/java/problems.html",headers:[{level:2,title:"新鲜句法",slug:"新鲜句法",normalizedTitle:"新鲜句法",charIndex:31},{level:2,title:"未见过的行为",slug:"未见过的行为",normalizedTitle:"未见过的行为",charIndex:41},{level:2,title:"迷惑行为",slug:"迷惑行为",normalizedTitle:"迷惑行为",charIndex:53},{level:2,title:"Lambda",slug:"lambda",normalizedTitle:"lambda",charIndex:63},{level:2,title:"自带API",slug:"自带api",normalizedTitle:"自带api",charIndex:75},{level:2,title:"恶臭之处",slug:"恶臭之处",normalizedTitle:"恶臭之处",charIndex:86},{level:2,title:"语言律师",slug:"语言律师",normalizedTitle:"语言律师",charIndex:96}],headersStr:"新鲜句法 未见过的行为 迷惑行为 Lambda 自带API 恶臭之处 语言律师",content:'# Problems\n\n\n\n * Problems\n   * 新鲜句法\n   * 未见过的行为\n   * 迷惑行为\n   * Lambda\n   * 自带API\n   * 恶臭之处\n   * 语言律师\n\n\n\n\n# 新鲜句法\n\n * Q: What is static blocks?\n\n> 这个问题是我在看到Integer.java源码之后，才想去了解下的。看Oracle里的doc，发现全称应该是叫做static initialization blocks。与此同时，对应地，也有initialization blocks。长这样子\n\n// they are both in a class body\nstatic {\n    // do something here\n}\n\n{\n    // do something here\n}\n\n\n> 前者是在class被加载的时候被调用，而后者是instantiation的时候被调用。因此前者可以用来初始化一些final field，后者可以处理新建对象后的事情(这样就不用把field初始化之类的事情写在constructor里了)。举个例子，如下\n\npublic class Example {\n    static class Foo {\n        {\n            String str = "instance initialization";\n            System.out.println(str.toUpperCase());\n        }\n        static {\n            String str = "static initialization";\n            System.out.println(str.toUpperCase());\n        }\n        Foo() {\n            System.out.println("CONSTRUCTOR");\n        }\n    }\n\n    public static void main(String[] args) {\n        Foo bar = new Foo();\n        Foo bar1 = new Foo();\n    }\n}\n/* OUTPUT\nSTATIC INITIALIZATION\nINSTANCE INITIALIZATION\nCONSTRUCTOR\nINSTANCE INITIALIZATION\nCONSTRUCTOR\n*/\n\n\n * Q: What is inner interface?\n\n> 其实这个呢，我觉得就是为了更好地控制类和接口访问权限的开与闭而已。由于Interface现在默认掉（但不建议加）public和static(仅限inner interface)的关键字了。因此，inner interface就是static的了，比如我们只希望在Foo类里头使用Bar接口，我们就可以这样写。如下，如果我们不在同一个package下，就不能访问到Example里头的Bar了\n\nclass Example {\n    static class Foo<T> {\n        @FunctionalInterface\n        interface Bar<T> {\n            void accept(T t);\n        }\n\n        void doBar(Bar<T> bar, T item) {\n            bar.accept(item);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Example.Foo<String>().doBar(System.out::println, "114514");\n    }\n}\n// 114514\n\n\n\n# 未见过的行为\n\n * Q: (泛型擦除)为什么俩type parameter不同的泛型类不一样?\n\n> 注意这个坑，擦除是compile后擦掉的，而如List<String>和List<Object>这两个在compile的时候，是属于不同类型的。在Runtime上，它们才是属于同一类型List（被擦了）\n> \n> 因此kotlin的Array<>也不能做到jvav中String[] a = new String[1];Object[] i = a;的操作（\n\n\n# 迷惑行为\n\nQ: 为什么javafx.scene.image.Image的relative url是相对于classpath的，而java.io.File的path url不是？\n\n> The Java IO API relies on the local disk file system, not on the classpath.\n> \n> Java.io的相对路径是根据此时的working directory来决定的\n\npackage test;\nimport java.io.File;\npublic class Test {\n    public static void main(String[] args) {\n        // Don\'t fiddle with relative paths in java.io.File. \n        // They are dependent on the current working directory over which you have totally no control from inside the Java code.\n        File file = new File("./test.dat");\n        System.out.println(file.getAbsolutePath());\n    }\n}\n\n\n比如这样，的确是根据工作目录来的。\n\nC:\\Users\\situ\\codes>java -cp C:\\Users\\situ\\codes\\experiment\\out\\production\\experiment test.Test\nC:\\Users\\situ\\codes\\test.dat\n\n\n而之前使用JavaFX，要读图只能放在classpath下。之前搞不懂，是因为我不知道classpath到底是个什么鬼，而现在我懂了。\n\n// The image is located in my.res package of the classpath\nImage image2 = new Image("my/res/flower.png");\n\n\n如果classpath是C:\\Users\\situ\\codes\\experiment\\out\\production\\experiment那么这个图片的绝对路径就是C:\\Users\\situ\\codes\\experiment\\out\\production\\experiment\\my\\res\\flower.png\n\n\n# Lambda\n\nMethod reference与Lambda expression的关系？详细了解Lambda表达式？为什么内部类只能访问final or effectively final的变量？\n\n> 详情请看博客：点击前往\n> \n> 这似乎跟内部实现有关，暂时先记住这个rule吧，以后有空再去慢慢摸清。\n> \n> 简的来说，方法引用就是把一个方法当成Lambda表达式。目前我有在用，用在abstract method或者interface method的实现上。其实这个method reference在内部似乎是交给了java.util.function package里的class来处理了（这个没有深究，以后补上！）\n> \n> 怎么判断一个method reference能不能被使用，首先看一下这个方法，static method的话，直接看header中的return type和signature中的parameter是否一致，比如int(int, int)的抽象类或接口方法就可以接受int(int, int)的method reference。那么对于对象方法，由于this会作为第一个参数传入。一个实例方法如int(String)可以被这样的方法：int(String, String)使用，因为这个实例方法的static样子就是int(this, String)即int(String, String)\n> \n> constructor也可以当成reference来传的，这个我没有研究过。\n\n\n# 自带API\n\n * split()方法\n\n竟然卡在String的split()方法里面了…不过这也证明了，我读文档的耐心程度还不够\n\n\n\n为什么会出现一个length为0的element呢…?想了想感觉是不是：因为是空格，所以直接把空格删掉，填个""上去充数了呢。结果读了文档才发现如下这么一段\n\nThe array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string.\n\n上面的这段话就是说，返回来的数组是包含着被原字符串中的子串所截断所产生的新String[]或因为没有符合的pattern而直接返回的包含一个原字符串的数组…所以，要认真一点读文档，避免错失关键信息。\n\n\n# 恶臭之处\n\n要注意，就Jvav的method没有默认参数值...\n\n\n# 语言律师\n\nprint一个对象不加toString()，在此之后不能用加号拼接一个非String？\n\n> 这个有点意思，我暂时还没有想到原因。\n\n会不会是因为当lhs和rhs都是一个没有加上.toString()方法的时候，就会很类似两个operand的manipulation。可能会产生歧义？（没有调查过）',normalizedContent:'# problems\n\n\n\n * problems\n   * 新鲜句法\n   * 未见过的行为\n   * 迷惑行为\n   * lambda\n   * 自带api\n   * 恶臭之处\n   * 语言律师\n\n\n\n\n# 新鲜句法\n\n * q: what is static blocks?\n\n> 这个问题是我在看到integer.java源码之后，才想去了解下的。看oracle里的doc，发现全称应该是叫做static initialization blocks。与此同时，对应地，也有initialization blocks。长这样子\n\n// they are both in a class body\nstatic {\n    // do something here\n}\n\n{\n    // do something here\n}\n\n\n> 前者是在class被加载的时候被调用，而后者是instantiation的时候被调用。因此前者可以用来初始化一些final field，后者可以处理新建对象后的事情(这样就不用把field初始化之类的事情写在constructor里了)。举个例子，如下\n\npublic class example {\n    static class foo {\n        {\n            string str = "instance initialization";\n            system.out.println(str.touppercase());\n        }\n        static {\n            string str = "static initialization";\n            system.out.println(str.touppercase());\n        }\n        foo() {\n            system.out.println("constructor");\n        }\n    }\n\n    public static void main(string[] args) {\n        foo bar = new foo();\n        foo bar1 = new foo();\n    }\n}\n/* output\nstatic initialization\ninstance initialization\nconstructor\ninstance initialization\nconstructor\n*/\n\n\n * q: what is inner interface?\n\n> 其实这个呢，我觉得就是为了更好地控制类和接口访问权限的开与闭而已。由于interface现在默认掉（但不建议加）public和static(仅限inner interface)的关键字了。因此，inner interface就是static的了，比如我们只希望在foo类里头使用bar接口，我们就可以这样写。如下，如果我们不在同一个package下，就不能访问到example里头的bar了\n\nclass example {\n    static class foo<t> {\n        @functionalinterface\n        interface bar<t> {\n            void accept(t t);\n        }\n\n        void dobar(bar<t> bar, t item) {\n            bar.accept(item);\n        }\n    }\n\n    public static void main(string[] args) {\n        new example.foo<string>().dobar(system.out::println, "114514");\n    }\n}\n// 114514\n\n\n\n# 未见过的行为\n\n * q: (泛型擦除)为什么俩type parameter不同的泛型类不一样?\n\n> 注意这个坑，擦除是compile后擦掉的，而如list<string>和list<object>这两个在compile的时候，是属于不同类型的。在runtime上，它们才是属于同一类型list（被擦了）\n> \n> 因此kotlin的array<>也不能做到jvav中string[] a = new string[1];object[] i = a;的操作（\n\n\n# 迷惑行为\n\nq: 为什么javafx.scene.image.image的relative url是相对于classpath的，而java.io.file的path url不是？\n\n> the java io api relies on the local disk file system, not on the classpath.\n> \n> java.io的相对路径是根据此时的working directory来决定的\n\npackage test;\nimport java.io.file;\npublic class test {\n    public static void main(string[] args) {\n        // don\'t fiddle with relative paths in java.io.file. \n        // they are dependent on the current working directory over which you have totally no control from inside the java code.\n        file file = new file("./test.dat");\n        system.out.println(file.getabsolutepath());\n    }\n}\n\n\n比如这样，的确是根据工作目录来的。\n\nc:\\users\\situ\\codes>java -cp c:\\users\\situ\\codes\\experiment\\out\\production\\experiment test.test\nc:\\users\\situ\\codes\\test.dat\n\n\n而之前使用javafx，要读图只能放在classpath下。之前搞不懂，是因为我不知道classpath到底是个什么鬼，而现在我懂了。\n\n// the image is located in my.res package of the classpath\nimage image2 = new image("my/res/flower.png");\n\n\n如果classpath是c:\\users\\situ\\codes\\experiment\\out\\production\\experiment那么这个图片的绝对路径就是c:\\users\\situ\\codes\\experiment\\out\\production\\experiment\\my\\res\\flower.png\n\n\n# lambda\n\nmethod reference与lambda expression的关系？详细了解lambda表达式？为什么内部类只能访问final or effectively final的变量？\n\n> 详情请看博客：点击前往\n> \n> 这似乎跟内部实现有关，暂时先记住这个rule吧，以后有空再去慢慢摸清。\n> \n> 简的来说，方法引用就是把一个方法当成lambda表达式。目前我有在用，用在abstract method或者interface method的实现上。其实这个method reference在内部似乎是交给了java.util.function package里的class来处理了（这个没有深究，以后补上！）\n> \n> 怎么判断一个method reference能不能被使用，首先看一下这个方法，static method的话，直接看header中的return type和signature中的parameter是否一致，比如int(int, int)的抽象类或接口方法就可以接受int(int, int)的method reference。那么对于对象方法，由于this会作为第一个参数传入。一个实例方法如int(string)可以被这样的方法：int(string, string)使用，因为这个实例方法的static样子就是int(this, string)即int(string, string)\n> \n> constructor也可以当成reference来传的，这个我没有研究过。\n\n\n# 自带api\n\n * split()方法\n\n竟然卡在string的split()方法里面了…不过这也证明了，我读文档的耐心程度还不够\n\n\n\n为什么会出现一个length为0的element呢…?想了想感觉是不是：因为是空格，所以直接把空格删掉，填个""上去充数了呢。结果读了文档才发现如下这么一段\n\nthe array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. the substrings in the array are in the order in which they occur in this string. if the expression does not match any part of the input then the resulting array has just one element, namely this string.\n\n上面的这段话就是说，返回来的数组是包含着被原字符串中的子串所截断所产生的新string[]或因为没有符合的pattern而直接返回的包含一个原字符串的数组…所以，要认真一点读文档，避免错失关键信息。\n\n\n# 恶臭之处\n\n要注意，就jvav的method没有默认参数值...\n\n\n# 语言律师\n\nprint一个对象不加tostring()，在此之后不能用加号拼接一个非string？\n\n> 这个有点意思，我暂时还没有想到原因。\n\n会不会是因为当lhs和rhs都是一个没有加上.tostring()方法的时候，就会很类似两个operand的manipulation。可能会产生歧义？（没有调查过）',charsets:{cjk:!0}},{title:"JavaScript",frontmatter:{},regularPath:"/javascript/",relativePath:"javascript/README.md",key:"v-05a6f19c",path:"/javascript/",headersStr:null,content:"# JavaScript\n\n好文明",normalizedContent:"# javascript\n\n好文明",charsets:{cjk:!0}},{title:"Reflection",frontmatter:{},regularPath:"/java/reflection.html",relativePath:"java/reflection.md",key:"v-a3442b8e",path:"/java/reflection.html",headers:[{level:2,title:"Get Field",slug:"get-field",normalizedTitle:"get field",charIndex:311},{level:2,title:"Get Method",slug:"get-method",normalizedTitle:"get method",charIndex:2150},{level:2,title:"Object instantiation",slug:"object-instantiation",normalizedTitle:"object instantiation",charIndex:4126},{level:2,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:5010}],headersStr:"Get Field Get Method Object instantiation 动态代理",content:'# Reflection\n\n> Something that shows what something else is like, or that is a sign of a particular situation\n\n在java里，有这么一个神奇的Class类，它是在运行时动态加载的。\n\n比如，当JVM加载String类的时候，String.class就会被实例化为一个Class对象并加载进内存里。以后JVM新建String对象，执行String对象里头的method等，都从这个对象里头读。\n\n总的来说，一个Class对象里头有对应类的一切信息。通过Class实例来获取类的信息，这个操作，就叫做反射。\n\n\n# Get Field\n\n对于这个的获取，首先是这么几个主要方法: getField(String name), getFields(), getDeclaredField(String name)和getDeclaredFields()\n\n前两个是用来获取指定的Field，而后者获取所有的并返回一个Field[]\n\n比如我们可以通过这几个方法来读取一个class里面的field，不过要注意前两个方法不包含private，后面两个就包含除了父类之外的field。\n\n而对于一个Field对象，我们还可以通过对应方法来获取它的名字和field的类型，甚至还能获取Modifier，以用来鉴定是public还是private等。甚至还能获取一个确切实例里面所有field的值。private当然也不例外，能读取，也能修改（由于modifier只是为了封装数据而已，实际上这些数据都可以通过反射来获取，不过不建议，会破坏封装）\n\n上面的讨论都在下面的代码里头体现了。\n\npackage reflection;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\n\npublic class Reflection {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n        Class<?> clz = Bar.class;\n        Field[] fields = clz.getFields();\n        Arrays.stream(fields).forEach(System.out::println);\n        System.out.println(clz.getDeclaredField("mValue"));\n        System.out.println();\n\n        Field field = clz.getDeclaredField("mValue");\n        System.out.println(field.getName());\n        System.out.println(field.getType());\n        int modifier = field.getModifiers();\n        System.out.println("It is a " + Modifier.toString(modifier) + " field");\n        System.out.println();\n\n        Bar bar = new Bar("114514");\n        field.setAccessible(true);\n        Object o = field.get(bar);\n        System.out.println(o.toString());\n\n        field.set(bar, "dssq");\n        o = field.get(bar);\n        System.out.println(o.toString());\n    }\n}\n\nclass Foo {\n    public String key;\n}\n\nclass Bar extends Foo {\n    public int value;\n    private String mValue;\n\n    public Bar(String value) {\n        this.mValue = value;\n    }\n}\n\n\n输出结果\n\npublic int reflection.Bar.value\npublic java.lang.String reflection.Foo.key\nprivate java.lang.String reflection.Bar.mValue\n\nmValue\nclass java.lang.String\nIt is a private field\n\n114514\ndssq\n\n\n\n# Get Method\n\n也可以获取Method的，同理Field，获取Method的方法大同小异，连方法名都是类似的。\n\n反射获取的Method，也能获取其一切的一切信息。非常强大，\n\n> Interface Function<T, R>\n> \n> default <V> Function<T, V> andThen (Function<? super R, ? extends V> after)\n\n比如我们获取Function下的andThen的一些信息，并且invoke它。\n\npublic class Reflection {\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        Function<Integer, Integer> f = x -> x * x;\n        Class<?> klass = Function.class;\n\n        var typeParameter = klass.getTypeParameters();\n        System.out.println("Class type parameters: " + Arrays.toString(typeParameter)); // get class generic type parameters\n\n        var method = klass.getMethod("andThen", Function.class); // get method\n        var name = "Method name: " + method.getName();\n        System.out.println(name);\n\n        var modifier = method.getModifiers();\n        System.out.println("It is a " + Modifier.toString(modifier) + " method");\n\n        System.out.print("Parameter of the method: ");\n        Arrays.stream(method.getParameters()).forEach(parameter -> System.out.print(parameter.toString() + " ")); // get parameters\' name\n        System.out.println();\n\n        System.out.print("Type parameter of the method: ");\n        Arrays.stream(method.getTypeParameters()).forEach(methodTypeVariable -> System.out.print(methodTypeVariable.getName() +" "));\n        System.out.println();\n\n        System.out.println("Returning: " + method.getGenericReturnType().getTypeName());\n\n        var composedFunction = method.invoke(f, f); // get a composed function\n        var result = ((Function<Integer, Integer>) composedFunction).apply(2);\n        System.out.println("Result: " + result);\n    }\n}\n\n\n输出\n\nClass type parameters: [T, R]\nMethod name: andThen\nIt is a public method\nParameter of the method: java.util.function.Function<? super R, ? extends V> arg0 \nType parameter of the method: V \nReturning: java.util.function.Function<T, V>\nResult: 16\n\n\n\n# Object instantiation\n\n同理，像获取Method一样获取Constructor，并可以进行调用来new一个对象。\n\npublic class Reflection {\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        Class<?> klass = Foo.class;\n        var foo = klass.getDeclaredConstructor().newInstance();\n        var privateConstructor = klass.getDeclaredConstructor(String[].class);\n        privateConstructor.setAccessible(true);\n        privateConstructor.newInstance((Object) new String[]{"114", "514"});\n    }\n}\n\nclass Foo {\n    Foo() {\n        System.out.println("Non-arg constructor");\n    }\n\n    private Foo(String... args) {\n        System.out.print("Private constructor with args: ");\n        Arrays.stream(args).forEach(arg -> System.out.print(arg + " "));\n    }\n}\n\n\n输出\n\nNon-arg constructor\nPrivate constructor with args: 114 514\n\n\n\n# 动态代理\n\n待更...',normalizedContent:'# reflection\n\n> something that shows what something else is like, or that is a sign of a particular situation\n\n在java里，有这么一个神奇的class类，它是在运行时动态加载的。\n\n比如，当jvm加载string类的时候，string.class就会被实例化为一个class对象并加载进内存里。以后jvm新建string对象，执行string对象里头的method等，都从这个对象里头读。\n\n总的来说，一个class对象里头有对应类的一切信息。通过class实例来获取类的信息，这个操作，就叫做反射。\n\n\n# get field\n\n对于这个的获取，首先是这么几个主要方法: getfield(string name), getfields(), getdeclaredfield(string name)和getdeclaredfields()\n\n前两个是用来获取指定的field，而后者获取所有的并返回一个field[]\n\n比如我们可以通过这几个方法来读取一个class里面的field，不过要注意前两个方法不包含private，后面两个就包含除了父类之外的field。\n\n而对于一个field对象，我们还可以通过对应方法来获取它的名字和field的类型，甚至还能获取modifier，以用来鉴定是public还是private等。甚至还能获取一个确切实例里面所有field的值。private当然也不例外，能读取，也能修改（由于modifier只是为了封装数据而已，实际上这些数据都可以通过反射来获取，不过不建议，会破坏封装）\n\n上面的讨论都在下面的代码里头体现了。\n\npackage reflection;\n\nimport java.lang.reflect.field;\nimport java.lang.reflect.modifier;\nimport java.util.arrays;\n\npublic class reflection {\n    public static void main(string[] args) throws nosuchfieldexception, illegalaccessexception {\n        class<?> clz = bar.class;\n        field[] fields = clz.getfields();\n        arrays.stream(fields).foreach(system.out::println);\n        system.out.println(clz.getdeclaredfield("mvalue"));\n        system.out.println();\n\n        field field = clz.getdeclaredfield("mvalue");\n        system.out.println(field.getname());\n        system.out.println(field.gettype());\n        int modifier = field.getmodifiers();\n        system.out.println("it is a " + modifier.tostring(modifier) + " field");\n        system.out.println();\n\n        bar bar = new bar("114514");\n        field.setaccessible(true);\n        object o = field.get(bar);\n        system.out.println(o.tostring());\n\n        field.set(bar, "dssq");\n        o = field.get(bar);\n        system.out.println(o.tostring());\n    }\n}\n\nclass foo {\n    public string key;\n}\n\nclass bar extends foo {\n    public int value;\n    private string mvalue;\n\n    public bar(string value) {\n        this.mvalue = value;\n    }\n}\n\n\n输出结果\n\npublic int reflection.bar.value\npublic java.lang.string reflection.foo.key\nprivate java.lang.string reflection.bar.mvalue\n\nmvalue\nclass java.lang.string\nit is a private field\n\n114514\ndssq\n\n\n\n# get method\n\n也可以获取method的，同理field，获取method的方法大同小异，连方法名都是类似的。\n\n反射获取的method，也能获取其一切的一切信息。非常强大，\n\n> interface function<t, r>\n> \n> default <v> function<t, v> andthen (function<? super r, ? extends v> after)\n\n比如我们获取function下的andthen的一些信息，并且invoke它。\n\npublic class reflection {\n    public static void main(string[] args) throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n        function<integer, integer> f = x -> x * x;\n        class<?> klass = function.class;\n\n        var typeparameter = klass.gettypeparameters();\n        system.out.println("class type parameters: " + arrays.tostring(typeparameter)); // get class generic type parameters\n\n        var method = klass.getmethod("andthen", function.class); // get method\n        var name = "method name: " + method.getname();\n        system.out.println(name);\n\n        var modifier = method.getmodifiers();\n        system.out.println("it is a " + modifier.tostring(modifier) + " method");\n\n        system.out.print("parameter of the method: ");\n        arrays.stream(method.getparameters()).foreach(parameter -> system.out.print(parameter.tostring() + " ")); // get parameters\' name\n        system.out.println();\n\n        system.out.print("type parameter of the method: ");\n        arrays.stream(method.gettypeparameters()).foreach(methodtypevariable -> system.out.print(methodtypevariable.getname() +" "));\n        system.out.println();\n\n        system.out.println("returning: " + method.getgenericreturntype().gettypename());\n\n        var composedfunction = method.invoke(f, f); // get a composed function\n        var result = ((function<integer, integer>) composedfunction).apply(2);\n        system.out.println("result: " + result);\n    }\n}\n\n\n输出\n\nclass type parameters: [t, r]\nmethod name: andthen\nit is a public method\nparameter of the method: java.util.function.function<? super r, ? extends v> arg0 \ntype parameter of the method: v \nreturning: java.util.function.function<t, v>\nresult: 16\n\n\n\n# object instantiation\n\n同理，像获取method一样获取constructor，并可以进行调用来new一个对象。\n\npublic class reflection {\n    public static void main(string[] args) throws illegalaccessexception, instantiationexception, nosuchmethodexception, invocationtargetexception {\n        class<?> klass = foo.class;\n        var foo = klass.getdeclaredconstructor().newinstance();\n        var privateconstructor = klass.getdeclaredconstructor(string[].class);\n        privateconstructor.setaccessible(true);\n        privateconstructor.newinstance((object) new string[]{"114", "514"});\n    }\n}\n\nclass foo {\n    foo() {\n        system.out.println("non-arg constructor");\n    }\n\n    private foo(string... args) {\n        system.out.print("private constructor with args: ");\n        arrays.stream(args).foreach(arg -> system.out.print(arg + " "));\n    }\n}\n\n\n输出\n\nnon-arg constructor\nprivate constructor with args: 114 514\n\n\n\n# 动态代理\n\n待更...',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/javascript/context_scope.html",relativePath:"javascript/context_scope.md",key:"v-4ee647e1",path:"/javascript/context_scope.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Background",frontmatter:{},regularPath:"/javascript/background.html",relativePath:"javascript/background.md",key:"v-663bdb0e",path:"/javascript/background.html",headers:[{level:2,title:"ES",slug:"es",normalizedTitle:"es",charIndex:25},{level:2,title:"JavaScript",slug:"javascript",normalizedTitle:"javascript",charIndex:229},{level:3,title:"一些方法的命名",slug:"一些方法的命名",normalizedTitle:"一些方法的命名",charIndex:785},{level:3,title:"几个JS",slug:"几个js",normalizedTitle:"几个js",charIndex:956},{level:3,title:"Paradigm",slug:"paradigm",normalizedTitle:"paradigm",charIndex:1653},{level:3,title:"解释or编译",slug:"解释or编译",normalizedTitle:"解释or编译",charIndex:1810},{level:2,title:"Backward compatible",slug:"backward-compatible",normalizedTitle:"backward compatible",charIndex:2157},{level:3,title:"BabelJS",slug:"babeljs",normalizedTitle:"babeljs",charIndex:2404},{level:3,title:"polyfill",slug:"polyfill",normalizedTitle:"polyfill",charIndex:2673},{level:2,title:"WASM",slug:"wasm",normalizedTitle:"wasm",charIndex:3330}],headersStr:"ES JavaScript 一些方法的命名 几个JS Paradigm 解释or编译 Backward compatible BabelJS polyfill WASM",content:"# Background\n\n一些背景知识\n\n\n# ES\n\n> ES -- The abbreviation of ECMAScript\n> \n> ECMA -- European Computer Manufacturers Association\n\nES6也叫做ES2015，是ES中的一个新版本，是现在JS的下一个迭代版本了，加入了许多的新特性。是在2015年出来的，当然现在还在不断更新着（命名方式是以年为后缀：ES2016 2017...）\n\n\n# JavaScript\n\n> JS's syntax and behavior are defined in the ES specification.\n\nJavaScript是ECMAScript的一个实现，具体syntax与行为，都定义在ES spec里了:https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n\n而ECMAScript standard由TC39 committee来指导\n\n> Their primary task is managing the official specification for the language. They meet regularly to vote on any agreed changes, which they then submit to ECMA, the standards organization.\n\nTS39的一些proposal都可以在这里找到: https://github.com/tc39/proposals\n\nJS可以运行在Browsers里头，也可以在其他environment上运行，比如Node.js\n\n\n# 一些方法的命名\n\n是Array.prototype.includes而不是Array.prototype.contains，又如是Array.prototype.flat而不是Array.prototype.flatten。是因为有一些第三库有这样的方法，所以为了不破坏现有网页内容，TS39就这样命名了。可以参见smoosh门事件\n\n\n# 几个JS\n\n> Contrary to some established and frustratingly perpetuated myth, there are not multiple versions of JavaScript in the wild. There's just one JS, the official standard as maintained by TC39 and ECMA.\n\n就一个...真的就只有一个JS啊...\n\n在浏览器上面呢？\n\nWeb browser上面的，包含了JS+DOM+BOM。\n\n不同环境下（比如浏览器，nodejs）的JS加了一些自己的API进去，就比如alert()和console.log和console.*，又或者fs.write()（来自nodejs的built-in module）这些方法，其实是没有在JS官方spec里头定义的。\n\n哦还有console只是为了方便做点调试而已。不要完全相信在F12 console里面出现的行为啊。\n\n> Don't trust what behavior you see in a developer console as representing exact to-the-letter JS semantics; for that, read the specification. Instead, think of the console as a \"JS-friendly\" environment. That's useful in its own right.\n\n\n# Paradigm\n\n> Paradigm is a board mindset and approach to structuring the codes\n\nJS是一门多范式语言，其代码可以由以下几个范式混编\n\n 1. Procedural style\n 2. OO style\n 3. FP style\n\n\n# 解释or编译\n\nJS到底是解释性语言呢还是编译性语言呢？解释性语言执行的时候会一行一行地运行，碰到错误就会停止。比如，第十行的错误不会在执行到它的时候抛出。\n\n不像一些动态语言如Python。JS是一门编译性语言。这样做可以提高执行的效率，也可以在执行前就能detect到大多数error\n\n编译的大致过程如下\n\n\n\n 1. 代码经过Babel之类的transpiler和Webpack这些打包工具（或者不经过），产生的代码交给JS引擎\n 2. JS引擎将这些代码转化为AST(Abstract Syntax Tree)\n 3. 引擎将AST转化为byte code，然后再被JIT(Just-In-Time) compiler优化/转化\n 4. JS VM执行这些byte code\n\n\n# Backward compatible\n\n这意味着就一旦一个特性被定下后，以后就不会被移除了，以确保老旧的代码能在最新引擎中跑起来。\n\n与之相反的是Forward Compatible，就像是HTML和CSS那样——加了新特性，但是代码却能在老版本浏览器中跑，那是因为新特性被忽略了，只处理该浏览器版本支持的特性（\n\nJS本身不支持这个，这意味着新的syntax和新的API不能在旧版本的引擎上面跑。\n\n----------------------------------------\n\n\n# BabelJS\n\n虽然JS不支持Forward Compatible，但是我们写的含新syntax的代码依旧能在浏览器上面跑\n\n举个例子：由于ES5还在浏览器上面使用，因此BabelJS用来作为在浏览器中ES5与ES2015之间转换的桥梁(ES2015 to ES5)。所以你可以在浏览器上面愉悦地使用ES2015，实际上就是通过BabelJS将ES2015的代码转换到了ES5\n\n对于这种转化，我们称之为transpiling。Babel就是一个transpiler，用来将新ES标准的syntax，转化为等效的老syntax\n\n\n# polyfill\n\n那一些新的API怎么办呢？怎么使这些代码能有前置兼容性呢？那就检查是否有这个API，没有的话就直接定义一个咯，这就是polyfill\n\n比如ES2019才加入的Promise.prototype.finally，它的一个简单的polyfill的就像是下面这样的(摘自YDKJSY)\n\nif (!Promise.prototype.finally) {\n    Promise.prototype.finally = function f(fn){\n        return this.then(\n            function t(v){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        return v;\n                    });\n            },\n            function c(e){\n                return Promise.resolve( fn() )\n                    .then(function t(){\n                        throw e;\n                    });\n            }\n        );\n    };\n}\n\n\n\n# WASM\n\n> Web Assembly\n\n简略记录。大致的，就是将其他语言写的代码转化为ASM.js，从而使得代码能够在JS引擎上面跑。",normalizedContent:"# background\n\n一些背景知识\n\n\n# es\n\n> es -- the abbreviation of ecmascript\n> \n> ecma -- european computer manufacturers association\n\nes6也叫做es2015，是es中的一个新版本，是现在js的下一个迭代版本了，加入了许多的新特性。是在2015年出来的，当然现在还在不断更新着（命名方式是以年为后缀：es2016 2017...）\n\n\n# javascript\n\n> js's syntax and behavior are defined in the es specification.\n\njavascript是ecmascript的一个实现，具体syntax与行为，都定义在es spec里了:https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n\n而ecmascript standard由tc39 committee来指导\n\n> their primary task is managing the official specification for the language. they meet regularly to vote on any agreed changes, which they then submit to ecma, the standards organization.\n\nts39的一些proposal都可以在这里找到: https://github.com/tc39/proposals\n\njs可以运行在browsers里头，也可以在其他environment上运行，比如node.js\n\n\n# 一些方法的命名\n\n是array.prototype.includes而不是array.prototype.contains，又如是array.prototype.flat而不是array.prototype.flatten。是因为有一些第三库有这样的方法，所以为了不破坏现有网页内容，ts39就这样命名了。可以参见smoosh门事件\n\n\n# 几个js\n\n> contrary to some established and frustratingly perpetuated myth, there are not multiple versions of javascript in the wild. there's just one js, the official standard as maintained by tc39 and ecma.\n\n就一个...真的就只有一个js啊...\n\n在浏览器上面呢？\n\nweb browser上面的，包含了js+dom+bom。\n\n不同环境下（比如浏览器，nodejs）的js加了一些自己的api进去，就比如alert()和console.log和console.*，又或者fs.write()（来自nodejs的built-in module）这些方法，其实是没有在js官方spec里头定义的。\n\n哦还有console只是为了方便做点调试而已。不要完全相信在f12 console里面出现的行为啊。\n\n> don't trust what behavior you see in a developer console as representing exact to-the-letter js semantics; for that, read the specification. instead, think of the console as a \"js-friendly\" environment. that's useful in its own right.\n\n\n# paradigm\n\n> paradigm is a board mindset and approach to structuring the codes\n\njs是一门多范式语言，其代码可以由以下几个范式混编\n\n 1. procedural style\n 2. oo style\n 3. fp style\n\n\n# 解释or编译\n\njs到底是解释性语言呢还是编译性语言呢？解释性语言执行的时候会一行一行地运行，碰到错误就会停止。比如，第十行的错误不会在执行到它的时候抛出。\n\n不像一些动态语言如python。js是一门编译性语言。这样做可以提高执行的效率，也可以在执行前就能detect到大多数error\n\n编译的大致过程如下\n\n\n\n 1. 代码经过babel之类的transpiler和webpack这些打包工具（或者不经过），产生的代码交给js引擎\n 2. js引擎将这些代码转化为ast(abstract syntax tree)\n 3. 引擎将ast转化为byte code，然后再被jit(just-in-time) compiler优化/转化\n 4. js vm执行这些byte code\n\n\n# backward compatible\n\n这意味着就一旦一个特性被定下后，以后就不会被移除了，以确保老旧的代码能在最新引擎中跑起来。\n\n与之相反的是forward compatible，就像是html和css那样——加了新特性，但是代码却能在老版本浏览器中跑，那是因为新特性被忽略了，只处理该浏览器版本支持的特性（\n\njs本身不支持这个，这意味着新的syntax和新的api不能在旧版本的引擎上面跑。\n\n----------------------------------------\n\n\n# babeljs\n\n虽然js不支持forward compatible，但是我们写的含新syntax的代码依旧能在浏览器上面跑\n\n举个例子：由于es5还在浏览器上面使用，因此babeljs用来作为在浏览器中es5与es2015之间转换的桥梁(es2015 to es5)。所以你可以在浏览器上面愉悦地使用es2015，实际上就是通过babeljs将es2015的代码转换到了es5\n\n对于这种转化，我们称之为transpiling。babel就是一个transpiler，用来将新es标准的syntax，转化为等效的老syntax\n\n\n# polyfill\n\n那一些新的api怎么办呢？怎么使这些代码能有前置兼容性呢？那就检查是否有这个api，没有的话就直接定义一个咯，这就是polyfill\n\n比如es2019才加入的promise.prototype.finally，它的一个简单的polyfill的就像是下面这样的(摘自ydkjsy)\n\nif (!promise.prototype.finally) {\n    promise.prototype.finally = function f(fn){\n        return this.then(\n            function t(v){\n                return promise.resolve( fn() )\n                    .then(function t(){\n                        return v;\n                    });\n            },\n            function c(e){\n                return promise.resolve( fn() )\n                    .then(function t(){\n                        throw e;\n                    });\n            }\n        );\n    };\n}\n\n\n\n# wasm\n\n> web assembly\n\n简略记录。大致的，就是将其他语言写的代码转化为asm.js，从而使得代码能够在js引擎上面跑。",charsets:{cjk:!0}},{title:"Built-in Objects",frontmatter:{},regularPath:"/javascript/built_in_object.html",relativePath:"javascript/built_in_object.md",key:"v-e3ce978e",path:"/javascript/built_in_object.html",headers:[{level:2,title:"String",slug:"string",normalizedTitle:"string",charIndex:23},{level:3,title:"Retrieve a char",slug:"retrieve-a-char",normalizedTitle:"retrieve a char",charIndex:34},{level:3,title:"indexOf",slug:"indexof",normalizedTitle:"indexof",charIndex:100},{level:3,title:"slice",slug:"slice",normalizedTitle:"slice",charIndex:300},{level:2,title:"大小写",slug:"大小写",normalizedTitle:"大小写",charIndex:463},{level:3,title:"replace",slug:"replace",normalizedTitle:"replace",charIndex:508},{level:3,title:"To Arrays",slug:"to-arrays",normalizedTitle:"to arrays",charIndex:682},{level:2,title:"Arrays",slug:"arrays",normalizedTitle:"arrays",charIndex:685},{level:3,title:"添加删除元素",slug:"添加删除元素",normalizedTitle:"添加删除元素",charIndex:915},{level:2,title:"Number",slug:"number",normalizedTitle:"number",charIndex:1011},{level:3,title:"toFixed",slug:"tofixed",normalizedTitle:"tofixed",charIndex:1092},{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:1239},{level:2,title:"WeakSet",slug:"weakset",normalizedTitle:"weakset",charIndex:1477}],headersStr:"String Retrieve a char indexOf slice 大小写 replace To Arrays Arrays 添加删除元素 Number toFixed Set WeakSet",content:"# Built-in Objects\n\n\n# String\n\n\n# Retrieve a char\n\nlet str = 'dssq';\nconsole.log(str[2]); // s\n\n\n\n# indexOf\n\nReturn the starting position of the substring in a string. If the substring is not found in the string, -1 will be returned.\n\nlet str = 'situ2001';\nlet index = str.indexOf('2001'); // 4\n\n\n\n# slice\n\n把substring切出来，但是要注意是，左闭右开：(inclusive, exclusive)\n\nlet str = 'situ2001';\nlet substring = str.slice(0,4); // situ\nlet substring1 = str.slice(4); // 2001\n\n\n\n# 大小写\n\n方法名都一样: toLowerCase and toUpperCase\n\n\n# replace\n\nDo replacement and return a new string.\n\nlet str = 'situ2001';\nstr.replace('2001', '2021'); // replace 2001 with 2021, result: situ2021\n\n\n也可以replace(regex, str)\n\n\n# To Arrays\n\nJust use the method split\n\nlet myData = 'Manchester,London,Liverpool,Birmingham,Leeds,Carlisle';\nlet myArray = myData.split(',');\n// [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n\n\n\n# Arrays\n\n\n# 添加删除元素\n\n\n\nlet a = [23, 45, 12, 67];\na.unshift(34);\nconsole.log(a); // [34, 23, 45, 12, 67]\n\n\n\n# Number\n\n将字符串等转换为数字\n\nlet i = '114514';\ni = Number(i);\n\n\n弱类型: 1 / 2 = 0.5，而不是1\n\n\n# toFixed\n\n固定小数位位数\n\nlet lotsOfDecimal = 1.766584958675746364;\nlotsOfDecimal;\nlet twoDecimalPlaces = lotsOfDecimal.toFixed(2);\ntwoDecimalPlaces;\n\n\n\n# Set\n\n集合，很常见的。不过特殊的是，js里头的集合，可以装primitive和object\n\n> Set objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the Set may only occur once; it is unique in the Set's collection.\n\n\n# WeakSet\n\nweak在哪里呢？\n\n> The WeakSet is weak, meaning references to objects in a WeakSet are held weakly.\n\n这意味着只能存object，一但里面存放的对象没有被任何一个变量所引用，那么它就会被垃圾回收掉。",normalizedContent:"# built-in objects\n\n\n# string\n\n\n# retrieve a char\n\nlet str = 'dssq';\nconsole.log(str[2]); // s\n\n\n\n# indexof\n\nreturn the starting position of the substring in a string. if the substring is not found in the string, -1 will be returned.\n\nlet str = 'situ2001';\nlet index = str.indexof('2001'); // 4\n\n\n\n# slice\n\n把substring切出来，但是要注意是，左闭右开：(inclusive, exclusive)\n\nlet str = 'situ2001';\nlet substring = str.slice(0,4); // situ\nlet substring1 = str.slice(4); // 2001\n\n\n\n# 大小写\n\n方法名都一样: tolowercase and touppercase\n\n\n# replace\n\ndo replacement and return a new string.\n\nlet str = 'situ2001';\nstr.replace('2001', '2021'); // replace 2001 with 2021, result: situ2021\n\n\n也可以replace(regex, str)\n\n\n# to arrays\n\njust use the method split\n\nlet mydata = 'manchester,london,liverpool,birmingham,leeds,carlisle';\nlet myarray = mydata.split(',');\n// [\"manchester\", \"london\", \"liverpool\", \"birmingham\", \"leeds\", \"carlisle\"]\n\n\n\n# arrays\n\n\n# 添加删除元素\n\n\n\nlet a = [23, 45, 12, 67];\na.unshift(34);\nconsole.log(a); // [34, 23, 45, 12, 67]\n\n\n\n# number\n\n将字符串等转换为数字\n\nlet i = '114514';\ni = number(i);\n\n\n弱类型: 1 / 2 = 0.5，而不是1\n\n\n# tofixed\n\n固定小数位位数\n\nlet lotsofdecimal = 1.766584958675746364;\nlotsofdecimal;\nlet twodecimalplaces = lotsofdecimal.tofixed(2);\ntwodecimalplaces;\n\n\n\n# set\n\n集合，很常见的。不过特殊的是，js里头的集合，可以装primitive和object\n\n> set objects are collections of values. you can iterate through the elements of a set in insertion order. a value in the set may only occur once; it is unique in the set's collection.\n\n\n# weakset\n\nweak在哪里呢？\n\n> the weakset is weak, meaning references to objects in a weakset are held weakly.\n\n这意味着只能存object，一但里面存放的对象没有被任何一个变量所引用，那么它就会被垃圾回收掉。",charsets:{cjk:!0}},{title:"Class & Module",frontmatter:{},regularPath:"/javascript/class_and_module.html",relativePath:"javascript/class_and_module.md",key:"v-ee3428ce",path:"/javascript/class_and_module.html",headers:[{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:2},{level:3,title:"Basis",slug:"basis",normalizedTitle:"basis",charIndex:133},{level:2,title:"Module",slug:"module",normalizedTitle:"module",charIndex:10},{level:3,title:"Classical",slug:"classical",normalizedTitle:"classical",charIndex:284},{level:3,title:"ES module",slug:"es-module",normalizedTitle:"es module",charIndex:1173}],headersStr:"Class Basis Module Classical ES module",content:"# Class & Module\n\n\n# Class\n\n函数在JS中，有许许多多的形式。比如说ES6加进来的class\n\nclass Foo {}\ntypeof Foo // \"function\"\n\n\n最好是与ES6之前的一样写法进行比较 -> 文章咕咕中\n\n\n# Basis\n\nclass Bar {}\nclass Foo extends Bar {}\n\n\n\n# Module\n\nmodule和class这两者，在本质上，是差不多的：都是把数据和行为给封装到一个逻辑单元上去。并可以控制外部对内部成员的访问权限。\n\n只不过这两者的syntax有较大的不同。\n\n\n# Classical\n\n读过The good part这本书，基本的模块是像这样的。\n\nlet Foo = function(number, comment) {\n    var publicObject = {\n        print() {\n            console.log(`No.${number}, comment is ${comment}`);\n        },\n        reset(newNumber) {\n            if (typeof number === 'number') {\n                number = newNumber;\n            }\n        }\n    }\n\n    return publicObject;\n};\n\nlet Bar = function(number, comment, name) {\n    var father = Foo(number, comment);\n\n    var publicObject = {\n        print() {\n            father.print();\n            console.log(`Commenter: ${name}\\n`);\n        },\n        reset(newNumber) {\n            father.reset(newNumber);\n        }\n    }\n    \n    return publicObject;\n}\n\nlet t = Bar(114514, 'dssq', 'senpai');\nt.print();\nt.reset(1919810);\nt.print();\n\n/*\nNo.114514, comment is dssq\nCommenter: senpai\n\nNo.1919810, comment is dssq\nCommenter: senpai\n*/\n\n\n这里利用的是闭包\n\n\n# ES module\n\n自ES6开始引入的。思想跟上面的都差不多，只不过实现有较大的不同。\n\n一般来说，常见的ES module有AMD(Asynchronous Method Definition), UMD(Universal Method Definition), CommonJS(Classical Node.js-style modules)\n\n这里不再像上面那样，使用一个函数来封装一个模块，ES模块是file-based的，它的context是整个文件：一个文件即一个模块\n\n上面的传统JS module写法，可以这样\n\n// in module file 'test.js'\nexport function Foo(number, comment) { /* ... */};\n\n\n我们可以使用以下syntax来import\n\n// in other file\nimport Foo from \"test.js\"; // or\nimport { Foo as createFoo } from \"test.js\"; // or\nimport * as test from \"test.js\";\n\n\n并且，一个模块就是一个实例，这个规则可以应用至单例(Singleton)设计模式中去。\n\n这意为着你在模块里面写好数据和方法之后，只需要export要暴露的成员就行了。例如\n\nlet a = 1;\nlet b = 2;\nlet c = 9;\nexport let i = 114514;\nexport { a, b };\nexport default c;\n",normalizedContent:"# class & module\n\n\n# class\n\n函数在js中，有许许多多的形式。比如说es6加进来的class\n\nclass foo {}\ntypeof foo // \"function\"\n\n\n最好是与es6之前的一样写法进行比较 -> 文章咕咕中\n\n\n# basis\n\nclass bar {}\nclass foo extends bar {}\n\n\n\n# module\n\nmodule和class这两者，在本质上，是差不多的：都是把数据和行为给封装到一个逻辑单元上去。并可以控制外部对内部成员的访问权限。\n\n只不过这两者的syntax有较大的不同。\n\n\n# classical\n\n读过the good part这本书，基本的模块是像这样的。\n\nlet foo = function(number, comment) {\n    var publicobject = {\n        print() {\n            console.log(`no.${number}, comment is ${comment}`);\n        },\n        reset(newnumber) {\n            if (typeof number === 'number') {\n                number = newnumber;\n            }\n        }\n    }\n\n    return publicobject;\n};\n\nlet bar = function(number, comment, name) {\n    var father = foo(number, comment);\n\n    var publicobject = {\n        print() {\n            father.print();\n            console.log(`commenter: ${name}\\n`);\n        },\n        reset(newnumber) {\n            father.reset(newnumber);\n        }\n    }\n    \n    return publicobject;\n}\n\nlet t = bar(114514, 'dssq', 'senpai');\nt.print();\nt.reset(1919810);\nt.print();\n\n/*\nno.114514, comment is dssq\ncommenter: senpai\n\nno.1919810, comment is dssq\ncommenter: senpai\n*/\n\n\n这里利用的是闭包\n\n\n# es module\n\n自es6开始引入的。思想跟上面的都差不多，只不过实现有较大的不同。\n\n一般来说，常见的es module有amd(asynchronous method definition), umd(universal method definition), commonjs(classical node.js-style modules)\n\n这里不再像上面那样，使用一个函数来封装一个模块，es模块是file-based的，它的context是整个文件：一个文件即一个模块\n\n上面的传统js module写法，可以这样\n\n// in module file 'test.js'\nexport function foo(number, comment) { /* ... */};\n\n\n我们可以使用以下syntax来import\n\n// in other file\nimport foo from \"test.js\"; // or\nimport { foo as createfoo } from \"test.js\"; // or\nimport * as test from \"test.js\";\n\n\n并且，一个模块就是一个实例，这个规则可以应用至单例(singleton)设计模式中去。\n\n这意为着你在模块里面写好数据和方法之后，只需要export要暴露的成员就行了。例如\n\nlet a = 1;\nlet b = 2;\nlet c = 9;\nexport let i = 114514;\nexport { a, b };\nexport default c;\n",charsets:{cjk:!0}},{title:"DOM",frontmatter:{},regularPath:"/javascript/dom.html",relativePath:"javascript/dom.md",key:"v-4a1fa2e5",path:"/javascript/dom.html",headers:[{level:2,title:"click",slug:"click",normalizedTitle:"click",charIndex:19}],headersStr:"click",content:"# DOM\n\n一些问题和笔记\n\n\n# click\n\n为什么监听反复设置了一晚上都无效？\n\n> The HTMLElement.click() method simulates a mouse click on an element.\n\n...草这个是模拟点击，而不是指的onlick...要的话请改onclick property或者addEventListener('click', func)",normalizedContent:"# dom\n\n一些问题和笔记\n\n\n# click\n\n为什么监听反复设置了一晚上都无效？\n\n> the htmlelement.click() method simulates a mouse click on an element.\n\n...草这个是模拟点击，而不是指的onlick...要的话请改onclick property或者addeventlistener('click', func)",charsets:{cjk:!0}},{title:"Common function",frontmatter:{},regularPath:"/javascript/common_function.html",relativePath:"javascript/common_function.md",key:"v-781ef711",path:"/javascript/common_function.html",headers:[{level:2,title:"setTimeout & setInterval",slug:"settimeout-setinterval",normalizedTitle:"settimeout &amp; setinterval",charIndex:null},{level:2,title:"apply & call",slug:"apply-call",normalizedTitle:"apply &amp; call",charIndex:null},{level:2,title:"bind",slug:"bind",normalizedTitle:"bind",charIndex:93}],headersStr:"setTimeout & setInterval apply & call bind",content:'# Common function\n\n\n\n * Common function\n   * setTimeout & setInterval\n   * apply & call\n   * bind\n\n\n\n这里将会用来记录JavaScript里头经常使用到的一些函数。\n\n\n# setTimeout & setInterval\n\n那就是setTimeout和setInterval了，之前一直不会英语，导致不知道是什么意思。现在literally读了一下，估计应该是：前者是在一段时间后执行，后者是以某一时间长短为间隔，反复执行。看起来没什么问题毕竟叫做是Timeout和Interval嘛。。。一查发现，的确如此\n\nsetTimeout()\nExecute a specified block of code once after a specified time has elapsed.\nsetInterval()\nExecute a specified block of code repeatedly with a fixed time delay between each call.\n\n\n然后它们的返回值是一个数值--timeoutID或者intervalID，都是共享同一个ID池的。\n\n这个ID作用一般是用于传给clearTimeout()或者clearInterval()，以清除timeout或者interval的。\n\n\n# apply & call\n\n> The difference is that apply lets you invoke the function with arguments as an array; call requires the parameters be listed explicitly. A useful mnemonic is "A for array and C for comma."\n\n就只是传arg的方式不是很一样而已，一个是数组，一个是正常的参数。\n\nfunc.apply(thisArg, [ argsArray])\n\nfunc.call([thisArg[, arg1, arg2, ...argN]])\n\nThe result of calling the function with the specified this value and arguments.\n\n\n# bind\n\nlet boundFunc = func.bind(thisArg[, arg1[, arg2[, ...argN]]])\n\n这个方法返回一个函数，这个函数有什么特别之处呢。特别之处就是这个函数的this是被bind了，bind就是对象thisArg。\n\n具体怎么操作呢？见下代码\n\nconst mod = {\n  value: 114514,\n  getValue: function () {\n    return this.value;\n  }\n};\n\nconst unboundGetValue = mod.getValue;\nconsole.log(unboundGetValue());\n\nconst boundGetValue = mod.getValue.bind(mod);\nconsole.log(boundGetValue());\n\n// in nodejs\n// the excepted output: undefined 114514\n',normalizedContent:'# common function\n\n\n\n * common function\n   * settimeout & setinterval\n   * apply & call\n   * bind\n\n\n\n这里将会用来记录javascript里头经常使用到的一些函数。\n\n\n# settimeout & setinterval\n\n那就是settimeout和setinterval了，之前一直不会英语，导致不知道是什么意思。现在literally读了一下，估计应该是：前者是在一段时间后执行，后者是以某一时间长短为间隔，反复执行。看起来没什么问题毕竟叫做是timeout和interval嘛。。。一查发现，的确如此\n\nsettimeout()\nexecute a specified block of code once after a specified time has elapsed.\nsetinterval()\nexecute a specified block of code repeatedly with a fixed time delay between each call.\n\n\n然后它们的返回值是一个数值--timeoutid或者intervalid，都是共享同一个id池的。\n\n这个id作用一般是用于传给cleartimeout()或者clearinterval()，以清除timeout或者interval的。\n\n\n# apply & call\n\n> the difference is that apply lets you invoke the function with arguments as an array; call requires the parameters be listed explicitly. a useful mnemonic is "a for array and c for comma."\n\n就只是传arg的方式不是很一样而已，一个是数组，一个是正常的参数。\n\nfunc.apply(thisarg, [ argsarray])\n\nfunc.call([thisarg[, arg1, arg2, ...argn]])\n\nthe result of calling the function with the specified this value and arguments.\n\n\n# bind\n\nlet boundfunc = func.bind(thisarg[, arg1[, arg2[, ...argn]]])\n\n这个方法返回一个函数，这个函数有什么特别之处呢。特别之处就是这个函数的this是被bind了，bind就是对象thisarg。\n\n具体怎么操作呢？见下代码\n\nconst mod = {\n  value: 114514,\n  getvalue: function () {\n    return this.value;\n  }\n};\n\nconst unboundgetvalue = mod.getvalue;\nconsole.log(unboundgetvalue());\n\nconst boundgetvalue = mod.getvalue.bind(mod);\nconsole.log(boundgetvalue());\n\n// in nodejs\n// the excepted output: undefined 114514\n',charsets:{cjk:!0}},{title:"Function",frontmatter:{},regularPath:"/javascript/function.html",relativePath:"javascript/function.md",key:"v-53fc998e",path:"/javascript/function.html",headers:[{level:2,title:"Pattern",slug:"pattern",normalizedTitle:"pattern",charIndex:86},{level:2,title:"this",slug:"this",normalizedTitle:"this",charIndex:333},{level:2,title:"arguments",slug:"arguments",normalizedTitle:"arguments",charIndex:522},{level:2,title:"Closure",slug:"closure",normalizedTitle:"closure",charIndex:917},{level:2,title:"Arrow function",slug:"arrow-function",normalizedTitle:"arrow function",charIndex:439}],headersStr:"Pattern this arguments Closure Arrow function",content:"# Function\n\n在js里，函数式一等公民。也就是说，函数不用被特殊对待，就是一个值。\n\n这个值可以被赋值给变量，可以作为参数传递，也可以存在对象里头...\n\n\n# Pattern\n\nFunction有四种Patterns，如下\n\n 1. The method invocation pattern\n 2. The function invocation pattern\n 3. The constructor invocation pattern\n 4. The apply invocation pattern\n\n如果有一个名为func的函数\n\ninvoke的操作分别是new func(), func(), foo.func(), func.apply(thisArg, [argsArray])\n\n\n# this\n\n已经优化，发了博客\n\nthis在JavaScript中就是执行当前context的对象\n\n大多数情况就是用来查明这个函数是由谁call的，但是要注意Arrow function没有属于自己的argument和this。\n\n箭头函数的this，是静态的，为箭头函数定义的地方capture自外部的this。\n\n\n# arguments\n\n函数里面除了拥有this，还有arguments。实际上就是一个Array-like的对象\n\nlet fn = function () {\n    console.log(arguments);\n};\n\nfn(114, 514); // [Arguments] { '0': 114, '1': 514 }\n\n\n这个对象的prototype只有两个property: length, callee(当前的这个函数)\n\n没有与Array自带的方法，不过可以转化为array\n\nlet array = Array.prototype.slice.call(arguments); // in function body\n\n\n传参又是怎么样的呢？\n\n在js函数里头，传的参数的长度不是固定为参数列表中参数的个数。完全可以传多或者传少，只不过要严格遵循参数的所在位置\n\n\n# Closure\n\n闭包，其实实际上的就是：一小块的代码块。在js中，外部的变量，根据context，可以被捕获进closure与之形成闭包。\n\n> This is possible because the function has the access to the context in which it was created.\n\n/** example code for explaining closure */\n\n/** \n * The function has access to the context in which it was created. This is called closure\n * And it has privileged access to the property even the method returned\n*/\n\n//like these\n//example 1\nvar myObject = function () {\n    var value = 0;\n\n    return {\n        increment: function (inc) {\n            value += typeof inc === 'number' ? inc : 1;\n        },\n        getValue: function () {\n            return value;\n        }\n    };\n}();\n\nmyObject.increment(114514);\nconsole.log(myObject.getValue()); // 114514\n\n//example 2\nvar quo = function (status) {\n    return {\n        get_status: function () {\n            return status;\n        }\n    };\n};\nvar myQuo = quo('amazed');\nconsole.log(myQuo.get_status()); // amazed\n\n//So, how to set events for each button?\n\n//a bad example. When a button was clicked, it alerts the length of the array of the nodes but not the ordinate.\nvar add_the_handlers_bad = function (node) {\n    var i;\n    for (i = 0; i < nodes.length; i += 1) {\n        nodes[i].onclick = function (e) {\n            alert(i);\n        };\n    }\n};\n\n//a better example. While setting an event of a button, the i will be passed into the function\n//and the events will be handled by a function that return from a function.\nvar add_the_handlers = function (nodes) {\n    var i;\n    for (i = 0; i < nodes.length; i += 1) {\n        nodes[i].onclick = function (i) {\n            return function (e) {\n                alert(i);\n            };\n        }(i);\n    }\n};\n\n\n\n# Arrow function\n\n简的来说就是没argument,this和super，不适合使用bind, apply和call了（同理，也不能做对象的method）。也不能用来做constructor。还有一些与普通函数的区别，摘自MDN。\n\n * Does not have arguments, or new.target keywords.\n * Can not use yield, within its body.",normalizedContent:"# function\n\n在js里，函数式一等公民。也就是说，函数不用被特殊对待，就是一个值。\n\n这个值可以被赋值给变量，可以作为参数传递，也可以存在对象里头...\n\n\n# pattern\n\nfunction有四种patterns，如下\n\n 1. the method invocation pattern\n 2. the function invocation pattern\n 3. the constructor invocation pattern\n 4. the apply invocation pattern\n\n如果有一个名为func的函数\n\ninvoke的操作分别是new func(), func(), foo.func(), func.apply(thisarg, [argsarray])\n\n\n# this\n\n已经优化，发了博客\n\nthis在javascript中就是执行当前context的对象\n\n大多数情况就是用来查明这个函数是由谁call的，但是要注意arrow function没有属于自己的argument和this。\n\n箭头函数的this，是静态的，为箭头函数定义的地方capture自外部的this。\n\n\n# arguments\n\n函数里面除了拥有this，还有arguments。实际上就是一个array-like的对象\n\nlet fn = function () {\n    console.log(arguments);\n};\n\nfn(114, 514); // [arguments] { '0': 114, '1': 514 }\n\n\n这个对象的prototype只有两个property: length, callee(当前的这个函数)\n\n没有与array自带的方法，不过可以转化为array\n\nlet array = array.prototype.slice.call(arguments); // in function body\n\n\n传参又是怎么样的呢？\n\n在js函数里头，传的参数的长度不是固定为参数列表中参数的个数。完全可以传多或者传少，只不过要严格遵循参数的所在位置\n\n\n# closure\n\n闭包，其实实际上的就是：一小块的代码块。在js中，外部的变量，根据context，可以被捕获进closure与之形成闭包。\n\n> this is possible because the function has the access to the context in which it was created.\n\n/** example code for explaining closure */\n\n/** \n * the function has access to the context in which it was created. this is called closure\n * and it has privileged access to the property even the method returned\n*/\n\n//like these\n//example 1\nvar myobject = function () {\n    var value = 0;\n\n    return {\n        increment: function (inc) {\n            value += typeof inc === 'number' ? inc : 1;\n        },\n        getvalue: function () {\n            return value;\n        }\n    };\n}();\n\nmyobject.increment(114514);\nconsole.log(myobject.getvalue()); // 114514\n\n//example 2\nvar quo = function (status) {\n    return {\n        get_status: function () {\n            return status;\n        }\n    };\n};\nvar myquo = quo('amazed');\nconsole.log(myquo.get_status()); // amazed\n\n//so, how to set events for each button?\n\n//a bad example. when a button was clicked, it alerts the length of the array of the nodes but not the ordinate.\nvar add_the_handlers_bad = function (node) {\n    var i;\n    for (i = 0; i < nodes.length; i += 1) {\n        nodes[i].onclick = function (e) {\n            alert(i);\n        };\n    }\n};\n\n//a better example. while setting an event of a button, the i will be passed into the function\n//and the events will be handled by a function that return from a function.\nvar add_the_handlers = function (nodes) {\n    var i;\n    for (i = 0; i < nodes.length; i += 1) {\n        nodes[i].onclick = function (i) {\n            return function (e) {\n                alert(i);\n            };\n        }(i);\n    }\n};\n\n\n\n# arrow function\n\n简的来说就是没argument,this和super，不适合使用bind, apply和call了（同理，也不能做对象的method）。也不能用来做constructor。还有一些与普通函数的区别，摘自mdn。\n\n * does not have arguments, or new.target keywords.\n * can not use yield, within its body.",charsets:{cjk:!0}},{title:"Iteration",frontmatter:{},regularPath:"/javascript/iteration.html",relativePath:"javascript/iteration.md",key:"v-f1fdf422",path:"/javascript/iteration.html",headers:[{level:2,title:"Iterable Protocol",slug:"iterable-protocol",normalizedTitle:"iterable protocol",charIndex:16},{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:338},{level:2,title:"Spread syntax (...)",slug:"spread-syntax",normalizedTitle:"spread syntax (...)",charIndex:802},{level:2,title:"Delegation",slug:"delegation",normalizedTitle:"delegation",charIndex:1411},{level:2,title:"Args passing",slug:"args-passing",normalizedTitle:"args passing",charIndex:1798},{level:2,title:"Symbol.iterator",slug:"symbol-iterator",normalizedTitle:"symbol.iterator",charIndex:1542}],headersStr:"Iterable Protocol Generator Spread syntax (...) Delegation Args passing Symbol.iterator",content:"# Iteration\n\n\n# Iterable Protocol\n\nES6标准定义了一套Iterable protocol，用于对iterable对象进行迭代。依靠这个protocol里面的next()--用于返回含有property为value和done的一个iterator对象。一个粗糙的实现是：next()后是否done，是则停下，否则继续next()\n\nES6拥有几个实现了该protocol的API和syntax，比如常见的循环for..of\n\n可以直接提供iterator给iterable protocol进行迭代，是因为iterator本身就是iterable的。当我们对一个iterator对象进行迭代，返回的就是这个iterator对象本身。\n\n\n# Generator\n\n带*的function: function*表示这个函数会返回一个Generator对象(这个对象符合iterator protocol)\n\n调用该函数就会返回一个iterator对象\n\n之后再调用这个对象的next()方法，生成器函数的函数体就会先执行，到第一个或者下一个yield表达式处停下，返回一个对象。该对象包含了yield的值value和是否已yield完了最后一个yield的done。\n\nfunction* foo () {\n    yield 1;\n}\n/* when it is in an object\nconst obj = {\n   *foo () {\n      yield 1;\n   }\n}\n*/\n\nlet gen = foo()\n\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n\n\n\n# Spread syntax (...)\n\n于ES2018加入的，可以把iterable比如函数arguments或者数组给展开。比如，可用于可变参数，对象属性复制和数组生成中。\n\nmyFunction(...iterableObj); // pass all elements of iterableObj as arguments to function myFunction\n[...iterableObj]; // insert all elements from iterableObj to an array\n[...iterableObj, '4', 'five', 6]; // combine two arrays by inserting all elements from iterableObj\nlet objClone = { ...obj }; // (copy object)pass all key:value pairs from an object \nlet newArray = [...array] // copy array to a new array\n\n\n常见的有\n\n// convert string to char array\nlet test = \"test\";\nlet chars = [...test]; // ['t', 'e', 's', 't']\n\n\n\n# Delegation\n\n可以用yield*来跳到委托的生成器中。\n\n比如我们可以用这个来获取含有一个对象里面的所有property的数组\n\nconst obj = {\n    s: 2,\n    i: 0,\n    t: 0,\n    u: 1\n};\n\nobj[Symbol.iterator] = function* () {\n    yield* Object.keys(this);\n};\n\nconsole.log([...obj]); // [ 's', 'i', 't', 'u' ]\n\n\n这里就是把iteration委托给array了。如果不用delegation，即yield为yield Object.keys(this);，就会是这样的\n\nconsole.log([...obj]); // [ [ 's', 'i', 't', 'u' ] ]\n\n\n\n# Args passing\n\n也可以传参：比如把参数换成yield。但是要注意next()一下以停在用yield代替的参数处，再进行传参。\n\n简单一例\n\nconst fn = function* () {\n    console.log(114514, yield);\n}\n\nconst gen = fn();\n\ngen.next(); // just to reach the first yield expr\ngen.next('1919810');\n\n\n实质，也就只是在前往下一个yield的时候顺便传值了而已\n\nconst f = function* () {\n    console.log('Before the first yield');\n    console.log(yield, yield);\n    console.log('After the first yield');\n    yield 1919810;\n    console.log('The last yield was yielded')\n};\n\nconst gen = f();\n\nconsole.log(gen.next()); \n// stop at the first yield\n// result: Before the first yield\n// { value: undefined, done: false }\n\nconsole.log(gen.next(114)); \n// pass 114 to replace the first yield and go to next yield\n// result: { value: undefined, done: false }\n\nconsole.log(gen.next(514)); \n// pass 514 to replace the second yield\n// Note: Because the arguments of console.log() are filled with a concrete value, so console.log() will be executed\n// and go to next field, so return an object with a value of 1919810\n// result: { value: undefined, done: false }\n// 114 514\n// After the first yield\n// { value: 1919810, done: false }\n\nconsole.log(gen.next()); \n// go to next field but it has no next field...\n// result: The last yield was yielded\n// { value: undefined, done: true }\n\n\n结果\n\nBefore the first yield\n{ value: undefined, done: false }\n{ value: undefined, done: false }\n114 514\nAfter the first yield\n{ value: 1919810, done: false }\nThe last yield was yielded\n{ value: undefined, done: true }\n\n\n\n# Symbol.iterator\n\n这个东东是用来自定义一个对象的迭代器的。往一个对象里头加Symbol.iterator这个property就行了，比如\n\nconst obj = {\n    *[Symbol.iterator] () {\n        yield 114;\n        yield 514;\n        yield 1919;\n        yield 810;\n    }\n};\n\nclass Foo {\n    *[Symbol.iterator] () {\n        yield 114514;\n        yield 1919810;\n    }\n}\n\nconsole.log([...obj]); // [ 114, 514, 1919, 810 ]\nconsole.log(Array.from(new Foo())); // [ 114514, 1919810 ]\n",normalizedContent:"# iteration\n\n\n# iterable protocol\n\nes6标准定义了一套iterable protocol，用于对iterable对象进行迭代。依靠这个protocol里面的next()--用于返回含有property为value和done的一个iterator对象。一个粗糙的实现是：next()后是否done，是则停下，否则继续next()\n\nes6拥有几个实现了该protocol的api和syntax，比如常见的循环for..of\n\n可以直接提供iterator给iterable protocol进行迭代，是因为iterator本身就是iterable的。当我们对一个iterator对象进行迭代，返回的就是这个iterator对象本身。\n\n\n# generator\n\n带*的function: function*表示这个函数会返回一个generator对象(这个对象符合iterator protocol)\n\n调用该函数就会返回一个iterator对象\n\n之后再调用这个对象的next()方法，生成器函数的函数体就会先执行，到第一个或者下一个yield表达式处停下，返回一个对象。该对象包含了yield的值value和是否已yield完了最后一个yield的done。\n\nfunction* foo () {\n    yield 1;\n}\n/* when it is in an object\nconst obj = {\n   *foo () {\n      yield 1;\n   }\n}\n*/\n\nlet gen = foo()\n\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n\n\n\n# spread syntax (...)\n\n于es2018加入的，可以把iterable比如函数arguments或者数组给展开。比如，可用于可变参数，对象属性复制和数组生成中。\n\nmyfunction(...iterableobj); // pass all elements of iterableobj as arguments to function myfunction\n[...iterableobj]; // insert all elements from iterableobj to an array\n[...iterableobj, '4', 'five', 6]; // combine two arrays by inserting all elements from iterableobj\nlet objclone = { ...obj }; // (copy object)pass all key:value pairs from an object \nlet newarray = [...array] // copy array to a new array\n\n\n常见的有\n\n// convert string to char array\nlet test = \"test\";\nlet chars = [...test]; // ['t', 'e', 's', 't']\n\n\n\n# delegation\n\n可以用yield*来跳到委托的生成器中。\n\n比如我们可以用这个来获取含有一个对象里面的所有property的数组\n\nconst obj = {\n    s: 2,\n    i: 0,\n    t: 0,\n    u: 1\n};\n\nobj[symbol.iterator] = function* () {\n    yield* object.keys(this);\n};\n\nconsole.log([...obj]); // [ 's', 'i', 't', 'u' ]\n\n\n这里就是把iteration委托给array了。如果不用delegation，即yield为yield object.keys(this);，就会是这样的\n\nconsole.log([...obj]); // [ [ 's', 'i', 't', 'u' ] ]\n\n\n\n# args passing\n\n也可以传参：比如把参数换成yield。但是要注意next()一下以停在用yield代替的参数处，再进行传参。\n\n简单一例\n\nconst fn = function* () {\n    console.log(114514, yield);\n}\n\nconst gen = fn();\n\ngen.next(); // just to reach the first yield expr\ngen.next('1919810');\n\n\n实质，也就只是在前往下一个yield的时候顺便传值了而已\n\nconst f = function* () {\n    console.log('before the first yield');\n    console.log(yield, yield);\n    console.log('after the first yield');\n    yield 1919810;\n    console.log('the last yield was yielded')\n};\n\nconst gen = f();\n\nconsole.log(gen.next()); \n// stop at the first yield\n// result: before the first yield\n// { value: undefined, done: false }\n\nconsole.log(gen.next(114)); \n// pass 114 to replace the first yield and go to next yield\n// result: { value: undefined, done: false }\n\nconsole.log(gen.next(514)); \n// pass 514 to replace the second yield\n// note: because the arguments of console.log() are filled with a concrete value, so console.log() will be executed\n// and go to next field, so return an object with a value of 1919810\n// result: { value: undefined, done: false }\n// 114 514\n// after the first yield\n// { value: 1919810, done: false }\n\nconsole.log(gen.next()); \n// go to next field but it has no next field...\n// result: the last yield was yielded\n// { value: undefined, done: true }\n\n\n结果\n\nbefore the first yield\n{ value: undefined, done: false }\n{ value: undefined, done: false }\n114 514\nafter the first yield\n{ value: 1919810, done: false }\nthe last yield was yielded\n{ value: undefined, done: true }\n\n\n\n# symbol.iterator\n\n这个东东是用来自定义一个对象的迭代器的。往一个对象里头加symbol.iterator这个property就行了，比如\n\nconst obj = {\n    *[symbol.iterator] () {\n        yield 114;\n        yield 514;\n        yield 1919;\n        yield 810;\n    }\n};\n\nclass foo {\n    *[symbol.iterator] () {\n        yield 114514;\n        yield 1919810;\n    }\n}\n\nconsole.log([...obj]); // [ 114, 514, 1919, 810 ]\nconsole.log(array.from(new foo())); // [ 114514, 1919810 ]\n",charsets:{cjk:!0}},{title:"指令",frontmatter:{},regularPath:"/linux/commands.html",relativePath:"linux/commands.md",key:"v-655c1b36",path:"/linux/commands.html",headers:[{level:2,title:"Path",slug:"path",normalizedTitle:"path",charIndex:30}],headersStr:"Path",content:"# 指令\n\n一些Linux命令行命令。(占坑待更)\n\n\n# Path\n\n * . means same folder as currently running context\n * .. means the parent folder of currently running context\n * Path starting with / means root dir",normalizedContent:"# 指令\n\n一些linux命令行命令。(占坑待更)\n\n\n# path\n\n * . means same folder as currently running context\n * .. means the parent folder of currently running context\n * path starting with / means root dir",charsets:{cjk:!0}},{title:"Object",frontmatter:{},regularPath:"/javascript/object.html",relativePath:"javascript/object.md",key:"v-bbf4764e",path:"/javascript/object.html",headers:[{level:2,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:27},{level:2,title:"Object.create",slug:"object-create",normalizedTitle:"object.create",charIndex:36},{level:3,title:"new",slug:"new",normalizedTitle:"new",charIndex:57},{level:2,title:"Object.hasOwnProperty",slug:"object-hasownproperty",normalizedTitle:"object.hasownproperty",charIndex:66},{level:2,title:"值的类型",slug:"值的类型",normalizedTitle:"值的类型",charIndex:93},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:103}],headersStr:"原型链 Object.create new Object.hasOwnProperty 值的类型 instanceof",content:"# Object\n\n\n\n * Object\n   * 原型链\n   * Object.create\n     * new\n   * Object.hasOwnProperty\n   * 值的类型\n   * instanceof\n\n\n\n\n# 原型链\n\n面向对象&继承，js跟Java/C++里的类不一样，js用的是函数模拟实现，继承靠的是原型链\n\n 1. Function对象是一个比较特殊的对象。且pattern为constructor的Function拥有prototype(原型对象)\n 2. __proto__是创建了该对象的对象\n\n\n\nprototype是一个对象，是函数的原型对象。prototype调用constructor来构建一个新对象，并使得该新对象的__proto__为func.prototype\n\n图中new Foo()产生的对象，其__proto__是Foo.prototype，function Foo()只是个constructor罢了。\n\nfunction a () {\n    this.i = 114514;\n}\ntypeof a.prototype // object\ntypeof Function.prototype // function\n\n\n这里，a创建的是对象，Function创建的是一个function\n\n继承关系:一个对象在寻找property的时候，会从自己开始，顺着原型链__proto__来找，直到找到了或碰到null为止。\n\n\n# Object.create\n\nObject.create()是直接使用现有的对象，作为新建对象的proto。\n\nconst foo = {\n    name: \"situ2001\",\n    isHuman: true\n};\n\nconst bar = Object.create(foo); // create bar {} from the proto of foo\nbar.__proto__ // foo\n\n\n我们甚至可以把null当参数，这样一来，这个对象就没有__proto__了，又根据原型链的继承关系，很多继承于上层对象的方法，比如toString()就不可用了。\n\n\n# new\n\nnew就是相当于创建了继承于func.prototype的新对象，再使用apply()将this指向这个对象\n\n// a simple implementation\nvar obj = Object.create(func.prototype);\nfunc.apply(obj, [args]);\n\n\nlet foo = function () {\n    this.x = 114;\n    this.y = 514;\n};\n\nlet bar = Object.create(foo.prototype);\nfoo.apply(bar);\n\nconsole.log(bar); // foo { x: 114, y: 514 }\n\n\n\n# Object.hasOwnProperty\n\n只会判断这个property是否是自己的，而不会通过原型链来找(毕竟叫做own property)\n\n\n# 值的类型\n\nupdate：见博客\n\n\n# instanceof\n\ninstanceof运算符用于判断一个对象是否拥有该构造函数的prototype。\n\n// obj instanceof constructor\nobj instanceof Object\n\n\n要注意到这个运算符的一些行为\n\n例如，string可以是primitive也可以是object。primitive其实是可以被wrap成object(像Java的wrapper class一样)。所以number, boolean这些，也会出现下面的行为。\n\nlet s1 = '114514'\nlet s2 = new String('1919810')\ns1 instanceof String // false\ns2 instanceof String // true\ntypeof s1 // 'string'\ntypeof s2 // 'object'\n",normalizedContent:"# object\n\n\n\n * object\n   * 原型链\n   * object.create\n     * new\n   * object.hasownproperty\n   * 值的类型\n   * instanceof\n\n\n\n\n# 原型链\n\n面向对象&继承，js跟java/c++里的类不一样，js用的是函数模拟实现，继承靠的是原型链\n\n 1. function对象是一个比较特殊的对象。且pattern为constructor的function拥有prototype(原型对象)\n 2. __proto__是创建了该对象的对象\n\n\n\nprototype是一个对象，是函数的原型对象。prototype调用constructor来构建一个新对象，并使得该新对象的__proto__为func.prototype\n\n图中new foo()产生的对象，其__proto__是foo.prototype，function foo()只是个constructor罢了。\n\nfunction a () {\n    this.i = 114514;\n}\ntypeof a.prototype // object\ntypeof function.prototype // function\n\n\n这里，a创建的是对象，function创建的是一个function\n\n继承关系:一个对象在寻找property的时候，会从自己开始，顺着原型链__proto__来找，直到找到了或碰到null为止。\n\n\n# object.create\n\nobject.create()是直接使用现有的对象，作为新建对象的proto。\n\nconst foo = {\n    name: \"situ2001\",\n    ishuman: true\n};\n\nconst bar = object.create(foo); // create bar {} from the proto of foo\nbar.__proto__ // foo\n\n\n我们甚至可以把null当参数，这样一来，这个对象就没有__proto__了，又根据原型链的继承关系，很多继承于上层对象的方法，比如tostring()就不可用了。\n\n\n# new\n\nnew就是相当于创建了继承于func.prototype的新对象，再使用apply()将this指向这个对象\n\n// a simple implementation\nvar obj = object.create(func.prototype);\nfunc.apply(obj, [args]);\n\n\nlet foo = function () {\n    this.x = 114;\n    this.y = 514;\n};\n\nlet bar = object.create(foo.prototype);\nfoo.apply(bar);\n\nconsole.log(bar); // foo { x: 114, y: 514 }\n\n\n\n# object.hasownproperty\n\n只会判断这个property是否是自己的，而不会通过原型链来找(毕竟叫做own property)\n\n\n# 值的类型\n\nupdate：见博客\n\n\n# instanceof\n\ninstanceof运算符用于判断一个对象是否拥有该构造函数的prototype。\n\n// obj instanceof constructor\nobj instanceof object\n\n\n要注意到这个运算符的一些行为\n\n例如，string可以是primitive也可以是object。primitive其实是可以被wrap成object(像java的wrapper class一样)。所以number, boolean这些，也会出现下面的行为。\n\nlet s1 = '114514'\nlet s2 = new string('1919810')\ns1 instanceof string // false\ns2 instanceof string // true\ntypeof s1 // 'string'\ntypeof s2 // 'object'\n",charsets:{cjk:!0}},{title:"Problems",frontmatter:{},regularPath:"/javascript/problems.html",relativePath:"javascript/problems.md",key:"v-5b00dab9",path:"/javascript/problems.html",headers:[{level:2,title:"Strict mode",slug:"strict-mode",normalizedTitle:"strict mode",charIndex:31},{level:2,title:"Falsy values",slug:"falsy-values",normalizedTitle:"falsy values",charIndex:48},{level:2,title:"Operator || &&",slug:"operator",normalizedTitle:"operator || &amp;&amp;",charIndex:null},{level:2,title:"值的比较",slug:"值的比较",normalizedTitle:"值的比较",charIndex:86},{level:2,title:"Global Object",slug:"global-object",normalizedTitle:"global object",charIndex:96},{level:2,title:"let",slug:"let",normalizedTitle:"let",charIndex:115},{level:2,title:"for in vs for of",slug:"for-in-vs-for-of",normalizedTitle:"for in vs for of",charIndex:124},{level:2,title:"template literals",slug:"template-literals",normalizedTitle:"template literals",charIndex:146},{level:2,title:"文件即程序",slug:"文件即程序",normalizedTitle:"文件即程序",charIndex:169}],headersStr:"Strict mode Falsy values Operator || && 值的比较 Global Object let for in vs for of template literals 文件即程序",content:'# Problems\n\n\n\n * Problems\n   * Strict mode\n   * Falsy values\n   * Operator || &&\n   * 值的比较\n   * Global Object\n   * let\n   * for in vs for of\n   * template literals\n   * 文件即程序\n\n\n\n\n# Strict mode\n\n> Strict mode is like a linter reminding you how JS should be written to have the highest quality and best chance at performance\n\nJS的严格模式，举个例子，在浏览器环境下，严格模式会使得global object变为undefined，而不是Window\n\n启用方法如下，这条statement前若有代码，那么就会使严格模式不生效\n\n// only comments and whitespace are allowed\n"use strict";\n// code starts here\n\n\n当然也可以用在function的scope上，叫做function-level strict mode。比如这个\n\nfunction foo() {\n    // only comments and whitespace are allowed\n    "use strict";\n    // code starts here\n}\n\n\n不过ES6的module都是假定在strict mode下的，所以ES6文件的代码都是自动默认为strict mode的（为什么不全部JS文件都默认为严格模式呢？这会break the web）\n\n\n# Falsy values\n\n这里插入falsy value，为后面比较做铺垫\n\n下面这些值都是false\n\n * false\n * null\n * undefined\n * NaN\n * 0 (zero)\n * -0 (Number negative zero)\n * 0n (BigInt zero)\n * empty string ("" or \'\' or ``)\n\n\n# Operator || &&\n\n与此同时，顺便插入跟其他常见语言行为有点不同的&&和||运算符运算规则\n\nOPERATOR   MEANING     STATEMENT\n``         Logic OR    If expr1 can be converted to true, returns expr1; else,\n                       returns expr2.\n&&         Logic AND   If expr1 can be converted to true, returns expr2; else,\n                       returns expr1.\n\nlet a = undefined || 114514; // a = 114514\nlet b = undefined && 1919810; // b = undefined\nlet c = "you" || "me"; // c = you\nlet d = "you" && "me"; // d = me\n\n\n根据短路运算的规则来理解就行了，比如Logic OR，第一个true就扔回第一个，否则就会比较第二个，因此第一个false就会扔回第二个。Logic AND也是如此\n\n并且因为js用来判断false和true的是用falsy value和truthy value，所以使用if语句的时候，要注意哪些东西在js里头是falsy的。\n\n\n# 值的比较\n\nupdate：见博客\n\n\n# Global Object\n\n顾名思义就是全局对象。在浏览器下，全局变量(global variable)创建后会被作为是Window的一个property\n\nIn web browser, when a variable defined with var keyword, they are created as the member of the global object.(Node.js does not have this case)\n\nENVIRONMENT   GLOBAL OBJECT\nWeb browser   Window\nNode.js       global\n\nFor example\n\n// on a web browser\nvar a = 114514;\nlet b = 114514;\nthis; // Window\nconsole.log(this.a); // 114514\nconsole.log(this.b); // undefined\n// on node.js\nvar a = 114514;\nvar b = 114514;\nconsole.log(this); // undefined\nconsole.log(this.a); // undefined\nconsole.log(this.b); // undefined\n\n\n\n# let\n\n了解这个之前可以了解一下js的scope，文章点此\n\n> The let statement declares a block-scoped local variable, optionally initializing it to a value.\n\n跟var声明的变量的scope为函数或全局的这一点不一样，let声明的是个具有block-scope的本地变量，即它的作用域是在一个block内，并且在同一个块里面，我们不能重复声明同一个变量。比如我们这样做就会发生错误\n\nlet x = 1;\nswitch(x) {\n  case 0:\n    let foo;\n    break;\n\n  case 1:\n    let foo; // SyntaxError for redeclaration.\n    break;\n}\n\n\n而要做的，只需要把每个case后面的statement使用brace{}括起来就行了，比如\n\ncase 0: {\n  let foo;\n  break;\n}\n\n\nvar和let的行为都是差不多的，只是scope的不同，以及let有TDZ临时死区\n\nfunction varTest() {\n  var x = 1;\n  {\n    var x = 2;  // same variable!\n    console.log(x);  // 2\n  }\n  console.log(x);  // 2\n}\n\nfunction letTest() {\n  let x = 1;\n  {\n    let x = 2;  // different variable\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n\n\nlet还能被用来创建{}scope的private variable，比如这个(其实var的话，利用closure+IIFE就行了)\n\nvar Thing;\n\n{\n  let privateScope = new WeakMap();\n  let counter = 0;\n\n  Thing = function() {\n    this.someProperty = \'foo\';\n\n    privateScope.set(this, {\n      hidden: ++counter,\n    });\n  };\n\n  Thing.prototype.showPublic = function() {\n    return this.someProperty;\n  };\n\n  Thing.prototype.showPrivate = function() {\n    return privateScope.get(this).hidden;\n  };\n}\n\nconsole.log(typeof privateScope); // "undefined"\n\nvar thing = new Thing();\n\nconsole.log(thing); // Thing {someProperty: "foo"}\n\nthing.showPublic(); // "foo"\n\nthing.showPrivate(); // 1\n\n\nlet不会在global object上面创建一个property\n\n> At the top level of programs and functions, let, unlike var, does not create a property on the global object.\n\nvar x = \'global\';\nlet y = \'global\';\nconsole.log(this.x); // "global"\nconsole.log(this.y); // undefined\n\n\n还有一个特性TDZ(temporal dead zone)，叫做临时死区。\n\n可以理解为在初始化之前被使用就会报错，而全局变量只会undefined，这是因为，虽然两者都有变量提升(即变量的声明位置被提到了该变量的顶层作用域的开头，比如var的就是全局作用域，let就是局部的)，但是var声明的变量，在到赋值语句前，只是undefined，而let的话会直接报错。\n\n{ // TDZ starts at beginning of scope\n  console.log(bar); // undefined\n  console.log(foo); // ReferenceError\n  var bar = 1;\n  let foo = 2; // End of TDZ (for foo)\n}\n\n\n与此同时，还有一个const，这个的行为跟let是差不多的，只不过const常量要在声明的时候赋值，且之后就不能更改赋的这个值了。\n\n> A third declaration form is const. It\'s like let but has an additional limitation that it must be given a value at the moment it\'s declared, and cannot be re-assigned a different value later.\n\n\n# for in vs for of\n\nfor ... in ...，迭代的是一个对象的enumerable property name\n\nfor ... of ...，迭代的是一个对象的property value，然而限定了使用的对象，要是iteratable的才行，比如Array, Map, Set, String, TypedArray, arguments\n\nlet list = [4, 5, 6];\n\nfor (let i in list) {\n   console.log(i); // "0", "1", "2",\n}\n\nfor (let i of list) {\n   console.log(i); // "4", "5", "6"\n}\n\nlet pets = new Set(["Cat", "Dog", "Hamster"]);\npets["species"] = "mammals";\n\nfor (let pet in pets) {\n   console.log(pet); // "species"\n}\n\nfor (let pet of pets) {\n    console.log(pet); // "Cat", "Dog", "Hamster"\n}\n\n\nfor..of循环还可以这样，一般来说，JS内建的iterable都有下面几个方法：keys(), values()和entries()\n\nvar arr = [ 10, 20, 30 ];\n\nfor (let [idx,val] of arr.entries()) {\n    console.log(`[${ idx }]: ${ val }`);\n}\n// [0]: 10\n// [1]: 20\n// [2]: 30\n\n\n\n# template literals\n\nlet str = \'514\';\nconsole.log(`114${str}`); // 114514\nlet examScore = 45;\nlet examHighestScore = 70;\nexamReport = `You scored ${ examScore }/${ examHighestScore } (${ Math.round((examScore/examHighestScore*100)) }%). ${ examScore >= 49 ? \'Well done, you passed!\' : \'Bad luck, you didn\\\'t pass this time.\' }`;\n\n\n\n# 文件即程序\n\n在JS里头，每一个文件就被当成一个独立的程序。多个js文件被加载之后，其实是每个单独的js文件通过global scope来共享它们之间的状态的，所以运行的时候它们就在一起工作了。（这就是网页有时候有多个js，但是一两个加载失败之后，网页的部分功能还能运作的原因）\n\nES6之后加入了module这个东西，只要一个文件有import之类的语句，或者在HTML上用tag <script type=module>，那么这个文件就会被当为ES6模块，不过ES6模块还是被视作为一个单独的文件。一个模块被import的时候，工作起来还是那样，如下\n\n> Similar to how "global scope" allows standalone files to mix together at runtime, importing a module into another allows runtime interoperation between them.',normalizedContent:'# problems\n\n\n\n * problems\n   * strict mode\n   * falsy values\n   * operator || &&\n   * 值的比较\n   * global object\n   * let\n   * for in vs for of\n   * template literals\n   * 文件即程序\n\n\n\n\n# strict mode\n\n> strict mode is like a linter reminding you how js should be written to have the highest quality and best chance at performance\n\njs的严格模式，举个例子，在浏览器环境下，严格模式会使得global object变为undefined，而不是window\n\n启用方法如下，这条statement前若有代码，那么就会使严格模式不生效\n\n// only comments and whitespace are allowed\n"use strict";\n// code starts here\n\n\n当然也可以用在function的scope上，叫做function-level strict mode。比如这个\n\nfunction foo() {\n    // only comments and whitespace are allowed\n    "use strict";\n    // code starts here\n}\n\n\n不过es6的module都是假定在strict mode下的，所以es6文件的代码都是自动默认为strict mode的（为什么不全部js文件都默认为严格模式呢？这会break the web）\n\n\n# falsy values\n\n这里插入falsy value，为后面比较做铺垫\n\n下面这些值都是false\n\n * false\n * null\n * undefined\n * nan\n * 0 (zero)\n * -0 (number negative zero)\n * 0n (bigint zero)\n * empty string ("" or \'\' or ``)\n\n\n# operator || &&\n\n与此同时，顺便插入跟其他常见语言行为有点不同的&&和||运算符运算规则\n\noperator   meaning     statement\n``         logic or    if expr1 can be converted to true, returns expr1; else,\n                       returns expr2.\n&&         logic and   if expr1 can be converted to true, returns expr2; else,\n                       returns expr1.\n\nlet a = undefined || 114514; // a = 114514\nlet b = undefined && 1919810; // b = undefined\nlet c = "you" || "me"; // c = you\nlet d = "you" && "me"; // d = me\n\n\n根据短路运算的规则来理解就行了，比如logic or，第一个true就扔回第一个，否则就会比较第二个，因此第一个false就会扔回第二个。logic and也是如此\n\n并且因为js用来判断false和true的是用falsy value和truthy value，所以使用if语句的时候，要注意哪些东西在js里头是falsy的。\n\n\n# 值的比较\n\nupdate：见博客\n\n\n# global object\n\n顾名思义就是全局对象。在浏览器下，全局变量(global variable)创建后会被作为是window的一个property\n\nin web browser, when a variable defined with var keyword, they are created as the member of the global object.(node.js does not have this case)\n\nenvironment   global object\nweb browser   window\nnode.js       global\n\nfor example\n\n// on a web browser\nvar a = 114514;\nlet b = 114514;\nthis; // window\nconsole.log(this.a); // 114514\nconsole.log(this.b); // undefined\n// on node.js\nvar a = 114514;\nvar b = 114514;\nconsole.log(this); // undefined\nconsole.log(this.a); // undefined\nconsole.log(this.b); // undefined\n\n\n\n# let\n\n了解这个之前可以了解一下js的scope，文章点此\n\n> the let statement declares a block-scoped local variable, optionally initializing it to a value.\n\n跟var声明的变量的scope为函数或全局的这一点不一样，let声明的是个具有block-scope的本地变量，即它的作用域是在一个block内，并且在同一个块里面，我们不能重复声明同一个变量。比如我们这样做就会发生错误\n\nlet x = 1;\nswitch(x) {\n  case 0:\n    let foo;\n    break;\n\n  case 1:\n    let foo; // syntaxerror for redeclaration.\n    break;\n}\n\n\n而要做的，只需要把每个case后面的statement使用brace{}括起来就行了，比如\n\ncase 0: {\n  let foo;\n  break;\n}\n\n\nvar和let的行为都是差不多的，只是scope的不同，以及let有tdz临时死区\n\nfunction vartest() {\n  var x = 1;\n  {\n    var x = 2;  // same variable!\n    console.log(x);  // 2\n  }\n  console.log(x);  // 2\n}\n\nfunction lettest() {\n  let x = 1;\n  {\n    let x = 2;  // different variable\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n\n\nlet还能被用来创建{}scope的private variable，比如这个(其实var的话，利用closure+iife就行了)\n\nvar thing;\n\n{\n  let privatescope = new weakmap();\n  let counter = 0;\n\n  thing = function() {\n    this.someproperty = \'foo\';\n\n    privatescope.set(this, {\n      hidden: ++counter,\n    });\n  };\n\n  thing.prototype.showpublic = function() {\n    return this.someproperty;\n  };\n\n  thing.prototype.showprivate = function() {\n    return privatescope.get(this).hidden;\n  };\n}\n\nconsole.log(typeof privatescope); // "undefined"\n\nvar thing = new thing();\n\nconsole.log(thing); // thing {someproperty: "foo"}\n\nthing.showpublic(); // "foo"\n\nthing.showprivate(); // 1\n\n\nlet不会在global object上面创建一个property\n\n> at the top level of programs and functions, let, unlike var, does not create a property on the global object.\n\nvar x = \'global\';\nlet y = \'global\';\nconsole.log(this.x); // "global"\nconsole.log(this.y); // undefined\n\n\n还有一个特性tdz(temporal dead zone)，叫做临时死区。\n\n可以理解为在初始化之前被使用就会报错，而全局变量只会undefined，这是因为，虽然两者都有变量提升(即变量的声明位置被提到了该变量的顶层作用域的开头，比如var的就是全局作用域，let就是局部的)，但是var声明的变量，在到赋值语句前，只是undefined，而let的话会直接报错。\n\n{ // tdz starts at beginning of scope\n  console.log(bar); // undefined\n  console.log(foo); // referenceerror\n  var bar = 1;\n  let foo = 2; // end of tdz (for foo)\n}\n\n\n与此同时，还有一个const，这个的行为跟let是差不多的，只不过const常量要在声明的时候赋值，且之后就不能更改赋的这个值了。\n\n> a third declaration form is const. it\'s like let but has an additional limitation that it must be given a value at the moment it\'s declared, and cannot be re-assigned a different value later.\n\n\n# for in vs for of\n\nfor ... in ...，迭代的是一个对象的enumerable property name\n\nfor ... of ...，迭代的是一个对象的property value，然而限定了使用的对象，要是iteratable的才行，比如array, map, set, string, typedarray, arguments\n\nlet list = [4, 5, 6];\n\nfor (let i in list) {\n   console.log(i); // "0", "1", "2",\n}\n\nfor (let i of list) {\n   console.log(i); // "4", "5", "6"\n}\n\nlet pets = new set(["cat", "dog", "hamster"]);\npets["species"] = "mammals";\n\nfor (let pet in pets) {\n   console.log(pet); // "species"\n}\n\nfor (let pet of pets) {\n    console.log(pet); // "cat", "dog", "hamster"\n}\n\n\nfor..of循环还可以这样，一般来说，js内建的iterable都有下面几个方法：keys(), values()和entries()\n\nvar arr = [ 10, 20, 30 ];\n\nfor (let [idx,val] of arr.entries()) {\n    console.log(`[${ idx }]: ${ val }`);\n}\n// [0]: 10\n// [1]: 20\n// [2]: 30\n\n\n\n# template literals\n\nlet str = \'514\';\nconsole.log(`114${str}`); // 114514\nlet examscore = 45;\nlet examhighestscore = 70;\nexamreport = `you scored ${ examscore }/${ examhighestscore } (${ math.round((examscore/examhighestscore*100)) }%). ${ examscore >= 49 ? \'well done, you passed!\' : \'bad luck, you didn\\\'t pass this time.\' }`;\n\n\n\n# 文件即程序\n\n在js里头，每一个文件就被当成一个独立的程序。多个js文件被加载之后，其实是每个单独的js文件通过global scope来共享它们之间的状态的，所以运行的时候它们就在一起工作了。（这就是网页有时候有多个js，但是一两个加载失败之后，网页的部分功能还能运作的原因）\n\nes6之后加入了module这个东西，只要一个文件有import之类的语句，或者在html上用tag <script type=module>，那么这个文件就会被当为es6模块，不过es6模块还是被视作为一个单独的文件。一个模块被import的时候，工作起来还是那样，如下\n\n> similar to how "global scope" allows standalone files to mix together at runtime, importing a module into another allows runtime interoperation between them.',charsets:{cjk:!0}},{title:"离散数学",frontmatter:{},regularPath:"/lessons/discrete_mathematics.html",relativePath:"lessons/discrete_mathematics.md",key:"v-2604c9e3",path:"/lessons/discrete_mathematics.html",headers:[{level:2,title:"命题逻辑",slug:"命题逻辑",normalizedTitle:"命题逻辑",charIndex:27},{level:3,title:"命题与联结词",slug:"命题与联结词",normalizedTitle:"命题与联结词",charIndex:36},{level:2,title:"命题公式",slug:"命题公式",normalizedTitle:"命题公式",charIndex:636},{level:2,title:"命题定律",slug:"命题定律",normalizedTitle:"命题定律",charIndex:797}],headersStr:"命题逻辑 命题与联结词 命题公式 命题定律",content:"# 离散数学\n\n这里主要是一些离散数学的笔记\n\n\n# 命题逻辑\n\n\n# 命题与联结词\n\n * 命题\n\n一个陈述句，可以确定真假(与之相反的就是谬误了)。\n\n * 联结词\n\n与命题相结合，就是用来修改命题的内容的。比如\n\n> PPP: 上海是一个大城市\n> \n> ¬P\\lnot P¬P: 上海并不是一个大城市\n\n联结词   英文               符号\n否定    Negation         ¬\\lnot¬\n合取    Conjunction      ∧\\land∧\n析取    Disjunction      ∨\\lor∨\n条件    Condition        →\\rightarrow→\n双条件   If and only if   ⇆\\leftrightarrows⇆\n\n怎么记之间的逻辑关系呢？\n\n程序语言...否定就是NOT，合取就是AND，析取就是OR，剩下两个就看真值表\n\n条件是善意的前提，P不行，Q也可能行（想一下P⇒QP\\Rightarrow QP⇒Q)，双条件就是要一起，才会真，不然就是假\n\nP   Q   P→\\RIGHTARROW→Q   P⇆\\LEFTRIGHTARROWS⇆Q\nT   T   T                 T\nT   F   F                 F\nF   T   T                 F\nF   F   T                 T\n\n\n# 命题公式\n\n像这样子的\n\n 1. ¬(P∧Q)\\lnot (P\\land Q)¬(P∧Q)\n 2. (((P→Q)∧(Q→R))⇆(S⇆T))(((P\\to Q)\\land (Q\\to R))\\leftrightarrows (S\\leftrightarrows T))(((P→Q)∧(Q→R))⇆(S⇆T))\n\n\n# 命题定律\n\n这个表可谓是非常重要的了，比如其中的德摩根律\n\n命题定律   表达式\n对合律    ¬¬P⇔P\\lnot \\lnot P\\Leftrightarrow P¬¬P⇔P\n幂等律    P∨P⇔P,P∧P⇔PP\\lor P\\Leftrightarrow P, P\\land P\\Leftrightarrow\n       PP∨P⇔P,P∧P⇔P\n结合律    (P∨Q)∨R⇔P∨(Q∨R)(P\\lor Q)\\lor R\\Leftrightarrow P\\lor (Q\\lor\n       R)(P∨Q)∨R⇔P∨(Q∨R)\n       (P∧Q)∧R⇔P∧(Q∧R)(P\\land Q)\\land R\\Leftrightarrow P\\land\n       (Q\\land R)(P∧Q)∧R⇔P∧(Q∧R)\n交换律    P∨Q⇔Q∨ PP\\lor Q\\Leftrightarrow Q\\lor\\ PP∨Q⇔Q∨ P\n       P∧Q⇔Q∧ PP\\land Q\\Leftrightarrow Q\\land\\ PP∧Q⇔Q∧ P\n分配律    P∨(Q∧R)⇔(P∨Q)∧(P∨R)P\\lor(Q\\land R)\\Leftrightarrow(P\\lor\n       Q)\\land(P\\lor R)P∨(Q∧R)⇔(P∨Q)∧(P∨R)\n       R∧(Q∨R)⇔(P∧Q)∨(P∧R)R\\land(Q\\lor R)\\Leftrightarrow (P\\land\n       Q)\\lor(P\\land R)R∧(Q∨R)⇔(P∧Q)∨(P∧R)\n吸收律    P∨(P∧Q)⇔PP\\lor (P\\land Q)\\Leftrightarrow PP∨(P∧Q)⇔P\n       P∧(P∨Q)⇔PP\\land (P\\lor Q)\\Leftrightarrow PP∧(P∨Q)⇔P\n德摩根律   ¬(P∧Q)⇔¬P∨¬Q\\lnot(P\\land Q)\\Leftrightarrow \\lnot P \\lor\n       \\lnot Q¬(P∧Q)⇔¬P∨¬Q\n       ¬(P∨Q)⇔¬P∧¬Q\\lnot(P\\lor Q)\\Leftrightarrow \\lnot P \\land\n       \\lnot Q¬(P∨Q)⇔¬P∧¬Q\n同一律    P∨F⇔P,P∧T⇔PP\\lor F\\Leftrightarrow P, P\\land T\\Leftrightarrow\n       PP∨F⇔P,P∧T⇔P\n零律     P∨T⇔T,P∧F⇔FP\\lor T\\Leftrightarrow T, P\\land F\\Leftrightarrow\n       FP∨T⇔T,P∧F⇔F\n否定律    P∨¬Q⇔T,P∧¬Q⇔FP\\lor \\lnot Q\\Leftrightarrow T, P\\land \\lnot\n       Q\\Leftrightarrow FP∨¬Q⇔T,P∧¬Q⇔F\n\n哦，还有这个重要的(P→Q)⇔¬P∨Q(P\\to Q)\\Leftrightarrow \\lnot P\\lor Q(P→Q)⇔¬P∨Q",normalizedContent:"# 离散数学\n\n这里主要是一些离散数学的笔记\n\n\n# 命题逻辑\n\n\n# 命题与联结词\n\n * 命题\n\n一个陈述句，可以确定真假(与之相反的就是谬误了)。\n\n * 联结词\n\n与命题相结合，就是用来修改命题的内容的。比如\n\n> ppp: 上海是一个大城市\n> \n> ¬p\\lnot p¬p: 上海并不是一个大城市\n\n联结词   英文               符号\n否定    negation         ¬\\lnot¬\n合取    conjunction      ∧\\land∧\n析取    disjunction      ∨\\lor∨\n条件    condition        →\\rightarrow→\n双条件   if and only if   ⇆\\leftrightarrows⇆\n\n怎么记之间的逻辑关系呢？\n\n程序语言...否定就是not，合取就是and，析取就是or，剩下两个就看真值表\n\n条件是善意的前提，p不行，q也可能行（想一下p⇒qp\\rightarrow qp⇒q)，双条件就是要一起，才会真，不然就是假\n\np   q   p→\\rightarrow→q   p⇆\\leftrightarrows⇆q\nt   t   t                 t\nt   f   f                 f\nf   t   t                 f\nf   f   t                 t\n\n\n# 命题公式\n\n像这样子的\n\n 1. ¬(p∧q)\\lnot (p\\land q)¬(p∧q)\n 2. (((p→q)∧(q→r))⇆(s⇆t))(((p\\to q)\\land (q\\to r))\\leftrightarrows (s\\leftrightarrows t))(((p→q)∧(q→r))⇆(s⇆t))\n\n\n# 命题定律\n\n这个表可谓是非常重要的了，比如其中的德摩根律\n\n命题定律   表达式\n对合律    ¬¬p⇔p\\lnot \\lnot p\\leftrightarrow p¬¬p⇔p\n幂等律    p∨p⇔p,p∧p⇔pp\\lor p\\leftrightarrow p, p\\land p\\leftrightarrow\n       pp∨p⇔p,p∧p⇔p\n结合律    (p∨q)∨r⇔p∨(q∨r)(p\\lor q)\\lor r\\leftrightarrow p\\lor (q\\lor\n       r)(p∨q)∨r⇔p∨(q∨r)\n       (p∧q)∧r⇔p∧(q∧r)(p\\land q)\\land r\\leftrightarrow p\\land\n       (q\\land r)(p∧q)∧r⇔p∧(q∧r)\n交换律    p∨q⇔q∨ pp\\lor q\\leftrightarrow q\\lor\\ pp∨q⇔q∨ p\n       p∧q⇔q∧ pp\\land q\\leftrightarrow q\\land\\ pp∧q⇔q∧ p\n分配律    p∨(q∧r)⇔(p∨q)∧(p∨r)p\\lor(q\\land r)\\leftrightarrow(p\\lor\n       q)\\land(p\\lor r)p∨(q∧r)⇔(p∨q)∧(p∨r)\n       r∧(q∨r)⇔(p∧q)∨(p∧r)r\\land(q\\lor r)\\leftrightarrow (p\\land\n       q)\\lor(p\\land r)r∧(q∨r)⇔(p∧q)∨(p∧r)\n吸收律    p∨(p∧q)⇔pp\\lor (p\\land q)\\leftrightarrow pp∨(p∧q)⇔p\n       p∧(p∨q)⇔pp\\land (p\\lor q)\\leftrightarrow pp∧(p∨q)⇔p\n德摩根律   ¬(p∧q)⇔¬p∨¬q\\lnot(p\\land q)\\leftrightarrow \\lnot p \\lor\n       \\lnot q¬(p∧q)⇔¬p∨¬q\n       ¬(p∨q)⇔¬p∧¬q\\lnot(p\\lor q)\\leftrightarrow \\lnot p \\land\n       \\lnot q¬(p∨q)⇔¬p∧¬q\n同一律    p∨f⇔p,p∧t⇔pp\\lor f\\leftrightarrow p, p\\land t\\leftrightarrow\n       pp∨f⇔p,p∧t⇔p\n零律     p∨t⇔t,p∧f⇔fp\\lor t\\leftrightarrow t, p\\land f\\leftrightarrow\n       fp∨t⇔t,p∧f⇔f\n否定律    p∨¬q⇔t,p∧¬q⇔fp\\lor \\lnot q\\leftrightarrow t, p\\land \\lnot\n       q\\leftrightarrow fp∨¬q⇔t,p∧¬q⇔f\n\n哦，还有这个重要的(p→q)⇔¬p∨q(p\\to q)\\leftrightarrow \\lnot p\\lor q(p→q)⇔¬p∨q",charsets:{cjk:!0}},{title:"Shell",frontmatter:{},regularPath:"/linux/shell.html",relativePath:"linux/shell.md",key:"v-25e7b55f",path:"/linux/shell.html",headersStr:null,content:"# Shell\n\n留坑待更...",normalizedContent:"# shell\n\n留坑待更...",charsets:{cjk:!0}},{title:"node.js",frontmatter:{},regularPath:"/nodejs/",relativePath:"nodejs/README.md",key:"v-61109a1c",path:"/nodejs/",headersStr:null,content:"# node.js",normalizedContent:"# node.js",charsets:{}},{title:"数字电路",frontmatter:{},regularPath:"/lessons/digital_circuits.html",relativePath:"lessons/digital_circuits.md",key:"v-ced71a3e",path:"/lessons/digital_circuits.html",headers:[{level:2,title:"基础储备",slug:"基础储备",normalizedTitle:"基础储备",charIndex:85},{level:3,title:"运算符号",slug:"运算符号",normalizedTitle:"运算符号",charIndex:94},{level:3,title:"原码 补码 反码",slug:"原码-补码-反码",normalizedTitle:"原码 补码 反码",charIndex:342},{level:3,title:"一些运算律",slug:"一些运算律",normalizedTitle:"一些运算律",charIndex:355},{level:2,title:"逻辑代数",slug:"逻辑代数",normalizedTitle:"逻辑代数",charIndex:531},{level:3,title:"逻辑函数",slug:"逻辑函数",normalizedTitle:"逻辑函数",charIndex:564}],headersStr:"基础储备 运算符号 原码 补码 反码 一些运算律 逻辑代数 逻辑函数",content:"# 数字电路\n\n(Discontinued)2020-03-29,该栏目转移到个人notion上\n\n这是数字电路课的笔记。(目前来看，怎么有一种离散数学的味道)\n\n\n# 基础储备\n\n\n# 运算符号\n\n基本的单个符号(与或非)，而由这三者其中几个组合而成的就是复合逻辑的符号。\n\n其实这些符号跟离散数学的很相似，也下表所示。\n\n符号名称   数字电路       离散数学\n与      ⋅\\cdot⋅    ∧\\land∧\n或      +          ∨\\lor∨\n非      `          ¬\\neg¬\n异或     ⊕\\oplus⊕   \n同或     ⊙\\odot⊙    \n与非                \n或非                \n\n\n# 原码 补码 反码\n\n\n# 一些运算律\n\n我是个省纸的人，所以我就直接扔到离散数学那边去了。\n\n德摩根定理：常用的是用来将非门化掉的，比如下\n\n¬(A∨B)=¬A∧¬B\\neg(A\\lor B)=\\neg A\\land\\neg B¬(A∨B)=¬A∧¬B\n\n¬(A∧B)=¬A∨¬B\\neg (A\\land B)=\\neg A\\lor\\neg B¬(A∧B)=¬A∨¬B\n\n\n# 逻辑代数\n\n很多知识都是离散数学的，迁移运用一下就行了。\n\n\n# 逻辑函数\n\n原理跟正常的函数也没有什么不同，功能都是处理(映射)输入的数据后输出结果。要我说，最暴力的方法依旧还是真值表。逻辑函数，这个东东似乎是在逻辑图、波形图、卡诺图等等的地方使用。（重要的是真值表和逻辑式和逻辑图，不过这不是离散数学的内容吗...\n\n提到的有下面几种\n\n 1. 真值表\n 2. 逻辑式\n 3. 逻辑表\n 4. 卡诺图\n 5. 波形图\n\n真值表yyds，自己水平菜的不行的时候，万能工具就是真值表啦。逻辑式，就是字母公式啦，很像是命题公式。然后逻辑图就是用与或非门做出来的电路图，就是逻辑图了。波形图，我个人理解，就是电平图，通过读取在某一段时间内的电平高低来判断0还是1。再接着卡诺图，就是画格子，有点像高中生物的遗传图表，使之来说呢，跟真值表没啥不同，就是减少一下穷举的次数，同时也能在表里执行化简而已。\n\n----------------------------------------\n\n * 最小项之和与最大项之积（等等，这货好像离散数学的那个内容，待补全\n\n最小项有多少个？就是2n2^n2n个嘛，比如ABCABCABC就算是一个最小项了，记作m1m_1m1 ，然后对于任意一个最小项，三个变元只有一种取值组合才能让这个最小项取值为1。同理我们可以迅速得出，最大项也只有2n2^n2n个，但是由个个之间的取和变为了取或(由合取conjunction变成了析取disjunction)，比如A+B+CA+B+CA+B+C是一个最大项，记作M1M_1M1\n\n一些公式，利用A+A‘=1A+A`=1A+A‘=1这个运算性质可以将任何一个逻辑函数转化为最小项之和的形式，比如BC=BC(A+A‘)=ABC+A‘BC=∑m(6,7)BC=BC(A+A`)=ABC+A`BC=\\sum m(6,7)BC=BC(A+A‘)=ABC+A‘BC=∑m(6,7)\n\n据老师说，这是用来给化简(卡诺图)来做铺垫的？\n\n----------------------------------------\n\n * 卡诺图化简的原理\n\n的确，就是逆着利用A+A‾=1A+\\overline{A}=1A+A=1罢了，就像是AB‾+AB=AA\\overline{B}+AB=AAB+AB=A\n\n比如，化简逻辑函数F,其中F(A,B,C,D)=∑m(1,5,6,7,11,12,13,15)F(A,B,C,D)=\\sum m(1,5,6,7,11,12,13,15)F(A,B,C,D)=∑m(1,5,6,7,11,12,13,15)，然后就会发现相邻的可以合成一个项，比如ABCD‾+ABC‾D=ABC‾AB\\overline{CD}+AB\\overline{C}D=AB\\overline{C}ABCD+ABCD=ABC\n\n----------------------------------------\n\nQ: 相邻的项合并方法是是?\n\n\n\nA: 如图所示，在合并项(卡诺圈)所处位置上，若某变量的代码有0也有1，则该变量被消去，否则该变量被保留，并按0为反变量，1为原变量的原则写成乘积项形式的合并项中。",normalizedContent:"# 数字电路\n\n(discontinued)2020-03-29,该栏目转移到个人notion上\n\n这是数字电路课的笔记。(目前来看，怎么有一种离散数学的味道)\n\n\n# 基础储备\n\n\n# 运算符号\n\n基本的单个符号(与或非)，而由这三者其中几个组合而成的就是复合逻辑的符号。\n\n其实这些符号跟离散数学的很相似，也下表所示。\n\n符号名称   数字电路       离散数学\n与      ⋅\\cdot⋅    ∧\\land∧\n或      +          ∨\\lor∨\n非      `          ¬\\neg¬\n异或     ⊕\\oplus⊕   \n同或     ⊙\\odot⊙    \n与非                \n或非                \n\n\n# 原码 补码 反码\n\n\n# 一些运算律\n\n我是个省纸的人，所以我就直接扔到离散数学那边去了。\n\n德摩根定理：常用的是用来将非门化掉的，比如下\n\n¬(a∨b)=¬a∧¬b\\neg(a\\lor b)=\\neg a\\land\\neg b¬(a∨b)=¬a∧¬b\n\n¬(a∧b)=¬a∨¬b\\neg (a\\land b)=\\neg a\\lor\\neg b¬(a∧b)=¬a∨¬b\n\n\n# 逻辑代数\n\n很多知识都是离散数学的，迁移运用一下就行了。\n\n\n# 逻辑函数\n\n原理跟正常的函数也没有什么不同，功能都是处理(映射)输入的数据后输出结果。要我说，最暴力的方法依旧还是真值表。逻辑函数，这个东东似乎是在逻辑图、波形图、卡诺图等等的地方使用。（重要的是真值表和逻辑式和逻辑图，不过这不是离散数学的内容吗...\n\n提到的有下面几种\n\n 1. 真值表\n 2. 逻辑式\n 3. 逻辑表\n 4. 卡诺图\n 5. 波形图\n\n真值表yyds，自己水平菜的不行的时候，万能工具就是真值表啦。逻辑式，就是字母公式啦，很像是命题公式。然后逻辑图就是用与或非门做出来的电路图，就是逻辑图了。波形图，我个人理解，就是电平图，通过读取在某一段时间内的电平高低来判断0还是1。再接着卡诺图，就是画格子，有点像高中生物的遗传图表，使之来说呢，跟真值表没啥不同，就是减少一下穷举的次数，同时也能在表里执行化简而已。\n\n----------------------------------------\n\n * 最小项之和与最大项之积（等等，这货好像离散数学的那个内容，待补全\n\n最小项有多少个？就是2n2^n2n个嘛，比如abcabcabc就算是一个最小项了，记作m1m_1m1 ，然后对于任意一个最小项，三个变元只有一种取值组合才能让这个最小项取值为1。同理我们可以迅速得出，最大项也只有2n2^n2n个，但是由个个之间的取和变为了取或(由合取conjunction变成了析取disjunction)，比如a+b+ca+b+ca+b+c是一个最大项，记作m1m_1m1\n\n一些公式，利用a+a‘=1a+a`=1a+a‘=1这个运算性质可以将任何一个逻辑函数转化为最小项之和的形式，比如bc=bc(a+a‘)=abc+a‘bc=∑m(6,7)bc=bc(a+a`)=abc+a`bc=\\sum m(6,7)bc=bc(a+a‘)=abc+a‘bc=∑m(6,7)\n\n据老师说，这是用来给化简(卡诺图)来做铺垫的？\n\n----------------------------------------\n\n * 卡诺图化简的原理\n\n的确，就是逆着利用a+a‾=1a+\\overline{a}=1a+a=1罢了，就像是ab‾+ab=aa\\overline{b}+ab=aab+ab=a\n\n比如，化简逻辑函数f,其中f(a,b,c,d)=∑m(1,5,6,7,11,12,13,15)f(a,b,c,d)=\\sum m(1,5,6,7,11,12,13,15)f(a,b,c,d)=∑m(1,5,6,7,11,12,13,15)，然后就会发现相邻的可以合成一个项，比如abcd‾+abc‾d=abc‾ab\\overline{cd}+ab\\overline{c}d=ab\\overline{c}abcd+abcd=abc\n\n----------------------------------------\n\nq: 相邻的项合并方法是是?\n\n\n\na: 如图所示，在合并项(卡诺圈)所处位置上，若某变量的代码有0也有1，则该变量被消去，否则该变量被保留，并按0为反变量，1为原变量的原则写成乘积项形式的合并项中。",charsets:{cjk:!0}},{title:"Python",frontmatter:{},regularPath:"/python/",relativePath:"python/README.md",key:"v-392672d2",path:"/python/",headersStr:null,content:"# Python\n\n记录与Python有关的问题",normalizedContent:"# python\n\n记录与python有关的问题",charsets:{cjk:!0}},{title:"机器学习与大数据",frontmatter:{},regularPath:"/lessons/ml_and_big_data.html",relativePath:"lessons/ml_and_big_data.md",key:"v-4810ac9f",path:"/lessons/ml_and_big_data.html",headers:[{level:2,title:"模型选择",slug:"模型选择",normalizedTitle:"模型选择",charIndex:24},{level:3,title:"评估方法",slug:"评估方法",normalizedTitle:"评估方法",charIndex:206},{level:3,title:"性能度量",slug:"性能度量",normalizedTitle:"性能度量",charIndex:227},{level:3,title:"比较检验",slug:"比较检验",normalizedTitle:"比较检验",charIndex:248},{level:3,title:"误差",slug:"误差",normalizedTitle:"误差",charIndex:1120},{level:2,title:"模型",slug:"模型",normalizedTitle:"模型",charIndex:24},{level:3,title:"线性模型",slug:"线性模型",normalizedTitle:"线性模型",charIndex:3543},{level:3,title:"线性回归",slug:"线性回归",normalizedTitle:"线性回归",charIndex:3786},{level:3,title:"多元线性回归",slug:"多元线性回归",normalizedTitle:"多元线性回归",charIndex:4348},{level:3,title:"二分类任务",slug:"二分类任务",normalizedTitle:"二分类任务",charIndex:4516},{level:3,title:"对率回归",slug:"对率回归",normalizedTitle:"对率回归",charIndex:4526},{level:3,title:"极大似然法",slug:"极大似然法",normalizedTitle:"极大似然法",charIndex:4761},{level:3,title:"线性判别分析",slug:"线性判别分析",normalizedTitle:"线性判别分析",charIndex:4798},{level:3,title:"多分类问题",slug:"多分类问题",normalizedTitle:"多分类问题",charIndex:5099}],headersStr:"模型选择 评估方法 性能度量 比较检验 误差 模型 线性模型 线性回归 多元线性回归 二分类任务 对率回归 极大似然法 线性判别分析 多分类问题",content:'# 机器学习与大数据\n\n这是一门选修课\n\n\n# 模型选择\n\n比如我们训练树叶识别的模型\n\n过拟合：训练样本调为都有锯齿，把无锯齿的新样本扔进来，就会认为不是树叶（它误认为树叶是都有锯齿的）\n\n欠拟合：训练样本调为绿色，扔新样本(树)，就把树当成树叶（认为绿色的都是）\n\n----------------------------------------\n\n模型选择的三个关键问题\n\n 1. 如何获得测试结果 -> 评估方法\n 2. 如果评估性能优劣 -> 性能度量\n 3. 如何判断实质差别 -> 比较检验\n\n\n# 评估方法\n\nQ: 如何获得数据集(dataset)\n\n> 测试集可以由一些比较出名的benchmark里头翻出来找到，也可以是自己制作的数据。测试集应该要与训练集“互斥”，方法有\n> \n>  1. 留出法(hold-out)\n>  2. 交叉验证法(cross validation)\n>  3. 自助法(bootstrap)\n\n * 留出法\n\n就是在数据集中，留出了一小部分用于存放测试集(≈1/5−1/3\\approx1/5 - 1/3≈1/5−1/3)，要注意重复随机划分，要保持数据分布的一致性\n\n * k-折交叉验证法\n\n就是把数据集以一定比例分开为测试集与训练集，并且每一次训练和测试都交换一下其中一部分测试集与训练集的顺序。\n\nData1-9 (Training) + Data10 (Testing) => result1\nData1-8 Data10 + Data9 => result2\n...\n... => result n\nreturning result = avg(result1, ..., result n)\n\n\n * 自助法\n\n这个数据的采样是可放回、可重复的采样。数据分布是有所改变的，训练集与原样本集同规模。\n\n可以这么理解，你盲盒抽奖，抽到啥就放啥到新的数据集里，其中同一个物品，是有可能被多次抽到的。\n\n包外估计(out-of-bag estimation)\n\nlim⁡x→∞(1−m)m=1e≈0.368{\\lim_{x\\to \\infty}}(1-m)^m=\\frac{1}{e}\\approx 0.368 x→∞lim (1−m)m=e1 ≈0.368\n\n * 调参\n\n算法的参数：人工设定，也称之为超参数。模型的参数：一般是由学习设定。\n\n算法模型的参数修改确定之后，要用训练集和验证集来重新训练模型。\n\n涉及到：参数空间\n\n\n# 性能度量\n\n(performance measure)这是衡量模型泛化能力的评价标准，反映了任务需求\n\n回归(regression)任务常用均方误差\n\nE(f:D)=1m∑i=1m(f(xi)−yi))2E(f:D)=\\frac{1}{m}\\sum_{i=1}^{m}(f(x_{i})-y_{i}))^2 E(f:D)=m1 i=1∑m (f(xi )−yi ))2\n\n * 错误率与精度\n\nE(f;D)=1m∑i=1m∏(f(xi)≠yi)E(f;D)=\\frac{1}{m}\\sum_{i=1}^{m}\\prod (f(x_{i})\\neq y_{i}) E(f;D)=m1 i=1∑m ∏(f(xi )=yi )\n\nacc(f;D)=1m∑i=1m∏(f(xi)≠yi)acc(f;D)=\\frac{1}{m}\\sum_{i=1}^{m}\\prod (f(x_{i})\\neq y_{i}) acc(f;D)=m1 i=1∑m ∏(f(xi )=yi )\n\n----------------------------------------\n\n * 查准率与查全率\n\n英语：查准率(Precision)与查全率(Recall)\n\n预测(PREDICTION)(右)   正    反\n真实(LABEL)(下)\n正                   TP   FN\n反                   FP   TN\n\nPrecision -- 由输入为起点，看机器对dataset的判断，到底有多少是正确的\n\n查准率=TPTP+FP\\frac{TP}{TP+FP}TP+FPTP\n\nRecall -- 由结果为起点，看dataset里头到底有多少label为真的样例被挑选了出来\n\n查全率=TPTP+FN\\frac{TP}{TP+FN}TP+FNTP\n\n----------------------------------------\n\n * PR图与BEP\n\nPR全称为Precision-Recall\n\n这图就是一个二维坐标系，y轴为查准率(Precision)，x为查全率(Recall)，对一个学习器的预测结果进行多次测量之后得出的曲线。其中BEP就是平衡点，基于的是查准率=查全率的一条曲线\n\n * F1\n\n平时我们用的比BEP更多的就是F1度量了，有一个公式是这样的，它可以表示对查全率与查准率的不同偏好\n\nFβ=(1+β2)∗P∗R(β2∗P)+RF_{\\beta}=\\frac{(1+\\beta ^2) *P*R}{(\\beta ^2 *P)+R} Fβ =(β2∗P)+R(1+β2)∗P∗R\n\n其中β>1\\beta >1β>1，查全率有更大影响，反之\n\n * 宏微指标\n\n宏(macro-)与微(micro-)，应该是指的宏观微观吧，一个是求全部的，一个是对一个一个地求\n\n * ROC 与 AUC\n\nAUC: Area Under the ROC(Receiver Operating Characteristic) Curve\n\n * 非均等代价\n\n犯下不同的错误往往会造成不同的损失。此时就需要考虑非均等代价了(unequal cost)，与此还有代价敏感(cost-sensitive)公式\n\nTODO\n\n\n# 比较检验\n\n机器学习 => 概率近似准确\n\n统计假设检验为学习器性能比较提供了重要依据\n\nFriedMan检验图\n\n----------------------------------------\n\n\n# 误差\n\n在此之前先放一个表格\n\nSIGN                    MEANING\nxxx                     测试样本\nDDD                     数据集\nyDy_{D}yD               x在数据集中的标记\nyyy                     x的真实标记\nfff                     用训练集DDD训练得到的模型\nf(x;D)f(x;D)f(x;D)      由DDD训练得到的模型fff对xxx的输出\nfˉ(x)\\bar{f}(x)fˉ (x)   由模型fff对xxx的期望预测输出\n\n偏差-方差分解(bias-variance decomposition)\n\nE(f:D)=bias2(x)+var(x)+ϵ2E(f:D)={bias}^{2}(x)+var(x)+\\epsilon ^2 E(f:D)=bias2(x)+var(x)+ϵ2\n\n其中\n\nbias2(x){bias}^{2}(x)bias2(x) - 期望输出与真实输出的差别(算法本身的拟合能力)\n\nbias2=(fˉ(x)−y)2{bias}^{2}=(\\bar{f}(x)-y)^2 bias2=(fˉ (x)−y)2\n\nvar(x)var(x)var(x) - 同样大小的训练集的变动所导致的性能变化(数据的扰动)\n\nvar(x)=ED[(f(x;D)−fˉ(x))2]var(x)=\\mathbb{E}_{D}[(f(x;D)-\\bar{f}(x))^{2}] var(x)=ED [(f(x;D)−fˉ (x))2]\n\nϵ2\\epsilon^2ϵ2 - (噪声)当前任务上任何学习算法所能达到的期望泛化误差的下界(学习问题本身的难度)\n\nϵ2=ED[(yD−y)2]\\epsilon^{2}=\\mathbb{E}_{D}[(y_{D}-y)^2] ϵ2=ED [(yD −y)2]\n\n这就是泛化误差了，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度共同决定\n\n同时也提到了: 偏差-方差窘境(bias-variance dilemma)，即训练的强度不同，泛化误差就会出现不同参数的主导阶段，就是偏差主导和方差主导。\n\n----------------------------------------\n\n\n# 模型\n\n\n# 线性模型\n\nLinear model尝试学得一个通过属性的线性组合(如下公式)来进行预测的函数，把分散的东西尝试拟合都一条线性的直线上面去\n\nf(x)=ω1x1+ω2x2+...+ωdxd+bf(x)=\\omega_{1}x_{1}+\\omega_{2}x_{2}+...+\\omega_{d}x_{d}+b f(x)=ω1 x1 +ω2 x2 +...+ωd xd +b\n\n可以用矩阵简化表示\n\ny=ωTxy=\\omega^{T}x y=ωTx\n\nx是输入，f是输出的预测？\n\n\n# 线性回归\n\n * 目标函数\n\n我们要找到问题，并为此建立合适的目标函数\n\n这个函数的ω\\omegaω和b值的变化，就会使得这个函数旋转、平移变换，使得这个目标函数往分散的数据拟合\n\nf(xi)=ωxi+bf(x_{i})=\\omega x_{i}+b f(xi )=ωxi +b\n\n(w∗,b∗)=argmin(w,b)∑i=1m(f(xi)−yi)2(w^{*},b^{*})=arg min_{(w,b)}\\sum^{m}_{i=1}(f(x_{i})-y_{i})^2 (w∗,b∗)=argmin(w,b) i=1∑m (f(xi )−yi )2\n\n得到\n\n(w∗,b∗)=argmin(w,b)∑i=1m(yi−ωxi−b)2(w^{*},b^{*})=arg min_{(w,b)}\\sum^{m}_{i=1}(y_{i}-\\omega x_{i}-b)^2 (w∗,b∗)=argmin(w,b) i=1∑m (yi −ωxi −b)2\n\nE(ω,b)=∑i=1m(yi−ωxi−b)2E_{(\\omega, b)}=\\sum^{m}_{i=1}(y_{i}-\\omega x_{i}-b)^2 E(ω,b) =i=1∑m (yi −ωxi −b)2\n\n对上式进行最小二乘参数估计（令均方误差最小化）\n\n\n# 多元线性回归\n\n从这里，区别就是f(x)f(x)f(x)中的一元量xix_{i}xi 变为了多维向量xi⃗\\vec{x_{i}}xi\n\nω\\omegaω也变成矩阵了，也就是说通过矩阵变换，把x⃗\\vec{x}x所在的空间转换到了新的空间上的y⃗\\vec{y}y\n\n * 最小二乘法与矩阵求导\n\nTODO 记录一下矩阵求导的知识\n\n\n# 二分类任务\n\n\n# 对率回归\n\n这是一个分类学习的算法\n\n什么是对数几率?一个方程，其中y1−y\\frac{y}{1-y}1−yy 是几率，反映了x作为正例的相对可能性\n\nlny1−y=ωTx+bln\\frac{y}{1-y}=\\omega^{T}x+b ln1−yy =ωTx+b\n\n可以写为\n\nlnp(y=1∣x)p(y=0∣x)=ωTx+bln\\frac{p(y=1|x)}{p(y=0|x)}=\\omega^{T}x+b lnp(y=0∣x)p(y=1∣x) =ωTx+b\n\n\n# 极大似然法\n\nMaximum likelihood method\n\n\n# 线性判别分析\n\n> 用低维空间的尺子来测量高维空间的数据\n\nLinear Discriminant Analysis(LDA)\n\n将样例，投影到一条直线，即低维空间。称为一种"监督降维"技术。比如高维样本投到一条直线（关键就是找这条直线）y=ωTxy=\\omega^{T}xy=ωTx上面的点来（将矩阵变为标量），其中ω\\omegaω可变。\n\n要使得同样例的投影点尽可能近，异类例的投影尽可能远。\n\n * 协方差\n\n某个样本到中心的距离，类比二维三维点坐标的距离\n\n(x⃗−u⃗)T(x⃗−u⃗)(\\vec{x}-\\vec{u})^T(\\vec{x}-\\vec{u}) (x−u)T(x−u)\n\n\n# 多分类问题\n\n思路就是拆成了多个二分类',normalizedContent:'# 机器学习与大数据\n\n这是一门选修课\n\n\n# 模型选择\n\n比如我们训练树叶识别的模型\n\n过拟合：训练样本调为都有锯齿，把无锯齿的新样本扔进来，就会认为不是树叶（它误认为树叶是都有锯齿的）\n\n欠拟合：训练样本调为绿色，扔新样本(树)，就把树当成树叶（认为绿色的都是）\n\n----------------------------------------\n\n模型选择的三个关键问题\n\n 1. 如何获得测试结果 -> 评估方法\n 2. 如果评估性能优劣 -> 性能度量\n 3. 如何判断实质差别 -> 比较检验\n\n\n# 评估方法\n\nq: 如何获得数据集(dataset)\n\n> 测试集可以由一些比较出名的benchmark里头翻出来找到，也可以是自己制作的数据。测试集应该要与训练集“互斥”，方法有\n> \n>  1. 留出法(hold-out)\n>  2. 交叉验证法(cross validation)\n>  3. 自助法(bootstrap)\n\n * 留出法\n\n就是在数据集中，留出了一小部分用于存放测试集(≈1/5−1/3\\approx1/5 - 1/3≈1/5−1/3)，要注意重复随机划分，要保持数据分布的一致性\n\n * k-折交叉验证法\n\n就是把数据集以一定比例分开为测试集与训练集，并且每一次训练和测试都交换一下其中一部分测试集与训练集的顺序。\n\ndata1-9 (training) + data10 (testing) => result1\ndata1-8 data10 + data9 => result2\n...\n... => result n\nreturning result = avg(result1, ..., result n)\n\n\n * 自助法\n\n这个数据的采样是可放回、可重复的采样。数据分布是有所改变的，训练集与原样本集同规模。\n\n可以这么理解，你盲盒抽奖，抽到啥就放啥到新的数据集里，其中同一个物品，是有可能被多次抽到的。\n\n包外估计(out-of-bag estimation)\n\nlim⁡x→∞(1−m)m=1e≈0.368{\\lim_{x\\to \\infty}}(1-m)^m=\\frac{1}{e}\\approx 0.368 x→∞lim (1−m)m=e1 ≈0.368\n\n * 调参\n\n算法的参数：人工设定，也称之为超参数。模型的参数：一般是由学习设定。\n\n算法模型的参数修改确定之后，要用训练集和验证集来重新训练模型。\n\n涉及到：参数空间\n\n\n# 性能度量\n\n(performance measure)这是衡量模型泛化能力的评价标准，反映了任务需求\n\n回归(regression)任务常用均方误差\n\ne(f:d)=1m∑i=1m(f(xi)−yi))2e(f:d)=\\frac{1}{m}\\sum_{i=1}^{m}(f(x_{i})-y_{i}))^2 e(f:d)=m1 i=1∑m (f(xi )−yi ))2\n\n * 错误率与精度\n\ne(f;d)=1m∑i=1m∏(f(xi)=yi)e(f;d)=\\frac{1}{m}\\sum_{i=1}^{m}\\prod (f(x_{i})\\neq y_{i}) e(f;d)=m1 i=1∑m ∏(f(xi )=yi )\n\nacc(f;d)=1m∑i=1m∏(f(xi)=yi)acc(f;d)=\\frac{1}{m}\\sum_{i=1}^{m}\\prod (f(x_{i})\\neq y_{i}) acc(f;d)=m1 i=1∑m ∏(f(xi )=yi )\n\n----------------------------------------\n\n * 查准率与查全率\n\n英语：查准率(precision)与查全率(recall)\n\n预测(prediction)(右)   正    反\n真实(label)(下)\n正                   tp   fn\n反                   fp   tn\n\nprecision -- 由输入为起点，看机器对dataset的判断，到底有多少是正确的\n\n查准率=tptp+fp\\frac{tp}{tp+fp}tp+fptp\n\nrecall -- 由结果为起点，看dataset里头到底有多少label为真的样例被挑选了出来\n\n查全率=tptp+fn\\frac{tp}{tp+fn}tp+fntp\n\n----------------------------------------\n\n * pr图与bep\n\npr全称为precision-recall\n\n这图就是一个二维坐标系，y轴为查准率(precision)，x为查全率(recall)，对一个学习器的预测结果进行多次测量之后得出的曲线。其中bep就是平衡点，基于的是查准率=查全率的一条曲线\n\n * f1\n\n平时我们用的比bep更多的就是f1度量了，有一个公式是这样的，它可以表示对查全率与查准率的不同偏好\n\nfβ=(1+β2)∗p∗r(β2∗p)+rf_{\\beta}=\\frac{(1+\\beta ^2) *p*r}{(\\beta ^2 *p)+r} fβ =(β2∗p)+r(1+β2)∗p∗r\n\n其中β>1\\beta >1β>1，查全率有更大影响，反之\n\n * 宏微指标\n\n宏(macro-)与微(micro-)，应该是指的宏观微观吧，一个是求全部的，一个是对一个一个地求\n\n * roc 与 auc\n\nauc: area under the roc(receiver operating characteristic) curve\n\n * 非均等代价\n\n犯下不同的错误往往会造成不同的损失。此时就需要考虑非均等代价了(unequal cost)，与此还有代价敏感(cost-sensitive)公式\n\ntodo\n\n\n# 比较检验\n\n机器学习 => 概率近似准确\n\n统计假设检验为学习器性能比较提供了重要依据\n\nfriedman检验图\n\n----------------------------------------\n\n\n# 误差\n\n在此之前先放一个表格\n\nsign                    meaning\nxxx                     测试样本\nddd                     数据集\nydy_{d}yd               x在数据集中的标记\nyyy                     x的真实标记\nfff                     用训练集ddd训练得到的模型\nf(x;d)f(x;d)f(x;d)      由ddd训练得到的模型fff对xxx的输出\nfˉ(x)\\bar{f}(x)fˉ (x)   由模型fff对xxx的期望预测输出\n\n偏差-方差分解(bias-variance decomposition)\n\ne(f:d)=bias2(x)+var(x)+ϵ2e(f:d)={bias}^{2}(x)+var(x)+\\epsilon ^2 e(f:d)=bias2(x)+var(x)+ϵ2\n\n其中\n\nbias2(x){bias}^{2}(x)bias2(x) - 期望输出与真实输出的差别(算法本身的拟合能力)\n\nbias2=(fˉ(x)−y)2{bias}^{2}=(\\bar{f}(x)-y)^2 bias2=(fˉ (x)−y)2\n\nvar(x)var(x)var(x) - 同样大小的训练集的变动所导致的性能变化(数据的扰动)\n\nvar(x)=ed[(f(x;d)−fˉ(x))2]var(x)=\\mathbb{e}_{d}[(f(x;d)-\\bar{f}(x))^{2}] var(x)=ed [(f(x;d)−fˉ (x))2]\n\nϵ2\\epsilon^2ϵ2 - (噪声)当前任务上任何学习算法所能达到的期望泛化误差的下界(学习问题本身的难度)\n\nϵ2=ed[(yd−y)2]\\epsilon^{2}=\\mathbb{e}_{d}[(y_{d}-y)^2] ϵ2=ed [(yd −y)2]\n\n这就是泛化误差了，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度共同决定\n\n同时也提到了: 偏差-方差窘境(bias-variance dilemma)，即训练的强度不同，泛化误差就会出现不同参数的主导阶段，就是偏差主导和方差主导。\n\n----------------------------------------\n\n\n# 模型\n\n\n# 线性模型\n\nlinear model尝试学得一个通过属性的线性组合(如下公式)来进行预测的函数，把分散的东西尝试拟合都一条线性的直线上面去\n\nf(x)=ω1x1+ω2x2+...+ωdxd+bf(x)=\\omega_{1}x_{1}+\\omega_{2}x_{2}+...+\\omega_{d}x_{d}+b f(x)=ω1 x1 +ω2 x2 +...+ωd xd +b\n\n可以用矩阵简化表示\n\ny=ωtxy=\\omega^{t}x y=ωtx\n\nx是输入，f是输出的预测？\n\n\n# 线性回归\n\n * 目标函数\n\n我们要找到问题，并为此建立合适的目标函数\n\n这个函数的ω\\omegaω和b值的变化，就会使得这个函数旋转、平移变换，使得这个目标函数往分散的数据拟合\n\nf(xi)=ωxi+bf(x_{i})=\\omega x_{i}+b f(xi )=ωxi +b\n\n(w∗,b∗)=argmin(w,b)∑i=1m(f(xi)−yi)2(w^{*},b^{*})=arg min_{(w,b)}\\sum^{m}_{i=1}(f(x_{i})-y_{i})^2 (w∗,b∗)=argmin(w,b) i=1∑m (f(xi )−yi )2\n\n得到\n\n(w∗,b∗)=argmin(w,b)∑i=1m(yi−ωxi−b)2(w^{*},b^{*})=arg min_{(w,b)}\\sum^{m}_{i=1}(y_{i}-\\omega x_{i}-b)^2 (w∗,b∗)=argmin(w,b) i=1∑m (yi −ωxi −b)2\n\ne(ω,b)=∑i=1m(yi−ωxi−b)2e_{(\\omega, b)}=\\sum^{m}_{i=1}(y_{i}-\\omega x_{i}-b)^2 e(ω,b) =i=1∑m (yi −ωxi −b)2\n\n对上式进行最小二乘参数估计（令均方误差最小化）\n\n\n# 多元线性回归\n\n从这里，区别就是f(x)f(x)f(x)中的一元量xix_{i}xi 变为了多维向量xi⃗\\vec{x_{i}}xi\n\nω\\omegaω也变成矩阵了，也就是说通过矩阵变换，把x⃗\\vec{x}x所在的空间转换到了新的空间上的y⃗\\vec{y}y\n\n * 最小二乘法与矩阵求导\n\ntodo 记录一下矩阵求导的知识\n\n\n# 二分类任务\n\n\n# 对率回归\n\n这是一个分类学习的算法\n\n什么是对数几率?一个方程，其中y1−y\\frac{y}{1-y}1−yy 是几率，反映了x作为正例的相对可能性\n\nlny1−y=ωtx+bln\\frac{y}{1-y}=\\omega^{t}x+b ln1−yy =ωtx+b\n\n可以写为\n\nlnp(y=1∣x)p(y=0∣x)=ωtx+bln\\frac{p(y=1|x)}{p(y=0|x)}=\\omega^{t}x+b lnp(y=0∣x)p(y=1∣x) =ωtx+b\n\n\n# 极大似然法\n\nmaximum likelihood method\n\n\n# 线性判别分析\n\n> 用低维空间的尺子来测量高维空间的数据\n\nlinear discriminant analysis(lda)\n\n将样例，投影到一条直线，即低维空间。称为一种"监督降维"技术。比如高维样本投到一条直线（关键就是找这条直线）y=ωtxy=\\omega^{t}xy=ωtx上面的点来（将矩阵变为标量），其中ω\\omegaω可变。\n\n要使得同样例的投影点尽可能近，异类例的投影尽可能远。\n\n * 协方差\n\n某个样本到中心的距离，类比二维三维点坐标的距离\n\n(x⃗−u⃗)t(x⃗−u⃗)(\\vec{x}-\\vec{u})^t(\\vec{x}-\\vec{u}) (x−u)t(x−u)\n\n\n# 多分类问题\n\n思路就是拆成了多个二分类',charsets:{cjk:!0}},{title:"鸭子类型",frontmatter:{},regularPath:"/python/ducking_type.html",relativePath:"python/ducking_type.md",key:"v-7ee3a2d9",path:"/python/ducking_type.html",headers:[{level:2,title:"What it is",slug:"what-it-is",normalizedTitle:"what it is",charIndex:58},{level:2,title:"静态语言",slug:"静态语言",normalizedTitle:"静态语言",charIndex:1249}],headersStr:"What it is 静态语言",content:"# 鸭子类型\n\n一语言要实现多态，方法不仅只有一种，这里主要介绍一下动态语言所用的Ducking Type\n\n\n# What it is\n\n什么是鸭子类型(Ducking type)呢？\n\n这是一种多态的实现方式，在弱类型的动态语言中经常出现，比如python/javascript甚至是golang都有。\n\n有一个idiom，叫做\n\n> If it looks like a duck and quacks like a duck, it's a duck.\n\n也就是说，一个东西看起来像鸭子，叫起来也像鸭子，那么它就是一只鸭子。\n\n那么，一个对象看起来是鸭子，行为也很像鸭子，那么它这个对象就是一只鸭子。即\n\n> Duck Typing means that an object is defined by what it can do, not by what it is.\n\n因此我们关心的不是对象的类型，而是这个对象到底是什么，它能做什么。\n\n举个例子\n\nclass Animal:\n    def who(self):\n        print ('I am a generic animal')\n\nclass Duck(Animal):\n    def who(self):\n        print ('I am a duck')\n\nclass Cat(Animal):\n    def who(self):\n        print ('I am a cat')\n\nclass Dog(Animal):\n    def who(self):\n        print ('I am a dog')\n\ndef identify(obj):\n    obj.who()\n\nduck = Duck()\ncat = Cat()\ndog = Dog()\n\nidentify(duck)\nidentify(cat)\nidentify(dog)\n\n\n输出结果是\n\nI am a duck\nI am a cat\nI am a dog\n\n\n而如果我们写\n\nidentify('animal')\n\n\n就会得到错误\n\nTraceback (most recent call last):\n  File \"c:/Users/situ/codes/python/test1.py\", line 28, in <module>\n    identify('animal')\n  File \"c:/Users/situ/codes/python/test1.py\", line 18, in identify\n    obj.who()\nAttributeError: 'str' object has no attribute 'who'\n\n\n那么看起来就是根据property/attribute来调用相对应的方法，这就保证了鸭子就是鸭子，猫就是猫，狗就是狗。动态语言就是由此实现了多态。\n\n\n# 静态语言\n\n一些静态语言，比如Java/C++就不是这样子实现的了，它们的class有很强的等级制度。比如\n\nclass Test {\n    class Animal {\n        public abstract void who();\n    }\n\n    class Duck extends Animal {\n    public void who() {\n        System.out.println(\"I am a duck\");\n    }\n\n    public static void identify(Object obj) {\n        obj.who();\n    }\n\n    public static void main(String[] args) {\n        Duck duck = new Duck();\n        identity(duck);\n    }\n}\n\n\n这上面的是错误的，因为此时传进去的duck，其declared type就是Object，而Object并没有who()这个方法，因此在identify()中，可以这样做。\n\nif (obj instanceof Animal) {\n    ((Animal)obj).who();\n}\n\n\n或者\n\npublic static void identify(Animal animal) {\n    animal.who();\n}\n\n\n这就是许多静态语言实现多态的方式。",normalizedContent:"# 鸭子类型\n\n一语言要实现多态，方法不仅只有一种，这里主要介绍一下动态语言所用的ducking type\n\n\n# what it is\n\n什么是鸭子类型(ducking type)呢？\n\n这是一种多态的实现方式，在弱类型的动态语言中经常出现，比如python/javascript甚至是golang都有。\n\n有一个idiom，叫做\n\n> if it looks like a duck and quacks like a duck, it's a duck.\n\n也就是说，一个东西看起来像鸭子，叫起来也像鸭子，那么它就是一只鸭子。\n\n那么，一个对象看起来是鸭子，行为也很像鸭子，那么它这个对象就是一只鸭子。即\n\n> duck typing means that an object is defined by what it can do, not by what it is.\n\n因此我们关心的不是对象的类型，而是这个对象到底是什么，它能做什么。\n\n举个例子\n\nclass animal:\n    def who(self):\n        print ('i am a generic animal')\n\nclass duck(animal):\n    def who(self):\n        print ('i am a duck')\n\nclass cat(animal):\n    def who(self):\n        print ('i am a cat')\n\nclass dog(animal):\n    def who(self):\n        print ('i am a dog')\n\ndef identify(obj):\n    obj.who()\n\nduck = duck()\ncat = cat()\ndog = dog()\n\nidentify(duck)\nidentify(cat)\nidentify(dog)\n\n\n输出结果是\n\ni am a duck\ni am a cat\ni am a dog\n\n\n而如果我们写\n\nidentify('animal')\n\n\n就会得到错误\n\ntraceback (most recent call last):\n  file \"c:/users/situ/codes/python/test1.py\", line 28, in <module>\n    identify('animal')\n  file \"c:/users/situ/codes/python/test1.py\", line 18, in identify\n    obj.who()\nattributeerror: 'str' object has no attribute 'who'\n\n\n那么看起来就是根据property/attribute来调用相对应的方法，这就保证了鸭子就是鸭子，猫就是猫，狗就是狗。动态语言就是由此实现了多态。\n\n\n# 静态语言\n\n一些静态语言，比如java/c++就不是这样子实现的了，它们的class有很强的等级制度。比如\n\nclass test {\n    class animal {\n        public abstract void who();\n    }\n\n    class duck extends animal {\n    public void who() {\n        system.out.println(\"i am a duck\");\n    }\n\n    public static void identify(object obj) {\n        obj.who();\n    }\n\n    public static void main(string[] args) {\n        duck duck = new duck();\n        identity(duck);\n    }\n}\n\n\n这上面的是错误的，因为此时传进去的duck，其declared type就是object，而object并没有who()这个方法，因此在identify()中，可以这样做。\n\nif (obj instanceof animal) {\n    ((animal)obj).who();\n}\n\n\n或者\n\npublic static void identify(animal animal) {\n    animal.who();\n}\n\n\n这就是许多静态语言实现多态的方式。",charsets:{cjk:!0}},{title:"包管理",frontmatter:{},regularPath:"/nodejs/package_management.html",relativePath:"nodejs/package_management.md",key:"v-1e31d6f9",path:"/nodejs/package_management.html",headers:[{level:2,title:"npm vs npx",slug:"npm-vs-npx",normalizedTitle:"npm vs npx",charIndex:21},{level:2,title:"ES2015模块",slug:"es2015模块",normalizedTitle:"es2015模块",charIndex:37}],headersStr:"npm vs npx ES2015模块",content:"# 包管理\n\n\n\n * 包管理\n   * npm vs npx\n   * ES2015模块\n\n\n\n主要是npm和yarn\n\n\n# npm vs npx\n\n前者用来进行包管理用的，后者用来单纯执行包用的，就是带来了便利性。\n\n前者要用包的话需要把包下载到本地存着，再执行。后者是把包下到本地临时目录，临时地执行它，使用它。\n\n * npM - Management\n * npX - eXcute\n\n\n# ES2015模块\n\n怎么说呢，nodejs支持commonJS和ES2015的模块。cjs是同步加载的，es6模块是异步加载的。\n\ncommonJS: require()来加载，module.export输出\n\nES2015: import加载，export输出\n\ncjs不能加载es6的模块，因为后者是异步加载且内部可以使用await。这样一来，如果用require()加载，整个代码就会卡在await的那里。直到await的部分执行完毕才继续执行。\n\nES2015模块在加载之前有一个静态解析阶段，来确定依赖关系，因此，最底层的模块是第一个被加载的。\n\nCommonJS to ES2015 module，只能先整体引入。单独引用一部分就继续import。同理，export的时候，cjs到es6就也可以这样做，加个wrapper\n\nimport packageMain from 'commonjs-package';\nconst { method } = packageMain;\n\n// import then export (CommonJS to ES2015 module)\nimport cjsModule from '../index.js';\nexport const foo = cjsModule.foo; \n",normalizedContent:"# 包管理\n\n\n\n * 包管理\n   * npm vs npx\n   * es2015模块\n\n\n\n主要是npm和yarn\n\n\n# npm vs npx\n\n前者用来进行包管理用的，后者用来单纯执行包用的，就是带来了便利性。\n\n前者要用包的话需要把包下载到本地存着，再执行。后者是把包下到本地临时目录，临时地执行它，使用它。\n\n * npm - management\n * npx - excute\n\n\n# es2015模块\n\n怎么说呢，nodejs支持commonjs和es2015的模块。cjs是同步加载的，es6模块是异步加载的。\n\ncommonjs: require()来加载，module.export输出\n\nes2015: import加载，export输出\n\ncjs不能加载es6的模块，因为后者是异步加载且内部可以使用await。这样一来，如果用require()加载，整个代码就会卡在await的那里。直到await的部分执行完毕才继续执行。\n\nes2015模块在加载之前有一个静态解析阶段，来确定依赖关系，因此，最底层的模块是第一个被加载的。\n\ncommonjs to es2015 module，只能先整体引入。单独引用一部分就继续import。同理，export的时候，cjs到es6就也可以这样做，加个wrapper\n\nimport packagemain from 'commonjs-package';\nconst { method } = packagemain;\n\n// import then export (commonjs to es2015 module)\nimport cjsmodule from '../index.js';\nexport const foo = cjsmodule.foo; \n",charsets:{cjk:!0}},{title:"内建功能",frontmatter:{},regularPath:"/python/built_in_things.html",relativePath:"python/built_in_things.md",key:"v-41a40162",path:"/python/built_in_things.html",headers:[{level:2,title:"help",slug:"help",normalizedTitle:"help",charIndex:36},{level:2,title:"pydoc",slug:"pydoc",normalizedTitle:"pydoc",charIndex:861}],headersStr:"help pydoc",content:'# 内建功能\n\n对于python的内建类、模组和函数的一些笔记\n\n\n# help\n\nhelp([object])\n\n这是一个内置的函数，可以获得指定的一个类、方法、模组等的帮助，其实这些帮助，是从docstring这里derive过来的，比如我这里写点docstring，像下面这样，注意写的位置，是在函数或类的body的第一行处写。文字前后用三个双引号圈起来（这很像多行注释）\n\nclass Bar(object):\n    """a bar class"""\n    def __init__(self) -> None:\n        """initialize a Bar"""\n        super().__init__()\n    def foo(self):\n        """\n        a foo method\n\n        For example\n\n        ```python\n        print (Bar().foo()) # 114514\n        ```\n\n        return `114514`\n        """\n        return 114514\n\n\n这个docstring存于属性__doc__之中，此时我们这样\n\nprint (Bar.__doc__)\nprint (Bar.__init__.__doc__)\nprint (Bar.foo.__doc__)\n\n\n或者\n\nhelp(Bar)\nhelp(Bar.__init__)\nhelp(Bar.foo)\n\n\n都可得到如下结果\n\na bar class\ninitialize a Bar\n\n        a foo method\n\n        For example\n\n        ```python\n        print (Bar().foo()) # 114514\n        ```\n\n        return `114514`\n\n\n\n# pydoc\n\n链接：点击此处\n\n为什么我要在help()函数下面写这个？因为pydoc生成的文档，靠的就是它内建有的help()函数啊。用法都在官方文档里头了，举个例子，把上面的代码文档生成一下。可以这么做，像下面\n\npython -m pydoc doc_test # 直接在命令行看doc_test模块的文档\npython -m pydoc -p 8080 # 生成指定目录下所有py的文档，并可在http://localhost:8080上访问\npython -m pydoc -w doc_test # 生成并保存模块doc_test的文档为HTML到当前目录下\npython -m pydoc -k test # 模糊查找含有该字符串的模块的文档\n',normalizedContent:'# 内建功能\n\n对于python的内建类、模组和函数的一些笔记\n\n\n# help\n\nhelp([object])\n\n这是一个内置的函数，可以获得指定的一个类、方法、模组等的帮助，其实这些帮助，是从docstring这里derive过来的，比如我这里写点docstring，像下面这样，注意写的位置，是在函数或类的body的第一行处写。文字前后用三个双引号圈起来（这很像多行注释）\n\nclass bar(object):\n    """a bar class"""\n    def __init__(self) -> none:\n        """initialize a bar"""\n        super().__init__()\n    def foo(self):\n        """\n        a foo method\n\n        for example\n\n        ```python\n        print (bar().foo()) # 114514\n        ```\n\n        return `114514`\n        """\n        return 114514\n\n\n这个docstring存于属性__doc__之中，此时我们这样\n\nprint (bar.__doc__)\nprint (bar.__init__.__doc__)\nprint (bar.foo.__doc__)\n\n\n或者\n\nhelp(bar)\nhelp(bar.__init__)\nhelp(bar.foo)\n\n\n都可得到如下结果\n\na bar class\ninitialize a bar\n\n        a foo method\n\n        for example\n\n        ```python\n        print (bar().foo()) # 114514\n        ```\n\n        return `114514`\n\n\n\n# pydoc\n\n链接：点击此处\n\n为什么我要在help()函数下面写这个？因为pydoc生成的文档，靠的就是它内建有的help()函数啊。用法都在官方文档里头了，举个例子，把上面的代码文档生成一下。可以这么做，像下面\n\npython -m pydoc doc_test # 直接在命令行看doc_test模块的文档\npython -m pydoc -p 8080 # 生成指定目录下所有py的文档，并可在http://localhost:8080上访问\npython -m pydoc -w doc_test # 生成并保存模块doc_test的文档为html到当前目录下\npython -m pydoc -k test # 模糊查找含有该字符串的模块的文档\n',charsets:{cjk:!0}},{title:"特有句法",frontmatter:{},regularPath:"/python/special.html",relativePath:"python/special.md",key:"v-621b90ce",path:"/python/special.html",headers:[{level:2,title:"比较",slug:"比较",normalizedTitle:"比较",charIndex:31},{level:2,title:"三目运算符",slug:"三目运算符",normalizedTitle:"三目运算符",charIndex:115},{level:2,title:"重复",slug:"重复",normalizedTitle:"重复",charIndex:197},{level:2,title:"反转",slug:"反转",normalizedTitle:"反转",charIndex:259},{level:2,title:"赋值",slug:"赋值",normalizedTitle:"赋值",charIndex:308},{level:2,title:"合并列表与字典",slug:"合并列表与字典",normalizedTitle:"合并列表与字典",charIndex:370},{level:2,title:"列表降维",slug:"列表降维",normalizedTitle:"列表降维",charIndex:594},{level:2,title:"iterate with enumerate",slug:"iterate-with-enumerate",normalizedTitle:"iterate with enumerate",charIndex:738},{level:2,title:"list to str",slug:"list-to-str",normalizedTitle:"list to str",charIndex:920},{level:2,title:"list to dict",slug:"list-to-dict",normalizedTitle:"list to dict",charIndex:995},{level:2,title:"dict reverse",slug:"dict-reverse",normalizedTitle:"dict reverse",charIndex:1129},{level:2,title:"isinstance",slug:"isinstance",normalizedTitle:"isinstance",charIndex:1295},{level:2,title:"zip",slug:"zip",normalizedTitle:"zip",charIndex:1081},{level:2,title:"Comprehensions",slug:"comprehensions",normalizedTitle:"comprehensions",charIndex:1568},{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:1805}],headersStr:"比较 三目运算符 重复 反转 赋值 合并列表与字典 列表降维 iterate with enumerate list to str list to dict dict reverse isinstance zip Comprehensions Generator",content:"# 特有句法\n\n其实py有许多与众不同的syntax\n\n\n# 比较\n\nif (114 < a < 514) # it is possible!\nif (a > 114 and a < 514) # equivalent\n\n\n\n# 三目运算符\n\na = i > 15 ? 114 : 514 # wrong!\na = 114 if i > 15 else 514 # Correct!\n\n\n\n# 重复\n\nstr = 'dssq'*3 # dssqdssqdssq\nlist = [1, 9]*2 # 1919\n\n\n\n# 反转\n\nstr = 'hello'\nprint (str[::-1]) # olleh\n\n\n\n# 赋值\n\na, b, c = 1, 3, 5\naccuracy, label = ([15], [114514])\n\n\n\n# 合并列表与字典\n\nfoo = {\n    'a': 114,\n    'b': 514\n}\n\nbar = [1919, 810]\n\nprint ({**foo, **foo})\nprint ([*bar, *bar])\n# or\nbar.extend(bar)\nprint (bar)\n\n'''\n{'a': 114, 'b': 514}\n[1919, 810, 1919, 810]\n[1919, 810, 1919, 810]\n'''\n\n\n\n# 列表降维\n\nimport itertools\n\nfoo = [[2, 3], [114, 514], [1919, 810]]\nit = itertools.chain(*foo)\n\nprint (list(it)) # [2, 3, 114, 514, 1919, 810]\n\n\n\n# iterate with enumerate\n\nfoo = [2, 3, 114, 514, 1919, 810]\n\nfor id, item in enumerate(foo):\n    print ('{}: {}'.format(id, item))\n\n'''\n0: 2\n1: 3\n2: 114\n3: 514\n4: 1919\n5: 810\n'''\n\n\n\n# list to str\n\nfoo = ['d', 'ss', 'q']\ns = ''.join(foo)\nprint (s) # dssq\n\n\n\n# list to dict\n\nfoo = [x for x in range(4)]\nbar = [x**2 for x in range(4)]\n\nprint (dict(zip(foo, bar))) # {0: 0, 1: 1, 2: 4, 3: 9}\n\n\n\n# dict reverse\n\nfoo = [x for x in range(4)]\nbar = [x**2 for x in range(4)]\n\nd = dict(zip(foo, bar)) # {0: 0, 1: 1, 2: 4, 3: 9}\ne = dict(zip(d.values(), d.keys()))\n\n\n\n# isinstance\n\nfoo = 14\nisinstance(foo, (int, list)) # True\n\n\n\n# zip\n\n传iteratable进去\n\nfoo = [1, 2, 3, 4, 5]\nbar = ['a', 'b', 'c']\n\nprint (list(zip(foo, bar)))\n\nfor a, b in zip(foo, bar):\n    print ('{} {}'.format(a, b))\n\n'''\n[(1, 'a'), (2, 'b'), (3, 'c')]\n1 a\n2 b\n3 c\n'''\n\n\n\n# Comprehensions\n\n也就是推导式\n\nfoo = [x**2 for x in range(5)] # [0, 1, 4, 9, 16]\nbar = {x: x**2 for x in range(5)} # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\nfoo1 = [x for x in foo if x > 8] # [9, 16]\nenum = {x for x in range(1, 5)} # {1, 2, 3, 4}\n\n\n\n# Generator\n\n像Java的iterator()(消费者)\n\nfoo = (x for x in range(5))\nfoo.__next__() # 0\nfoo.__next__() # 1\n# ...\n\nfor item in foo:\n    print (item) # 2, 3, 4\n",normalizedContent:"# 特有句法\n\n其实py有许多与众不同的syntax\n\n\n# 比较\n\nif (114 < a < 514) # it is possible!\nif (a > 114 and a < 514) # equivalent\n\n\n\n# 三目运算符\n\na = i > 15 ? 114 : 514 # wrong!\na = 114 if i > 15 else 514 # correct!\n\n\n\n# 重复\n\nstr = 'dssq'*3 # dssqdssqdssq\nlist = [1, 9]*2 # 1919\n\n\n\n# 反转\n\nstr = 'hello'\nprint (str[::-1]) # olleh\n\n\n\n# 赋值\n\na, b, c = 1, 3, 5\naccuracy, label = ([15], [114514])\n\n\n\n# 合并列表与字典\n\nfoo = {\n    'a': 114,\n    'b': 514\n}\n\nbar = [1919, 810]\n\nprint ({**foo, **foo})\nprint ([*bar, *bar])\n# or\nbar.extend(bar)\nprint (bar)\n\n'''\n{'a': 114, 'b': 514}\n[1919, 810, 1919, 810]\n[1919, 810, 1919, 810]\n'''\n\n\n\n# 列表降维\n\nimport itertools\n\nfoo = [[2, 3], [114, 514], [1919, 810]]\nit = itertools.chain(*foo)\n\nprint (list(it)) # [2, 3, 114, 514, 1919, 810]\n\n\n\n# iterate with enumerate\n\nfoo = [2, 3, 114, 514, 1919, 810]\n\nfor id, item in enumerate(foo):\n    print ('{}: {}'.format(id, item))\n\n'''\n0: 2\n1: 3\n2: 114\n3: 514\n4: 1919\n5: 810\n'''\n\n\n\n# list to str\n\nfoo = ['d', 'ss', 'q']\ns = ''.join(foo)\nprint (s) # dssq\n\n\n\n# list to dict\n\nfoo = [x for x in range(4)]\nbar = [x**2 for x in range(4)]\n\nprint (dict(zip(foo, bar))) # {0: 0, 1: 1, 2: 4, 3: 9}\n\n\n\n# dict reverse\n\nfoo = [x for x in range(4)]\nbar = [x**2 for x in range(4)]\n\nd = dict(zip(foo, bar)) # {0: 0, 1: 1, 2: 4, 3: 9}\ne = dict(zip(d.values(), d.keys()))\n\n\n\n# isinstance\n\nfoo = 14\nisinstance(foo, (int, list)) # true\n\n\n\n# zip\n\n传iteratable进去\n\nfoo = [1, 2, 3, 4, 5]\nbar = ['a', 'b', 'c']\n\nprint (list(zip(foo, bar)))\n\nfor a, b in zip(foo, bar):\n    print ('{} {}'.format(a, b))\n\n'''\n[(1, 'a'), (2, 'b'), (3, 'c')]\n1 a\n2 b\n3 c\n'''\n\n\n\n# comprehensions\n\n也就是推导式\n\nfoo = [x**2 for x in range(5)] # [0, 1, 4, 9, 16]\nbar = {x: x**2 for x in range(5)} # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\nfoo1 = [x for x in foo if x > 8] # [9, 16]\nenum = {x for x in range(1, 5)} # {1, 2, 3, 4}\n\n\n\n# generator\n\n像java的iterator()(消费者)\n\nfoo = (x for x in range(5))\nfoo.__next__() # 0\nfoo.__next__() # 1\n# ...\n\nfor item in foo:\n    print (item) # 2, 3, 4\n",charsets:{cjk:!0}},{title:"问题记录",frontmatter:{},regularPath:"/nodejs/problems.html",relativePath:"nodejs/problems.md",key:"v-e0b82d0e",path:"/nodejs/problems.html",headers:[{level:2,title:"非链式Promise catch",slug:"非链式promise-catch",normalizedTitle:"非链式promise catch",charIndex:11},{level:2,title:"ES2015 module报错",slug:"es2015-module报错",normalizedTitle:"es2015 module报错",charIndex:462}],headersStr:"非链式Promise catch ES2015 module报错",content:'# 问题记录\n\n\n# 非链式Promise catch\n\n记录时为2020/03/24\n\n直接报错\n\n(node:4796) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: spawn cmd ENOENT\n[1] (node:4796) DeprecationWarning: Unhandled promise rejections are deprecated.\nIn the future, promise rejections that are not handled will terminate the Node.\njs process with a non-zero exit code.\n\n\nHandle error，在nodejs里，必须要是链式调用才行\n\nlet foo = new Promise(...);\nfoo.then(...).catch(...);\n\n\n\n# ES2015 module报错\n\n记录时为2020/03/25\n\nSyntaxError: Cannot use import statement outside a module\n\n\n需要在package.json里头加上"type": "module"\n\n> Node.js treats JavaScript code as CommonJS modules by default. Authors can tell Node.js to treat JavaScript code as ECMAScript modules via the .mjs file extension, the package.json "type" field, or the --input-type flag',normalizedContent:'# 问题记录\n\n\n# 非链式promise catch\n\n记录时为2020/03/24\n\n直接报错\n\n(node:4796) unhandledpromiserejectionwarning: unhandled promise rejection (rejection id: 1): error: spawn cmd enoent\n[1] (node:4796) deprecationwarning: unhandled promise rejections are deprecated.\nin the future, promise rejections that are not handled will terminate the node.\njs process with a non-zero exit code.\n\n\nhandle error，在nodejs里，必须要是链式调用才行\n\nlet foo = new promise(...);\nfoo.then(...).catch(...);\n\n\n\n# es2015 module报错\n\n记录时为2020/03/25\n\nsyntaxerror: cannot use import statement outside a module\n\n\n需要在package.json里头加上"type": "module"\n\n> node.js treats javascript code as commonjs modules by default. authors can tell node.js to treat javascript code as ecmascript modules via the .mjs file extension, the package.json "type" field, or the --input-type flag',charsets:{cjk:!0}},{title:"问题记录",frontmatter:{},regularPath:"/python/problems.html",relativePath:"python/problems.md",key:"v-104f3dd9",path:"/python/problems.html",headers:[{level:2,title:"Asterisk",slug:"asterisk",normalizedTitle:"asterisk",charIndex:11},{level:2,title:"Traceback",slug:"traceback",normalizedTitle:"traceback",charIndex:741},{level:2,title:"list vs array",slug:"list-vs-array",normalizedTitle:"list vs array",charIndex:1170},{level:2,title:"scope",slug:"scope",normalizedTitle:"scope",charIndex:1365},{level:2,title:"main",slug:"main",normalizedTitle:"main",charIndex:1612}],headersStr:"Asterisk Traceback list vs array scope main",content:"# 问题记录\n\n\n# Asterisk\n\nConversion between collections and arguments\n\n通常发生在函数invocation中。将参数转化为元组或者字典\n\n* collects all the positional arguments in a tuple.\n\n** collects all the keyword arguments in a dictionary.\n\ndef func(*args, **kargs):\n    # ...\nfunc(1, 14, 514, a=1, b=2, c=3)\n# args=[1, 14, 514] kargs = {'a':1, 'b':2, 'c':3}\n\n\n要列表、元组或字典解包为参数的时候，就可以这么做\n\n* unpacks a list or tuple into position arguments.\n\n** unpacks a dictionary into keyword arguments.\n\nl = [114, 514] # f(*l) -> f(114, 514)\nd = {'a': 114, 'b': 514} # f(**d) -> f(a=114, b=514)\n\n\n比如\n\ndef func(a, b=None, *args, **kwargs):\n    print (a)\n    print (b)\n    print (args)\n    print (kwargs)\n\nfunc(1, 14, *[514, 1919], chou='810')\n\n'''\n1\n14\n(514, 1919)\n{'chou': '810'}\n'''\n\n\n\n# Traceback\n\n报错了，怎么看traceback呢，它不像java的stacktrace那样读，有句话很关键: most recent call last，即最近的call是在最下面的！所以，整个过程是要从上往下看的。\n\ndef test(str):\n    print ('Hello, ' + st)\n\ntest('Tom')\n\n''' RUN\nTraceback (most recent call last):\n  File \"C:\\Users\\situ\\codes\\python\\test1.py\", line 4, in <module>\n    test('Tom')\n  File \"C:\\Users\\situ\\codes\\python\\test1.py\", line 2, in test\n    print ('Hello, ' + st)\nNameError: name 'st' is not defined\n'''\n\n\n\n# list vs array\n\n列表与数组，有什么区别呢？好像在python里面，我很少会见到array啊。经常见的，也就只有list和tuple，后者就是不可更改的前者。\n\n查阅之后，发现一个能放Any元素，一个只能放特定类型的元素，不过python呢，不自带array，只有list和tuple，所以想要数组的话，需要第三方包，比如numpy（怪不得我很少在py里见到array\n\n\n# scope\n\ndef test():\n    if some_condition:\n        a = 3\n    else:\n        a = 5\n    # If the above nesting created a new scope, \"a\" would\n    # now be out of scope.\n    print a\n\n\n就除了function和class之外，几乎是不存在scope的了。\n\n并且变量名就只是一个name而已，它指到某一个对象上。\n\n\n# main\n\n要想module里的class和函数外的语句不被import的时候调用，可以加这个来判断__main__，达到作为模块的时候不被执行的效果\n\nif __name == '__main__':\n    # do sth\n",normalizedContent:"# 问题记录\n\n\n# asterisk\n\nconversion between collections and arguments\n\n通常发生在函数invocation中。将参数转化为元组或者字典\n\n* collects all the positional arguments in a tuple.\n\n** collects all the keyword arguments in a dictionary.\n\ndef func(*args, **kargs):\n    # ...\nfunc(1, 14, 514, a=1, b=2, c=3)\n# args=[1, 14, 514] kargs = {'a':1, 'b':2, 'c':3}\n\n\n要列表、元组或字典解包为参数的时候，就可以这么做\n\n* unpacks a list or tuple into position arguments.\n\n** unpacks a dictionary into keyword arguments.\n\nl = [114, 514] # f(*l) -> f(114, 514)\nd = {'a': 114, 'b': 514} # f(**d) -> f(a=114, b=514)\n\n\n比如\n\ndef func(a, b=none, *args, **kwargs):\n    print (a)\n    print (b)\n    print (args)\n    print (kwargs)\n\nfunc(1, 14, *[514, 1919], chou='810')\n\n'''\n1\n14\n(514, 1919)\n{'chou': '810'}\n'''\n\n\n\n# traceback\n\n报错了，怎么看traceback呢，它不像java的stacktrace那样读，有句话很关键: most recent call last，即最近的call是在最下面的！所以，整个过程是要从上往下看的。\n\ndef test(str):\n    print ('hello, ' + st)\n\ntest('tom')\n\n''' run\ntraceback (most recent call last):\n  file \"c:\\users\\situ\\codes\\python\\test1.py\", line 4, in <module>\n    test('tom')\n  file \"c:\\users\\situ\\codes\\python\\test1.py\", line 2, in test\n    print ('hello, ' + st)\nnameerror: name 'st' is not defined\n'''\n\n\n\n# list vs array\n\n列表与数组，有什么区别呢？好像在python里面，我很少会见到array啊。经常见的，也就只有list和tuple，后者就是不可更改的前者。\n\n查阅之后，发现一个能放any元素，一个只能放特定类型的元素，不过python呢，不自带array，只有list和tuple，所以想要数组的话，需要第三方包，比如numpy（怪不得我很少在py里见到array\n\n\n# scope\n\ndef test():\n    if some_condition:\n        a = 3\n    else:\n        a = 5\n    # if the above nesting created a new scope, \"a\" would\n    # now be out of scope.\n    print a\n\n\n就除了function和class之外，几乎是不存在scope的了。\n\n并且变量名就只是一个name而已，它指到某一个对象上。\n\n\n# main\n\n要想module里的class和函数外的语句不被import的时候调用，可以加这个来判断__main__，达到作为模块的时候不被执行的效果\n\nif __name == '__main__':\n    # do sth\n",charsets:{cjk:!0}},{title:"问题大杂烩",frontmatter:{},regularPath:"/tools/problems.html",relativePath:"tools/problems.md",key:"v-2311a39b",path:"/tools/problems.html",headers:[{level:2,title:"VMware下Ubuntu掉网卡",slug:"vmware下ubuntu掉网卡",normalizedTitle:"vmware下ubuntu掉网卡",charIndex:12}],headersStr:"VMware下Ubuntu掉网卡",content:"# 问题大杂烩\n\n\n# VMware下Ubuntu掉网卡\n\n问题解答：点击此处\n\n只需要on off一下...\n\nnmcli network on\n",normalizedContent:"# 问题大杂烩\n\n\n# vmware下ubuntu掉网卡\n\n问题解答：点击此处\n\n只需要on off一下...\n\nnmcli network on\n",charsets:{cjk:!0}},{title:"魔法函数",frontmatter:{},regularPath:"/python/special_method.html",relativePath:"python/special_method.md",key:"v-0bee68b9",path:"/python/special_method.html",headers:[{level:2,title:"str",slug:"str",normalizedTitle:"str",charIndex:42},{level:2,title:"获取属性",slug:"获取属性",normalizedTitle:"获取属性",charIndex:263},{level:2,title:"Operator overloading",slug:"operator-overloading",normalizedTitle:"operator overloading",charIndex:468},{level:2,title:"Ellipsis & slice",slug:"ellipsis-slice",normalizedTitle:"ellipsis &amp; slice",charIndex:null}],headersStr:"str 获取属性 Operator overloading Ellipsis & slice",content:"# 魔法函数\n\n总的来说，一般是__开头和结尾的，就是了。如__init__, __str__等\n\n\n# str\n\n就像是Java里头的toString()\n\nclass Foo(object):\n    def __init__(self) -> None:\n        super().__init__()\n    def __str__(self) -> str:\n        return 'Hello from foo...'\n\nprint (Foo()) # Hello from foo...\n\n\n\n# 获取属性\n\npython对象的属性可以通过属性__dict__来获得\n\nclass Foo(object):\n    def __init__(self) -> None:\n        self.bar = 114514\n        self.bar1 = 1919810\n\nprint (Foo().__dict__) # {'bar': 114514, 'bar1': 1919810}\n\n\n\n# Operator overloading\n\n官方链接\n\npy通红也有运算符重载的操作，官方叫法叫做Emulating numeric types，通过实现相对应的方法，便可重载掉运算符\n\n> The following methods can be defined to emulate numeric objects. Methods corresponding to operations that are not supported by the particular kind of number implemented (e.g., bitwise operations for non-integral numbers) should be left undefined.\n\n支持这些个+, -, *, @, /, //, %, divmod(), pow(), **, <<, >>, &, ^, |, +=, -=, *=, @=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=，并且还能重载Math里的一些方法...(这里不讨论)例如\n\nobject.__add__(self, other)\n\nobject.__radd__(self, other)\n\nobject.__iadd__(self, other)\n\n分别是a+b b+a +=，没有实现的话就会返回一个NotImplemented\n\n而对于其中__rxxx__的方法\n\n> These functions are only called if the left operand does not support the corresponding operation 3 and the operands are of different types. 4 For instance, to evaluate the expression x - y, where y is an instance of a class that has an rsub() method, y.rsub(x) is called if x.sub(y) returns NotImplemented.\n\n例如\n\nclass Circle(object):\n    def __init__(self) -> None:\n        self.radius = 2\n    def get_area(self):\n        return self.radius * self.radius * 3.14\n    def __add__(self, other):\n        return self.get_area() + other.get_area()\n\nc1 = Circle()\nc2 = Circle()\n\nprint (c1 + c2) # 25.12\n\n\n\n# Ellipsis & slice\n\n铺垫，要讲下去，我们先要实现__getitem__方法，下面的内容才有意义（比如numpy就是实现了这个方法），比如这个，比如[1, 2, 3]就作为k给pass进__getitem__里面了，可以说是py里面的一种特殊的运算符重载操作\n\nclass T(object):\n    def __getitem__(self, k):\n        return k\n\nprint (T()[1, 2, 3])\nprint (T()[11:45:14])\nprint (T()[1, ..., 3])\nprint (T()[...])\nprint (T()[1, ..., 114:, :514, :])\n\n'''\n(1, 2, 3)\nslice(11, 45, 14)\n(1, Ellipsis, 3)\nEllipsis\n(1, Ellipsis, slice(114, None, None), slice(None, 514, None), slice(None, None, None))\n'''\n\n\n普通的[1, 2, 3]就是得到了tuple(1,2,3)\n\n又可以看到[11:45:14]在__getitem__(self, k)的作用下产生了一个slice对象，而slice对象的__init__是这样的\n\nclass slice(start, stop[, step])\n\n这样一来就可以理解了[11: 45: 14]是从11开始到45结束（不包括），步进是14.\n\n这个玩意平时不出现，但是到了机器学习这，就经常出现了，拿出现频率最高的numpy来说一下吧，一般是出现在对高维数组的refinement上。\n\n首先我们创建了一个三维数组\n\nimport numpy as np\nx = np.arange(27).reshape((3, 3, 3))\n'''\n[[[ 0  1  2]\n  [ 3  4  5]\n  [ 6  7  8]]\n\n [[ 9 10 11]\n  [12 13 14]\n  [15 16 17]]\n\n [[18 19 20]\n  [21 22 23]\n  [24 25 26]]]\n'''\n\n\n要refine?就用到了上面的那个神奇__getitem__(self, k)(numpy里面已经实现好了)，如果我们只要一个，比如19的话，那就是这样子来做一步一步来:x[2][0][1]。而如果我们要得到一维数组数组[19]的话那，直接x[2, 0, 1]\n\n加入:呢？这就是slice切片了，inclusive:exclusive这个样子的，比如0:就是从0到最后一个元素(inclusive)，而:2就是0≤element<20\\leq element < 20≤element<2了，同理2:3即2≤element<32\\leq element < 32≤element<3，一个:是啥，想必不用说了。上面也提到了。\n\n如果我们这样x[:2, :, 1:]切片，就是切成了这样，其实不用多说啥，划重点：看到上面19和[19]是怎么样refine的了吗？所以，总结规律，我们只需要按照正常的高维数组refinement的次序来思考怎么切，切哪里就行了。\n\nprint (x[:2, :, 1:])\n'''\n[[[ 1  2]\n  [ 4  5] \n  [ 7  8]]\n\n [[10 11]\n  [13 14]\n  [16 17]]]\n'''\n\n\n而那个Ellipsis而怎么理解呢？我觉得可以直接literally理解，就是“省略”之意。\n\n加入Ellipsis(其实是一个built-in constant)即...就是这样了，有一个五维的数组y，refinement本来是这样的:y[:2, :, :, :, 3:]就可以写成[:2, ..., 3:]了（在numpy的具体实现下），不愧就是Ellipsis省略之意啊。",normalizedContent:"# 魔法函数\n\n总的来说，一般是__开头和结尾的，就是了。如__init__, __str__等\n\n\n# str\n\n就像是java里头的tostring()\n\nclass foo(object):\n    def __init__(self) -> none:\n        super().__init__()\n    def __str__(self) -> str:\n        return 'hello from foo...'\n\nprint (foo()) # hello from foo...\n\n\n\n# 获取属性\n\npython对象的属性可以通过属性__dict__来获得\n\nclass foo(object):\n    def __init__(self) -> none:\n        self.bar = 114514\n        self.bar1 = 1919810\n\nprint (foo().__dict__) # {'bar': 114514, 'bar1': 1919810}\n\n\n\n# operator overloading\n\n官方链接\n\npy通红也有运算符重载的操作，官方叫法叫做emulating numeric types，通过实现相对应的方法，便可重载掉运算符\n\n> the following methods can be defined to emulate numeric objects. methods corresponding to operations that are not supported by the particular kind of number implemented (e.g., bitwise operations for non-integral numbers) should be left undefined.\n\n支持这些个+, -, *, @, /, //, %, divmod(), pow(), **, <<, >>, &, ^, |, +=, -=, *=, @=, /=, //=, %=, **=, <<=, >>=, &=, ^=, |=，并且还能重载math里的一些方法...(这里不讨论)例如\n\nobject.__add__(self, other)\n\nobject.__radd__(self, other)\n\nobject.__iadd__(self, other)\n\n分别是a+b b+a +=，没有实现的话就会返回一个notimplemented\n\n而对于其中__rxxx__的方法\n\n> these functions are only called if the left operand does not support the corresponding operation 3 and the operands are of different types. 4 for instance, to evaluate the expression x - y, where y is an instance of a class that has an rsub() method, y.rsub(x) is called if x.sub(y) returns notimplemented.\n\n例如\n\nclass circle(object):\n    def __init__(self) -> none:\n        self.radius = 2\n    def get_area(self):\n        return self.radius * self.radius * 3.14\n    def __add__(self, other):\n        return self.get_area() + other.get_area()\n\nc1 = circle()\nc2 = circle()\n\nprint (c1 + c2) # 25.12\n\n\n\n# ellipsis & slice\n\n铺垫，要讲下去，我们先要实现__getitem__方法，下面的内容才有意义（比如numpy就是实现了这个方法），比如这个，比如[1, 2, 3]就作为k给pass进__getitem__里面了，可以说是py里面的一种特殊的运算符重载操作\n\nclass t(object):\n    def __getitem__(self, k):\n        return k\n\nprint (t()[1, 2, 3])\nprint (t()[11:45:14])\nprint (t()[1, ..., 3])\nprint (t()[...])\nprint (t()[1, ..., 114:, :514, :])\n\n'''\n(1, 2, 3)\nslice(11, 45, 14)\n(1, ellipsis, 3)\nellipsis\n(1, ellipsis, slice(114, none, none), slice(none, 514, none), slice(none, none, none))\n'''\n\n\n普通的[1, 2, 3]就是得到了tuple(1,2,3)\n\n又可以看到[11:45:14]在__getitem__(self, k)的作用下产生了一个slice对象，而slice对象的__init__是这样的\n\nclass slice(start, stop[, step])\n\n这样一来就可以理解了[11: 45: 14]是从11开始到45结束（不包括），步进是14.\n\n这个玩意平时不出现，但是到了机器学习这，就经常出现了，拿出现频率最高的numpy来说一下吧，一般是出现在对高维数组的refinement上。\n\n首先我们创建了一个三维数组\n\nimport numpy as np\nx = np.arange(27).reshape((3, 3, 3))\n'''\n[[[ 0  1  2]\n  [ 3  4  5]\n  [ 6  7  8]]\n\n [[ 9 10 11]\n  [12 13 14]\n  [15 16 17]]\n\n [[18 19 20]\n  [21 22 23]\n  [24 25 26]]]\n'''\n\n\n要refine?就用到了上面的那个神奇__getitem__(self, k)(numpy里面已经实现好了)，如果我们只要一个，比如19的话，那就是这样子来做一步一步来:x[2][0][1]。而如果我们要得到一维数组数组[19]的话那，直接x[2, 0, 1]\n\n加入:呢？这就是slice切片了，inclusive:exclusive这个样子的，比如0:就是从0到最后一个元素(inclusive)，而:2就是0≤element<20\\leq element < 20≤element<2了，同理2:3即2≤element<32\\leq element < 32≤element<3，一个:是啥，想必不用说了。上面也提到了。\n\n如果我们这样x[:2, :, 1:]切片，就是切成了这样，其实不用多说啥，划重点：看到上面19和[19]是怎么样refine的了吗？所以，总结规律，我们只需要按照正常的高维数组refinement的次序来思考怎么切，切哪里就行了。\n\nprint (x[:2, :, 1:])\n'''\n[[[ 1  2]\n  [ 4  5] \n  [ 7  8]]\n\n [[10 11]\n  [13 14]\n  [16 17]]]\n'''\n\n\n而那个ellipsis而怎么理解呢？我觉得可以直接literally理解，就是“省略”之意。\n\n加入ellipsis(其实是一个built-in constant)即...就是这样了，有一个五维的数组y，refinement本来是这样的:y[:2, :, :, :, 3:]就可以写成[:2, ..., 3:]了（在numpy的具体实现下），不愧就是ellipsis省略之意啊。",charsets:{cjk:!0}},{title:"命名规范",frontmatter:{},regularPath:"/python/rules_naming.html",relativePath:"python/rules_naming.md",key:"v-4b85924e",path:"/python/rules_naming.html",headers:[{level:2,title:"大致一览",slug:"大致一览",normalizedTitle:"大致一览",charIndex:346},{level:2,title:"命名习惯",slug:"命名习惯",normalizedTitle:"命名习惯",charIndex:1312},{level:2,title:"要避免的",slug:"要避免的",normalizedTitle:"要避免的",charIndex:2784}],headersStr:"大致一览 命名习惯 要避免的",content:'# 命名规范\n\nStill, 一个很好的repo: StyleGuide(原文大部分摘抄自此)\n\n> Function names, variable names, and filenames should be descriptive; eschew abbreviation. In particular, do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.\n\n准则呢，还是要优先保证可读性与准确性，不要滥用模棱两可的缩写，更不要吞字\n\n\n# 大致一览\n\n摘抄了一些命名的示例，以便快速查阅\n\nmodule_name, package_name, ClassName, method_name, ExceptionName,function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name,function_parameter_name, local_var_name.\n\nTYPE                         PUBLIC               INTERNAL\nPackages                     lower_with_under     \nModules                      lower_with_under     _lower_with_under\nClasses                      CapWords             _CapWords\nExceptions                   CapWords             \nFunctions                    lower_with_under()   _lower_with_under()\nGlobal/Class Constants       CAPS_WITH_UNDER      _CAPS_WITH_UNDER\nGlobal/Class Variables       lower_with_under     _lower_with_under\nInstance Variables           lower_with_under     _lower_with_under (protected)\nMethod Names                 lower_with_under()   _lower_with_under() (protected)\nFunction/Method Parameters   lower_with_under     \nLocal Variables              lower_with_under     \n\n\n# 命名习惯\n\n简的来说就是：\n\n 1. 内部变量需要在前面加个underscore(_)\n 2. 将相关的类与顶端函数放在同一个module里，不像Java的那样严格。\n 3. 类名是每个单词首字母大写，如ClassExample\n 4. 不建议模块名跟类名重合，会产生歧义，如from Login import Login\n 5. 还有单元测试的规范，详情见下第五条\n\n----------------------------------------\n\n * "Internal" means internal to a module, or protected or private within a class.\n\n * Prepending a single underscore (_) has some support for protecting module variables and functions (linters will flag protected member access). While prepending a double underscore (__ aka "dunder") to an instance variable or method effectively makes the variable or method private to its class (using name mangling); we discourage its use as it impacts readability and testability, and isn\'t really private.\n\n * Place related classes and top-level functions together in a module. Unlike Java, there is no need to limit yourself to one class per module.\n\n * Use CapWords for class names, but lower_with_under.py for module names. Although there are some old modules named CapWords.py, this is now discouraged because it\'s confusing when the module happens to be named after a class. ("wait -- did I write import StringIO or from StringIO import StringIO?")\n\n * Underscores may appear in unittest method names starting with test to separate logical components of the name, even if those components use CapWords. One possible pattern is test<MethodUnderTest>_<state>; for example testPop_EmptyStack is okay. There is no One Correct Way to name test methods.\n\n\n# 要避免的\n\n 1. 避免一些有专门用途的单字母变量\n 2. 避免模块名和包名出现dash(-)\n 3. 避免如__main__这类的python预留变量或方法\n 4. 避免阴阳怪气的起名\n 5. 如果能直接看出类型，不需要在名字里塞类型\n\n----------------------------------------\n\n * single character names, except for specifically allowed cases:\n   \n   * counters or iterators (e.g. i, j, k, v, et al.)\n   * e as an exception identifier in try/except statements.\n   * f as a file handle in with statements\n   \n   Please be mindful not to abuse single-character naming. Generally speaking, descriptiveness should be proportional to the name\'s scope of visibility. For example, i might be a fine name for 5-line code block but within multiple nested scopes, it is likely too vague.\n\n * dashes (-) in any package/module name\n\n * __double_leading_and_trailing_underscore__ names (reserved by Python)\n\n * offensive terms\n\n * names that needlessly include the type of the variable (for example: id_to_name_dict)',normalizedContent:'# 命名规范\n\nstill, 一个很好的repo: styleguide(原文大部分摘抄自此)\n\n> function names, variable names, and filenames should be descriptive; eschew abbreviation. in particular, do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.\n\n准则呢，还是要优先保证可读性与准确性，不要滥用模棱两可的缩写，更不要吞字\n\n\n# 大致一览\n\n摘抄了一些命名的示例，以便快速查阅\n\nmodule_name, package_name, classname, method_name, exceptionname,function_name, global_constant_name, global_var_name, instance_var_name,function_parameter_name, local_var_name.\n\ntype                         public               internal\npackages                     lower_with_under     \nmodules                      lower_with_under     _lower_with_under\nclasses                      capwords             _capwords\nexceptions                   capwords             \nfunctions                    lower_with_under()   _lower_with_under()\nglobal/class constants       caps_with_under      _caps_with_under\nglobal/class variables       lower_with_under     _lower_with_under\ninstance variables           lower_with_under     _lower_with_under (protected)\nmethod names                 lower_with_under()   _lower_with_under() (protected)\nfunction/method parameters   lower_with_under     \nlocal variables              lower_with_under     \n\n\n# 命名习惯\n\n简的来说就是：\n\n 1. 内部变量需要在前面加个underscore(_)\n 2. 将相关的类与顶端函数放在同一个module里，不像java的那样严格。\n 3. 类名是每个单词首字母大写，如classexample\n 4. 不建议模块名跟类名重合，会产生歧义，如from login import login\n 5. 还有单元测试的规范，详情见下第五条\n\n----------------------------------------\n\n * "internal" means internal to a module, or protected or private within a class.\n\n * prepending a single underscore (_) has some support for protecting module variables and functions (linters will flag protected member access). while prepending a double underscore (__ aka "dunder") to an instance variable or method effectively makes the variable or method private to its class (using name mangling); we discourage its use as it impacts readability and testability, and isn\'t really private.\n\n * place related classes and top-level functions together in a module. unlike java, there is no need to limit yourself to one class per module.\n\n * use capwords for class names, but lower_with_under.py for module names. although there are some old modules named capwords.py, this is now discouraged because it\'s confusing when the module happens to be named after a class. ("wait -- did i write import stringio or from stringio import stringio?")\n\n * underscores may appear in unittest method names starting with test to separate logical components of the name, even if those components use capwords. one possible pattern is test<methodundertest>_<state>; for example testpop_emptystack is okay. there is no one correct way to name test methods.\n\n\n# 要避免的\n\n 1. 避免一些有专门用途的单字母变量\n 2. 避免模块名和包名出现dash(-)\n 3. 避免如__main__这类的python预留变量或方法\n 4. 避免阴阳怪气的起名\n 5. 如果能直接看出类型，不需要在名字里塞类型\n\n----------------------------------------\n\n * single character names, except for specifically allowed cases:\n   \n   * counters or iterators (e.g. i, j, k, v, et al.)\n   * e as an exception identifier in try/except statements.\n   * f as a file handle in with statements\n   \n   please be mindful not to abuse single-character naming. generally speaking, descriptiveness should be proportional to the name\'s scope of visibility. for example, i might be a fine name for 5-line code block but within multiple nested scopes, it is likely too vague.\n\n * dashes (-) in any package/module name\n\n * __double_leading_and_trailing_underscore__ names (reserved by python)\n\n * offensive terms\n\n * names that needlessly include the type of the variable (for example: id_to_name_dict)',charsets:{cjk:!0}},{title:"基础",frontmatter:{},regularPath:"/react/basis.html",relativePath:"react/basis.md",key:"v-36459e7f",path:"/react/basis.html",headers:[{level:2,title:"Component",slug:"component",normalizedTitle:"component",charIndex:61}],headersStr:"Component",content:'# 基础\n\n记录一些基础。React是个JS框架，用于方便从小且独立的代码即components开始构建用户界面\n\n\n# Component\n\ncomponent有一些property如props, state。\n\nprops是创建这个对象时候传进去的，state可以认为是对象私有的properties\n\n比如\n\nclass Foo extends React.Component {\n    render() {\n        return (\n            <div>\n                {this.props.value}\n            </div>\n        );\n    }\n}\n\nconst element = <Foo value="114514" />;\n\n\n传了个value进去，props对象就含有value\n\n其实上面这个JSX语句<Foo value="114514" />等价于下面这个\n\nReact.createElement(Foo, {\n  value: "114514"\n});\n\n\ncomponent除了可以声明为一个继承自React.Component的类，还可以是一个Function\n\nfunction Foo(props) {\n    return (\n        <div>\n            {this.props.value}\n        </div>\n    );\n}\n\n\n为了使react能定位render的时候有哪些element变化了，需要一个key，这是一个特殊的预留属性。可以在创建对象的时候定义一个。',normalizedContent:'# 基础\n\n记录一些基础。react是个js框架，用于方便从小且独立的代码即components开始构建用户界面\n\n\n# component\n\ncomponent有一些property如props, state。\n\nprops是创建这个对象时候传进去的，state可以认为是对象私有的properties\n\n比如\n\nclass foo extends react.component {\n    render() {\n        return (\n            <div>\n                {this.props.value}\n            </div>\n        );\n    }\n}\n\nconst element = <foo value="114514" />;\n\n\n传了个value进去，props对象就含有value\n\n其实上面这个jsx语句<foo value="114514" />等价于下面这个\n\nreact.createelement(foo, {\n  value: "114514"\n});\n\n\ncomponent除了可以声明为一个继承自react.component的类，还可以是一个function\n\nfunction foo(props) {\n    return (\n        <div>\n            {this.props.value}\n        </div>\n    );\n}\n\n\n为了使react能定位render的时候有哪些element变化了，需要一个key，这是一个特殊的预留属性。可以在创建对象的时候定义一个。',charsets:{cjk:!0}},{title:"做笔记",frontmatter:{},regularPath:"/tools/taking_notes.html",relativePath:"tools/taking_notes.md",key:"v-1dda9912",path:"/tools/taking_notes.html",headers:[{level:2,title:"Markdown",slug:"markdown",normalizedTitle:"markdown",charIndex:55},{level:2,title:"LaTeX",slug:"latex",normalizedTitle:"latex",charIndex:69},{level:3,title:"速查表格",slug:"速查表格",normalizedTitle:"速查表格",charIndex:82},{level:2,title:"Markdown extension",slug:"markdown-extension",normalizedTitle:"markdown extension",charIndex:92},{level:3,title:"toc",slug:"toc",normalizedTitle:"toc",charIndex:118},{level:3,title:"Github-Style Tables",slug:"github-style-tables",normalizedTitle:"github-style tables",charIndex:129},{level:3,title:"Custom container",slug:"custom-container",normalizedTitle:"custom container",charIndex:156}],headersStr:"Markdown LaTeX 速查表格 Markdown extension toc Github-Style Tables Custom container",content:'# 做笔记\n\nHow to take notes with vuepress?\n\n\n\n * 做笔记\n   * Markdown\n   * LaTeX\n     * 速查表格\n   * Markdown extension\n     * toc\n     * Github-Style Tables\n     * Custom container\n\n\n\n\n# Markdown\n\n这个真好用\n\n这是一种用于快速写formatted的文章的lightweight markup language\n\n主要是要了解它的一些syntax之类的，我平时参考的是这个表格\n\n### Heading\n\n# H1\n\n## H2\n\n### H3\n\n### Bold\n\n**bold text**\n\n### Italic\n\n*italicized text*\n\n### Blockquote\n\n> blockquote\n\n### Ordered List\n\n1. First item\n2. Second item\n3. Third item\n\n### Unordered List\n\n- First item\n- Second item\n- Third item\n\n### Code\n\n`code`\n\n### Horizontal Rule\n\n---\n\n### Link\n\n[title](https://www.example.com)\n\n### Image\n\n![alt text](image.jpg)\n\n## Extended Syntax\n\nThese elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements.\n\n### Table\n\n| Syntax    | Description |\n| --------- | ----------- |\n| Header    | Title       |\n| Paragraph | Text        |\n\n### Fenced Code Block\n\n` x3 + your language\n{\n  "firstName": "John",\n  "lastName": "Smith",\n  "age": 25\n}\n` x3\n\n### Footnote\n\nHere\'s a sentence with a footnote. [^1]\n\n[^1]: This is the footnote.\n\n### Heading ID\n\n### My Great Heading {#custom-id}\n\n### Definition List\n\nterm\n: definition\n\n### Strikethrough\n\n~~The world is flat.~~\n\n### Task List\n\n- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\n\n然后详细的syntax介绍就是来自于这个网页了: Markdown Guide\n\n\n# LaTeX\n\nLaTeXLaTeXLaTeX是一个用来写数学公式的typesetting system\n\n所以怎么用的，在markdown-it-katex插件下，要遵循的语法是\n\n 1. Anything between two $ characters will be treated as TeX math.\n 2. The opening $ must have a non-space character immediately to its right, while the closing $ must have a non-space character immediately to its left, and must not be followed immediately by a digit. Thus, $20,000 and $30,000 won’t parse as math.\n 3. If for some reason you need to enclose text in literal $ characters,backslash-escape them and they won’t be treated as math delimiters.\n\n目前，我的符号的查询有两种途径，但是相比起来呢，后者似乎更全一些，因为logic notation这些运算符，我在Wiki那边倒是没有找到。\n\n比较全面的是\n\nhttps://latex.wikia.org/wiki/List_of_LaTeX_symbols\n\n还有一些\n\n 1. https://en.wikipedia.org/wiki/Wikipedia:LaTeX_symbols\n 2. https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols\n\n----------------------------------------\n\n\n# 速查表格\n\n符号                               LATEX\n∑i=0m\\sum_{i=0}^{m}∑i=0m         \\sum_{i=0}^{m}\n114514\\frac{114}{514}514114      \\frac{114}{514}\nfˉ\\bar{f}fˉ                      \\bar{f}\nE\\mathbb{E}E                     \\mathbb{E}\n∫114514\\int^{514}_{114}∫114514   \\int^{514}_{114}\nx⃗\\vec{x}x                       \\vec{x}\nΔv\\Delta vΔv                     \\Delta v\n∀\\forall∀                        \\forall\n∃\\exists∃                        \\exists\n114≤514114\\leq 514114≤514        $114\\leq 514$\n\n----------------------------------------\n\n\n# Markdown extension\n\n\n# toc\n\n[[toc]]可以直接得到目录\n\n\n\n * 做笔记\n   * Markdown\n   * LaTeX\n     * 速查表格\n   * Markdown extension\n     * toc\n     * Github-Style Tables\n     * Custom container\n\n\n\n\n# Github-Style Tables\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n\nTABLES          ARE             COOL\ncol 3 is        right-aligned   $1600\ncol 2 is        centered        $12\nzebra stripes   are neat        $1\n\n\n# Custom container\n\n::: tip\nThis is a tip\n:::\n\n::: warning\nThis is a warning\n:::\n\n::: danger\nThis is a dangerous warning\n:::\n\n::: details\nThis is a details block, which does not work in IE / Edge\n:::\n\n\nTIP\n\nThis is a tip\n\nWARNING\n\nThis is a warning\n\nWARNING\n\nThis is a dangerous warning\n\nDETAILS\n\nThis is a details block, which does not work in IE / Edge',normalizedContent:'# 做笔记\n\nhow to take notes with vuepress?\n\n\n\n * 做笔记\n   * markdown\n   * latex\n     * 速查表格\n   * markdown extension\n     * toc\n     * github-style tables\n     * custom container\n\n\n\n\n# markdown\n\n这个真好用\n\n这是一种用于快速写formatted的文章的lightweight markup language\n\n主要是要了解它的一些syntax之类的，我平时参考的是这个表格\n\n### heading\n\n# h1\n\n## h2\n\n### h3\n\n### bold\n\n**bold text**\n\n### italic\n\n*italicized text*\n\n### blockquote\n\n> blockquote\n\n### ordered list\n\n1. first item\n2. second item\n3. third item\n\n### unordered list\n\n- first item\n- second item\n- third item\n\n### code\n\n`code`\n\n### horizontal rule\n\n---\n\n### link\n\n[title](https://www.example.com)\n\n### image\n\n![alt text](image.jpg)\n\n## extended syntax\n\nthese elements extend the basic syntax by adding additional features. not all markdown applications support these elements.\n\n### table\n\n| syntax    | description |\n| --------- | ----------- |\n| header    | title       |\n| paragraph | text        |\n\n### fenced code block\n\n` x3 + your language\n{\n  "firstname": "john",\n  "lastname": "smith",\n  "age": 25\n}\n` x3\n\n### footnote\n\nhere\'s a sentence with a footnote. [^1]\n\n[^1]: this is the footnote.\n\n### heading id\n\n### my great heading {#custom-id}\n\n### definition list\n\nterm\n: definition\n\n### strikethrough\n\n~~the world is flat.~~\n\n### task list\n\n- [x] write the press release\n- [ ] update the website\n- [ ] contact the media\n\n\n然后详细的syntax介绍就是来自于这个网页了: markdown guide\n\n\n# latex\n\nlatexlatexlatex是一个用来写数学公式的typesetting system\n\n所以怎么用的，在markdown-it-katex插件下，要遵循的语法是\n\n 1. anything between two $ characters will be treated as tex math.\n 2. the opening $ must have a non-space character immediately to its right, while the closing $ must have a non-space character immediately to its left, and must not be followed immediately by a digit. thus, $20,000 and $30,000 won’t parse as math.\n 3. if for some reason you need to enclose text in literal $ characters,backslash-escape them and they won’t be treated as math delimiters.\n\n目前，我的符号的查询有两种途径，但是相比起来呢，后者似乎更全一些，因为logic notation这些运算符，我在wiki那边倒是没有找到。\n\n比较全面的是\n\nhttps://latex.wikia.org/wiki/list_of_latex_symbols\n\n还有一些\n\n 1. https://en.wikipedia.org/wiki/wikipedia:latex_symbols\n 2. https://oeis.org/wiki/list_of_latex_mathematical_symbols\n\n----------------------------------------\n\n\n# 速查表格\n\n符号                               latex\n∑i=0m\\sum_{i=0}^{m}∑i=0m         \\sum_{i=0}^{m}\n114514\\frac{114}{514}514114      \\frac{114}{514}\nfˉ\\bar{f}fˉ                      \\bar{f}\ne\\mathbb{e}e                     \\mathbb{e}\n∫114514\\int^{514}_{114}∫114514   \\int^{514}_{114}\nx⃗\\vec{x}x                       \\vec{x}\nδv\\delta vδv                     \\delta v\n∀\\forall∀                        \\forall\n∃\\exists∃                        \\exists\n114≤514114\\leq 514114≤514        $114\\leq 514$\n\n----------------------------------------\n\n\n# markdown extension\n\n\n# toc\n\n[[toc]]可以直接得到目录\n\n\n\n * 做笔记\n   * markdown\n   * latex\n     * 速查表格\n   * markdown extension\n     * toc\n     * github-style tables\n     * custom container\n\n\n\n\n# github-style tables\n\n| tables        | are           | cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n\ntables          are             cool\ncol 3 is        right-aligned   $1600\ncol 2 is        centered        $12\nzebra stripes   are neat        $1\n\n\n# custom container\n\n::: tip\nthis is a tip\n:::\n\n::: warning\nthis is a warning\n:::\n\n::: danger\nthis is a dangerous warning\n:::\n\n::: details\nthis is a details block, which does not work in ie / edge\n:::\n\n\ntip\n\nthis is a tip\n\nwarning\n\nthis is a warning\n\nwarning\n\nthis is a dangerous warning\n\ndetails\n\nthis is a details block, which does not work in ie / edge',charsets:{cjk:!0}}],themeConfig:{nav:[{text:"Blog",link:"https://blog.situ2001.com"},{text:"GitHub",link:"https://github.com/situ2001"}],sidebarDepth:2,sidebar:[{title:"Tools",children:["./tools/taking_notes.md","./tools/problems.md"]},{title:"Java",children:["./java/basis.md","./java/problems.md","./java/feature_jdk.md","./java/multithreading.md","./java/design_patterns.md","./java/reflection.md"]},{title:"JavaScript",children:["./javascript/background.md","./javascript/problems.md","./javascript/common_function.md","./javascript/built_in_object.md","./javascript/object.md","./javascript/function.md","./javascript/class_and_module.md","./javascript/asynchronous.md","./javascript/iteration.md"]},{title:"Python",children:["./python/rules_naming.md","./python/built_in_things.md","./python/special.md","./python/special_method.md","./python/problems.md","./python/ducking_type.md"]},{title:"C/C++",children:["./cpp/snippet.md","./cpp/keywords.md","./cpp/rules_naming.md","./cpp/header.md","./cpp/oop.md","./cpp/problems.md"]},{title:"数据结构与算法",children:["./dsa/basis.md","./dsa/approach.md"]},{title:"Linux",children:["./linux/commands.md","./linux/shell.md"]},{title:"Git",children:["./git/gitignore.md"]},{title:"HTTP",children:["./http/cors.md"]},{title:"React",children:["./react/basis.md"]},{title:"Node.js",children:["./nodejs/problems.md","./nodejs/package_management.md"]},{title:"框架",children:["./frameworks/tensorflow.md","./frameworks/electron.md"]},{title:"课程",children:["./lessons/digital_circuits.md","./lessons/discrete_mathematics.md","./lessons/ml_and_big_data.md"]}]}};t(143);Eo.component("CodeGroup",()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,224))),Eo.component("CodeBlock",()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,225))),Eo.component("Badge",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,278)));t(144);var is=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{}],ss=[];class ls extends class{constructor(){this.store=new Eo({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Eo.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(ls.prototype,{getPageAsyncComponent:Fi,getLayoutAsyncComponent:Di,getAsyncComponent:qi,getVueComponent:Bi});var cs={install(n){const e=new ls;n.$vuepress=e,n.prototype.$vuepress=e}};function us(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var ds={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Mi("pageKey",e),Eo.component(e)||Eo.component(e,Fi(e)),Eo.component(e)?n(e):n("")}},ps={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},fs={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},hs=(t(145),t(146),Object(ts.a)(fs,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),ms={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Eo.config.productionTip=!1,Eo.use(_i),Eo.use(cs),Eo.mixin(function(n,e,t=Eo){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},as)),Eo.component("Content",ds),Eo.component("ContentSlotsDistributor",ps),Eo.component("OutboundLink",hs),Eo.component("ClientOnly",ms),Eo.component("Layout",Di("Layout")),Eo.component("NotFound",Di("NotFound")),Eo.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.2",hash:"7d909eb"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:as.routerBase||as.base,t=new _i({base:e,mode:"history",fallback:!1,routes:os,scrollBehavior:(n,e,t)=>t||(n.hash?!Eo.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(us(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";us(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";us(n,o)?r(o):us(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(is.filter(n=>"function"==typeof n).map(e=>e({Vue:Eo,options:r,router:t,siteData:as,isServer:n})))}catch(n){console.error(n)}return{app:new Eo(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ss.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);